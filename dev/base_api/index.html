<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Base API · VLBISkyModels.jl</title><meta name="title" content="Base API · VLBISkyModels.jl"/><meta property="og:title" content="Base API · VLBISkyModels.jl"/><meta property="twitter:title" content="Base API · VLBISkyModels.jl"/><meta name="description" content="Documentation for VLBISkyModels.jl."/><meta property="og:description" content="Documentation for VLBISkyModels.jl."/><meta property="twitter:description" content="Documentation for VLBISkyModels.jl."/><meta property="og:url" content="https://ehtjulia.github.io/VLBISkyModels.jl/base_api/"/><meta property="twitter:url" content="https://ehtjulia.github.io/VLBISkyModels.jl/base_api/"/><link rel="canonical" href="https://ehtjulia.github.io/VLBISkyModels.jl/base_api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">VLBISkyModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../interface/">Model Interface</a></li><li><a class="tocitem" href="../api/">API</a></li><li class="is-active"><a class="tocitem" href>Base API</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Model-API"><span>Model API</span></a></li><li><a class="tocitem" href="#Polarization"><span>Polarization</span></a></li><li><a class="tocitem" href="#Internal-Methods-not-part-of-public-API"><span>Internal Methods not part of public API</span></a></li></ul></li><li><a class="tocitem" href="../examples/nonanalytic/">Non-Analytic Modeling</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Base API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Base API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/EHTJulia/VLBISkyModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/main/docs/src/base_api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Base-API"><a class="docs-heading-anchor" href="#Base-API">Base API</a><a id="Base-API-1"></a><a class="docs-heading-anchor-permalink" href="#Base-API" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Base-API">Base API</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li><li><a href="#Model-API">Model API</a></li><li><a href="#Polarization">Polarization</a></li><li><a href="#Internal-Methods-not-part-of-public-API">Internal Methods not part of public API</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#ComradeBase.AbstractDualDomain"><code>ComradeBase.AbstractDualDomain</code></a></li><li><a href="#ComradeBase.AbstractModel"><code>ComradeBase.AbstractModel</code></a></li><li><a href="#ComradeBase.AbstractPolarizedModel"><code>ComradeBase.AbstractPolarizedModel</code></a></li><li><a href="#ComradeBase.DensityAnalytic"><code>ComradeBase.DensityAnalytic</code></a></li><li><a href="#ComradeBase.DomainParams"><code>ComradeBase.DomainParams</code></a></li><li><a href="#ComradeBase.DualMap"><code>ComradeBase.DualMap</code></a></li><li><a href="#ComradeBase.IntensityMap-Tuple{AbstractArray, ComradeBase.AbstractRectiGrid}"><code>ComradeBase.IntensityMap</code></a></li><li><a href="#ComradeBase.IntensityMap"><code>ComradeBase.IntensityMap</code></a></li><li><a href="#ComradeBase.IsAnalytic"><code>ComradeBase.IsAnalytic</code></a></li><li><a href="#ComradeBase.MinimalHeader"><code>ComradeBase.MinimalHeader</code></a></li><li><a href="#ComradeBase.NoHeader"><code>ComradeBase.NoHeader</code></a></li><li><a href="#ComradeBase.NotAnalytic"><code>ComradeBase.NotAnalytic</code></a></li><li><a href="#ComradeBase.ReactantEx"><code>ComradeBase.ReactantEx</code></a></li><li><a href="#ComradeBase.RectiGrid"><code>ComradeBase.RectiGrid</code></a></li><li><a href="#ComradeBase.Serial"><code>ComradeBase.Serial</code></a></li><li><a href="#ComradeBase.ThreadsEx"><code>ComradeBase.ThreadsEx</code></a></li><li><a href="#ComradeBase.UnstructuredDomain"><code>ComradeBase.UnstructuredDomain</code></a></li><li><a href="#ComradeBase.UnstructuredMap"><code>ComradeBase.UnstructuredMap</code></a></li><li><a href="#PolarizedTypes.CirBasis"><code>PolarizedTypes.CirBasis</code></a></li><li><a href="#PolarizedTypes.CoherencyMatrix"><code>PolarizedTypes.CoherencyMatrix</code></a></li><li><a href="#PolarizedTypes.ElectricFieldBasis"><code>PolarizedTypes.ElectricFieldBasis</code></a></li><li><a href="#PolarizedTypes.LPol"><code>PolarizedTypes.LPol</code></a></li><li><a href="#PolarizedTypes.LinBasis"><code>PolarizedTypes.LinBasis</code></a></li><li><a href="#PolarizedTypes.PolBasis"><code>PolarizedTypes.PolBasis</code></a></li><li><a href="#PolarizedTypes.RPol"><code>PolarizedTypes.RPol</code></a></li><li><a href="#PolarizedTypes.StokesParams"><code>PolarizedTypes.StokesParams</code></a></li><li><a href="#PolarizedTypes.XPol"><code>PolarizedTypes.XPol</code></a></li><li><a href="#PolarizedTypes.YPol"><code>PolarizedTypes.YPol</code></a></li><li><a href="#ComradeBase._visibilitymap"><code>ComradeBase._visibilitymap</code></a></li><li><a href="#ComradeBase._visibilitymap!"><code>ComradeBase._visibilitymap!</code></a></li><li><a href="#ComradeBase.allocate_imgmap"><code>ComradeBase.allocate_imgmap</code></a></li><li><a href="#ComradeBase.allocate_vismap"><code>ComradeBase.allocate_vismap</code></a></li><li><a href="#ComradeBase.amplitude-Tuple{Any, Any}"><code>ComradeBase.amplitude</code></a></li><li><a href="#ComradeBase.amplitudemap"><code>ComradeBase.amplitudemap</code></a></li><li><a href="#ComradeBase.axisdims"><code>ComradeBase.axisdims</code></a></li><li><a href="#ComradeBase.baseimage"><code>ComradeBase.baseimage</code></a></li><li><a href="#ComradeBase.bispectrum"><code>ComradeBase.bispectrum</code></a></li><li><a href="#ComradeBase.bispectrummap"><code>ComradeBase.bispectrummap</code></a></li><li><a href="#ComradeBase.build_param"><code>ComradeBase.build_param</code></a></li><li><a href="#ComradeBase.centroid"><code>ComradeBase.centroid</code></a></li><li><a href="#ComradeBase.closure_phase"><code>ComradeBase.closure_phase</code></a></li><li><a href="#ComradeBase.closure_phasemap"><code>ComradeBase.closure_phasemap</code></a></li><li><a href="#ComradeBase.create_imgmap"><code>ComradeBase.create_imgmap</code></a></li><li><a href="#ComradeBase.create_map"><code>ComradeBase.create_map</code></a></li><li><a href="#ComradeBase.create_vismap"><code>ComradeBase.create_vismap</code></a></li><li><a href="#ComradeBase.domainpoints"><code>ComradeBase.domainpoints</code></a></li><li><a href="#ComradeBase.dualmap"><code>ComradeBase.dualmap</code></a></li><li><a href="#ComradeBase.executor"><code>ComradeBase.executor</code></a></li><li><a href="#ComradeBase.fieldofview"><code>ComradeBase.fieldofview</code></a></li><li><a href="#ComradeBase.flux"><code>ComradeBase.flux</code></a></li><li><a href="#ComradeBase.getparam"><code>ComradeBase.getparam</code></a></li><li><a href="#ComradeBase.header"><code>ComradeBase.header</code></a></li><li><a href="#ComradeBase.imagepixels"><code>ComradeBase.imagepixels</code></a></li><li><a href="#ComradeBase.imanalytic"><code>ComradeBase.imanalytic</code></a></li><li><a href="#ComradeBase.intensity_point"><code>ComradeBase.intensity_point</code></a></li><li><a href="#ComradeBase.intensitymap"><code>ComradeBase.intensitymap</code></a></li><li><a href="#ComradeBase.intensitymap!"><code>ComradeBase.intensitymap!</code></a></li><li><a href="#ComradeBase.intensitymap_analytic"><code>ComradeBase.intensitymap_analytic</code></a></li><li><a href="#ComradeBase.intensitymap_analytic!"><code>ComradeBase.intensitymap_analytic!</code></a></li><li><a href="#ComradeBase.intensitymap_numeric"><code>ComradeBase.intensitymap_numeric</code></a></li><li><a href="#ComradeBase.intensitymap_numeric!"><code>ComradeBase.intensitymap_numeric!</code></a></li><li><a href="#ComradeBase.ispolarized"><code>ComradeBase.ispolarized</code></a></li><li><a href="#ComradeBase.logclosure_amplitude"><code>ComradeBase.logclosure_amplitude</code></a></li><li><a href="#ComradeBase.logclosure_amplitudemap"><code>ComradeBase.logclosure_amplitudemap</code></a></li><li><a href="#ComradeBase.named_dims"><code>ComradeBase.named_dims</code></a></li><li><a href="#ComradeBase.paramtype"><code>ComradeBase.paramtype</code></a></li><li><a href="#ComradeBase.phasecenter"><code>ComradeBase.phasecenter</code></a></li><li><a href="#ComradeBase.pixelsizes"><code>ComradeBase.pixelsizes</code></a></li><li><a href="#ComradeBase.radialextent"><code>ComradeBase.radialextent</code></a></li><li><a href="#ComradeBase.second_moment"><code>ComradeBase.second_moment</code></a></li><li><a href="#ComradeBase.stokes"><code>ComradeBase.stokes</code></a></li><li><a href="#ComradeBase.visanalytic"><code>ComradeBase.visanalytic</code></a></li><li><a href="#ComradeBase.visibility"><code>ComradeBase.visibility</code></a></li><li><a href="#ComradeBase.visibility_point"><code>ComradeBase.visibility_point</code></a></li><li><a href="#ComradeBase.visibilitymap"><code>ComradeBase.visibilitymap</code></a></li><li><a href="#ComradeBase.visibilitymap!"><code>ComradeBase.visibilitymap!</code></a></li><li><a href="#ComradeBase.visibilitymap_analytic"><code>ComradeBase.visibilitymap_analytic</code></a></li><li><a href="#ComradeBase.visibilitymap_analytic!"><code>ComradeBase.visibilitymap_analytic!</code></a></li><li><a href="#ComradeBase.visibilitymap_numeric"><code>ComradeBase.visibilitymap_numeric</code></a></li><li><a href="#ComradeBase.visibilitymap_numeric!"><code>ComradeBase.visibilitymap_numeric!</code></a></li><li><a href="#DimensionalData.Dimensions.dims"><code>DimensionalData.Dimensions.dims</code></a></li><li><a href="#PolarizedTypes.basis_components"><code>PolarizedTypes.basis_components</code></a></li><li><a href="#PolarizedTypes.basis_transform"><code>PolarizedTypes.basis_transform</code></a></li><li><a href="#PolarizedTypes.evpa"><code>PolarizedTypes.evpa</code></a></li><li><a href="#PolarizedTypes.fracpolarization-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><code>PolarizedTypes.fracpolarization</code></a></li><li><a href="#PolarizedTypes.fracpolarization"><code>PolarizedTypes.fracpolarization</code></a></li><li><a href="#PolarizedTypes.innerprod"><code>PolarizedTypes.innerprod</code></a></li><li><a href="#PolarizedTypes.linearpol"><code>PolarizedTypes.linearpol</code></a></li><li><a href="#PolarizedTypes.mbreve-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><code>PolarizedTypes.mbreve</code></a></li><li><a href="#PolarizedTypes.mpol-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><code>PolarizedTypes.mpol</code></a></li><li><a href="#PolarizedTypes.m̆"><code>PolarizedTypes.m̆</code></a></li><li><a href="#PolarizedTypes.polarization"><code>PolarizedTypes.polarization</code></a></li><li><a href="#PolarizedTypes.polarization-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><code>PolarizedTypes.polarization</code></a></li><li><a href="#PolarizedTypes.polellipse-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><code>PolarizedTypes.polellipse</code></a></li><li><a href="#ComradeBase.@threaded"><code>ComradeBase.@threaded</code></a></li><li><a href="#ComradeBase.@unpack_params"><code>ComradeBase.@unpack_params</code></a></li></ul><h2 id="Model-API"><a class="docs-heading-anchor" href="#Model-API">Model API</a><a id="Model-API-1"></a><a class="docs-heading-anchor-permalink" href="#Model-API" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ComradeBase.flux"><a class="docstring-binding" href="#ComradeBase.flux"><code>ComradeBase.flux</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">flux(im::IntensityMap)</code></pre><p>Computes the flux of a intensity map</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/images/methods.jl#L116-L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.visibility"><a class="docstring-binding" href="#ComradeBase.visibility"><code>ComradeBase.visibility</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">visibility(mimg, p)</code></pre><p>Computes the complex visibility of model <code>m</code> at coordinates <code>p</code>. <code>p</code> corresponds to the coordinates of the model. These need to have the properties <code>U</code>, <code>V</code> and sometimes <code>Ti</code> for time and <code>Fr</code> for frequency.</p><p><strong>Notes</strong></p><p>If you want to compute the visibilities at a large number of positions consider using the <a href="#ComradeBase.visibilitymap"><code>visibilitymap</code></a>.</p><p><strong>Warn</strong></p><p>This is only defined for analytic models. If you want to compute the visibility for a single point for a non-analytic model, please use the <code>visibilitymap</code> function and create an <code>UnstructuredDomain</code> with a single point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/models/visibilities.jl#L86-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.dualmap"><a class="docstring-binding" href="#ComradeBase.dualmap"><code>ComradeBase.dualmap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dualmap(m::AbstractModel, dims::AbstractDualDomain)</code></pre><p>Computes both the intensity map and visibility map of the <code>model</code>. This can be faster than computing them separately as some intermediate results can be reused. This returns a <code>DualMap</code> which holds the intensity map and visibility map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/domain.jl#L154-L160">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.visibilitymap"><a class="docstring-binding" href="#ComradeBase.visibilitymap"><code>ComradeBase.visibilitymap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">visibilitymap(model::AbstractModel, p)</code></pre><p>Computes the complex visibilities at the locations p.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L211-L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.visibilitymap!"><a class="docstring-binding" href="#ComradeBase.visibilitymap!"><code>ComradeBase.visibilitymap!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">visibilitymap!(vis::AbstractArray, model::AbstractModel, p)</code></pre><p>Computes the complex visibilities <code>vis</code> in place at the locations p</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L218-L222">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.intensitymap"><a class="docstring-binding" href="#ComradeBase.intensitymap"><code>ComradeBase.intensitymap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">intensitymap(model::AbstractModel, p::AbstractSingleDomain)</code></pre><p>Computes the intensity map of model. For the inplace version see <a href="#ComradeBase.intensitymap!"><code>intensitymap!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L163-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.intensitymap!"><a class="docstring-binding" href="#ComradeBase.intensitymap!"><code>ComradeBase.intensitymap!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">intensitymap!(buffer::AbstractDimArray, model::AbstractModel)</code></pre><p>Computes the intensity map of <code>model</code> by modifying the <code>buffer</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L156-L160">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.allocate_vismap"><a class="docstring-binding" href="#ComradeBase.allocate_vismap"><code>ComradeBase.allocate_vismap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">allocate_vismap(m::AbstractModel, g::AbstractSingleDomain)</code></pre><p>Allocate the default map specialized by the grid <code>g</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/domain.jl#L52-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.allocate_imgmap"><a class="docstring-binding" href="#ComradeBase.allocate_imgmap"><code>ComradeBase.allocate_imgmap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">allocate_imgmap(m::AbstractModel, g::AbstractSingleDomain)</code></pre><p>Allocate the default map specialized by the grid <code>g</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/domain.jl#L45-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.create_imgmap"><a class="docstring-binding" href="#ComradeBase.create_imgmap"><code>ComradeBase.create_imgmap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_imgmap(array, g::AbstractSingleDomain)</code></pre><p>Create a map of values specialized by the grid <code>g</code> in the image domain. The default is to call <code>create_map</code> with the same arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/domain.jl#L37-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.create_vismap"><a class="docstring-binding" href="#ComradeBase.create_vismap"><code>ComradeBase.create_vismap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_vismap(array, g::AbstractSingleDomain)</code></pre><p>Create a map of values specialized by the grid <code>g</code> in the visibility domain. The default is to call <code>create_map</code> with the same arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/domain.jl#L29-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.amplitude-Tuple{Any, Any}"><a class="docstring-binding" href="#ComradeBase.amplitude-Tuple{Any, Any}"><code>ComradeBase.amplitude</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">amplitude(model, p)</code></pre><p>Computes the visibility amplitude of model <code>m</code> at the coordinate <code>p</code>. The coordinate <code>p</code> is expected to have the properties <code>U</code>, <code>V</code>, and sometimes <code>Ti</code> and <code>Fr</code>.</p><p>If you want to compute the amplitudemap at a large number of positions consider using the <code>amplitudemap</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/models/visibilities.jl#L111-L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.amplitudemap"><a class="docstring-binding" href="#ComradeBase.amplitudemap"><code>ComradeBase.amplitudemap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">amplitudemap(m::AbstractModel, p)</code></pre><p>Computes the visibility amplitudemap of the model <code>m</code> at the coordinates <code>p</code>. The coordinates <code>p</code> are expected to have the properties <code>U</code>, <code>V</code>, and sometimes <code>Ti</code> and <code>Fr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/models/visibilities.jl#L173-L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.bispectrum"><a class="docstring-binding" href="#ComradeBase.bispectrum"><code>ComradeBase.bispectrum</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">bispectrum(model, p1, p2, p3)</code></pre><p>Computes the complex bispectrum of model <code>m</code> at the uv-triangle p1 -&gt; p2 -&gt; p3</p><p>If you want to compute the bispectrum over a number of triangles consider using the <code>bispectrummap</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/models/visibilities.jl#L125-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.bispectrummap"><a class="docstring-binding" href="#ComradeBase.bispectrummap"><code>ComradeBase.bispectrummap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">bispectrummap(m, p1, p2, p3)</code></pre><p>Computes the closure phases of the model <code>m</code> at the triangles p1, p2, p3, where <code>pi</code> are coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/models/visibilities.jl#L197-L202">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.closure_phase"><a class="docstring-binding" href="#ComradeBase.closure_phase"><code>ComradeBase.closure_phase</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">closure_phase(model, p1, p2, p3, p4)</code></pre><p>Computes the closure phase of model <code>m</code> at the uv-triangle u1,v1 -&gt; u2,v2 -&gt; u3,v3</p><p>If you want to compute closure phases over a number of triangles consider using the <code>closure_phasemap</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/models/visibilities.jl#L138-L146">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.closure_phasemap"><a class="docstring-binding" href="#ComradeBase.closure_phasemap"><code>ComradeBase.closure_phasemap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">closure_phasemap(m,
               p1::AbstractArray
               p2::AbstractArray
               p3::AbstractArray
               )</code></pre><p>Computes the closure phases of the model <code>m</code> at the triangles p1, p2, p3, where <code>pi</code> are coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/models/visibilities.jl#L246-L255">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.logclosure_amplitude"><a class="docstring-binding" href="#ComradeBase.logclosure_amplitude"><code>ComradeBase.logclosure_amplitude</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logclosure_amplitude(model, p1, p2, p3, p4)</code></pre><p>Computes the log-closure amplitude of model <code>m</code> at the uv-quadrangle u1,v1 -&gt; u2,v2 -&gt; u3,v3 -&gt; u4,v4 using the formula</p><p class="math-container">\[C = \log\left|\frac{V(u1,v1)V(u2,v2)}{V(u3,v3)V(u4,v4)}\right|\]</p><p>If you want to compute log closure amplitudemap over a number of triangles consider using the <code>logclosure_amplitudemap</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/models/visibilities.jl#L151-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.logclosure_amplitudemap"><a class="docstring-binding" href="#ComradeBase.logclosure_amplitudemap"><code>ComradeBase.logclosure_amplitudemap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logclosure_amplitudemap(m::AbstractModel,
                      p1,
                      p2,
                      p3,
                      p4
                     )</code></pre><p>Computes the log closure amplitudemap of the model <code>m</code> at the quadrangles p1, p2, p3, p4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/models/visibilities.jl#L294-L304">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.mpol-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><a class="docstring-binding" href="#PolarizedTypes.mpol-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><code>PolarizedTypes.mpol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mpol(pimg::AbstractPolarizedModel, p)</code></pre><p>Return the fractional linear polarization of the model <code>m</code> at point <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/b008322399efdac0877d97e7e200e8abb94a4384/src/models/polarized.jl#L381-L385">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.polellipse-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><a class="docstring-binding" href="#PolarizedTypes.polellipse-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><code>PolarizedTypes.polellipse</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">polellipse(pimg::AbstractPolarizedModel, p)</code></pre><p>Compute the polarization of the polarized model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/b008322399efdac0877d97e7e200e8abb94a4384/src/models/polarized.jl#L417-L421">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.polarization-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><a class="docstring-binding" href="#PolarizedTypes.polarization-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><code>PolarizedTypes.polarization</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">polarization(pimg::AbstractPolarizedModel, p)</code></pre><p>Return the polarization vector (Q, U, V) of the model <code>m</code> at point <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/b008322399efdac0877d97e7e200e8abb94a4384/src/models/polarized.jl#L390-L394">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.fracpolarization-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><a class="docstring-binding" href="#PolarizedTypes.fracpolarization-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><code>PolarizedTypes.fracpolarization</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fracpolarization(pimg::AbstractPolarizedModel, p)</code></pre><p>Return the fractional polarization vector (Q/I, U/I, V/I) of the model <code>m</code> at point <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/b008322399efdac0877d97e7e200e8abb94a4384/src/models/polarized.jl#L399-L403">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.mbreve-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><a class="docstring-binding" href="#PolarizedTypes.mbreve-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><code>PolarizedTypes.mbreve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mbreve(pimg, p)
</code></pre><p>Explicit m̆ function used for convenience.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/b008322399efdac0877d97e7e200e8abb94a4384/src/models/polarized.jl#L444-L448">source</a></section></details></article><h3 id="Model-Interface"><a class="docs-heading-anchor" href="#Model-Interface">Model Interface</a><a id="Model-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Interface" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="ComradeBase.AbstractModel"><a class="docstring-binding" href="#ComradeBase.AbstractModel"><code>ComradeBase.AbstractModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractModel</code></pre><p>The Comrade abstract model type. To instantiate your own model type you should subtybe from this model. Additionally you need to implement the following methods to satify the interface:</p><p><strong>Mandatory Methods</strong></p><ul><li><a href="#ComradeBase.visanalytic"><code>visanalytic</code></a>: defines whether the model visibilities can be computed analytically. If yes  then this should return <code>IsAnalytic()</code> and the user <em>must</em> to define <code>visibility_point</code>.  If not analytic then <code>visanalytic</code> should return <code>NotAnalytic()</code>.</li><li><a href="#ComradeBase.imanalytic"><code>imanalytic</code></a>: defines whether the model intensities can be computed pointwise. If yes   then this should return <code>IsAnalytic()</code> and the user <em>must</em> to define <code>intensity_point</code>.   If not analytic then <code>imanalytic</code> should return <code>NotAnalytic()</code>.</li><li><a href="#ComradeBase.radialextent"><code>radialextent</code></a>: Provides a estimate of the radial extent of the model in the image domain.  This is used for estimating the size of the image, and for plotting.</li><li><a href="#ComradeBase.flux"><code>flux</code></a>: Returns the total flux of the model.</li><li><a href="#ComradeBase.intensity_point"><code>intensity_point</code></a>: Defines how to compute model intensities pointwise. Note this is must be defined if <code>imanalytic(::Type{YourModel})==IsAnalytic()</code>.</li><li><a href="#ComradeBase.visibility_point"><code>visibility_point</code></a>: Defines how to compute model visibilties pointwise. Note this is   must be defined if <code>visanalytic(::Type{YourModel})==IsAnalytic()</code>.</li></ul><p><strong>Optional Methods:</strong></p><ul><li><a href="#ComradeBase.ispolarized"><code>ispolarized</code></a>: Specified whether a model is intrinsically polarized (returns <code>IsPolarized()</code>) or is not (returns <code>NotPolarized()</code>), by default a model is <code>NotPolarized()</code></li><li><a href="#ComradeBase.visibilitymap_analytic"><code>visibilitymap_analytic</code></a>: Vectorized version of <code>visibility_point</code> for models where <code>visanalytic</code> returns <code>IsAnalytic()</code></li><li><a href="#ComradeBase.visibilitymap_numeric"><code>visibilitymap_numeric</code></a>: Vectorized version of <code>visibility_point</code> for models where <code>visanalytic</code> returns <code>NotAnalytic()</code> typically these are numerical FT&#39;s</li><li><a href="#ComradeBase.intensitymap_analytic"><code>intensitymap_analytic</code></a>: Computes the entire image for models where <code>imanalytic</code> returns <code>IsAnalytic()</code></li><li><a href="#ComradeBase.intensitymap_numeric"><code>intensitymap_numeric</code></a>: Computes the entire image for models where <code>imanalytic</code> returns <code>NotAnalytic()</code></li><li><a href="#ComradeBase.intensitymap_analytic!"><code>intensitymap_analytic!</code></a>: Inplace version of <code>intensitymap</code></li><li><a href="#ComradeBase.intensitymap_numeric!"><code>intensitymap_numeric!</code></a>: Inplace version of <code>intensitymap</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L1-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.visanalytic"><a class="docstring-binding" href="#ComradeBase.visanalytic"><code>ComradeBase.visanalytic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">visanalytic(::Type{&lt;:AbstractModel})</code></pre><p>Determines whether the model is pointwise analytic in Fourier domain, i.e. we can evaluate its fourier transform at an arbritrary point.</p><p>If <code>IsAnalytic()</code> then it will try to call <code>visibility_point</code> to calculate the complex visibilities. Otherwise it fallback to using the FFT that works for all models that can compute an image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L101-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.imanalytic"><a class="docstring-binding" href="#ComradeBase.imanalytic"><code>ComradeBase.imanalytic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">imanalytic(::Type{&lt;:AbstractModel})</code></pre><p>Determines whether the model is pointwise analytic in the image domain, i.e. we can evaluate its intensity at an arbritrary point.</p><p>If <code>IsAnalytic()</code> then it will try to call <code>intensity_point</code> to calculate the intensity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L113-L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.ispolarized"><a class="docstring-binding" href="#ComradeBase.ispolarized"><code>ComradeBase.ispolarized</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ispolarized(::Type)</code></pre><p>Trait function that defines whether a model is polarized or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L46-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.radialextent"><a class="docstring-binding" href="#ComradeBase.radialextent"><code>ComradeBase.radialextent</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">radialextent(model::AbstractModel)</code></pre><p>Provides an estimate of the radial size/extent of the <code>model</code>. This is used internally to estimate image size when plotting and using <code>modelimage</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L203-L208">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.DensityAnalytic"><a class="docstring-binding" href="#ComradeBase.DensityAnalytic"><code>ComradeBase.DensityAnalytic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DensityAnalytic</code></pre><p>Internal type for specifying the nature of the model functions. Whether they can be easily evaluated pointwise analytic. This is an internal type that may change.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L72-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.IsAnalytic"><a class="docstring-binding" href="#ComradeBase.IsAnalytic"><code>ComradeBase.IsAnalytic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct IsAnalytic &lt;: ComradeBase.DensityAnalytic</code></pre><p>Defines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has a analytic fourier transform and/or image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L81-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.NotAnalytic"><a class="docstring-binding" href="#ComradeBase.NotAnalytic"><code>ComradeBase.NotAnalytic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct NotAnalytic &lt;: ComradeBase.DensityAnalytic</code></pre><p>Defines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has does not have a easy analytic fourier transform and/or intensity function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L91-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.visibility_point"><a class="docstring-binding" href="#ComradeBase.visibility_point"><code>ComradeBase.visibility_point</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">visibility_point(model::AbstractModel, p)</code></pre><p>Function that computes the pointwise visibility. This must be implemented in the model interface if <code>visanalytic(::Type{MyModel}) == IsAnalytic()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L138-L144">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.visibilitymap_analytic"><a class="docstring-binding" href="#ComradeBase.visibilitymap_analytic"><code>ComradeBase.visibilitymap_analytic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">visibilties_analytic(model, p)</code></pre><p>Computes the visibilties of a <code>model</code> using using the analytic visibility expression given by <code>visibility_point</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L253-L258">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.visibilitymap_analytic!"><a class="docstring-binding" href="#ComradeBase.visibilitymap_analytic!"><code>ComradeBase.visibilitymap_analytic!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">visibilties_analytic!(vis, model)</code></pre><p>Computes the visibilties of a <code>model</code> in-place, using using the analytic visibility expression given by <code>visibility_point</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L269-L274">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.visibilitymap_numeric"><a class="docstring-binding" href="#ComradeBase.visibilitymap_numeric"><code>ComradeBase.visibilitymap_numeric</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">visibilties_numeric(model, p)</code></pre><p>Computes the visibilties of a <code>model</code> using a numerical fourier transform. Note that none of these are implemented in <code>ComradeBase</code>. For implementations please see <code>Comrade</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L245-L250">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.visibilitymap_numeric!"><a class="docstring-binding" href="#ComradeBase.visibilitymap_numeric!"><code>ComradeBase.visibilitymap_numeric!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">visibilties_numeric!(vis, model)</code></pre><p>Computes the visibilties of a <code>model</code> in-place using a numerical fourier transform. Note that none of these are implemented in <code>ComradeBase</code>. For implementations please see <code>Comrade</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L261-L266">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.intensity_point"><a class="docstring-binding" href="#ComradeBase.intensity_point"><code>ComradeBase.intensity_point</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">intensity_point(model::AbstractModel, p)</code></pre><p>Function that computes the pointwise intensity if the model has the trait in the image domain <code>IsAnalytic()</code>. Otherwise it will use construct the image in visibility space and invert it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L147-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.intensitymap_analytic"><a class="docstring-binding" href="#ComradeBase.intensitymap_analytic"><code>ComradeBase.intensitymap_analytic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">intensitymap_analytic(m::AbstractModel, p::AbstractSingleDomain)</code></pre><p>Computes the <code>IntensityMap</code> of a model <code>m</code> using the image dimensions <code>p</code> by broadcasting over the analytic <a href="#ComradeBase.intensity_point"><code>intensity_point</code></a> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L179-L184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.intensitymap_analytic!"><a class="docstring-binding" href="#ComradeBase.intensitymap_analytic!"><code>ComradeBase.intensitymap_analytic!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">intensitymap_analytic!(img::IntensityMap, m::AbstractModel)</code></pre><p>Updates the <code>img</code> using the model <code>m</code>  by broadcasting over the analytic <a href="#ComradeBase.intensity_point"><code>intensity_point</code></a> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L196-L200">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.intensitymap_numeric"><a class="docstring-binding" href="#ComradeBase.intensitymap_numeric"><code>ComradeBase.intensitymap_numeric</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">intensitymap_numeric(m::AbstractModel, p::AbstractSingleDomain)</code></pre><p>Computes the <code>IntensityMap</code> of a model <code>m</code> at the image positions <code>p</code> using a numerical method. This has to be specified uniquely for every model <code>m</code> if <code>imanalytic(typeof(m)) === NotAnalytic()</code>. See <code>Comrade.jl</code> for example implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L170-L176">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.intensitymap_numeric!"><a class="docstring-binding" href="#ComradeBase.intensitymap_numeric!"><code>ComradeBase.intensitymap_numeric!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">intensitymap_numeric!(img::IntensityMap, m::AbstractModel)</code></pre><p>Updates the <code>img</code> using the model <code>m</code>  using a numerical method. This has to be specified uniquely for every model <code>m</code> if <code>imanalytic(typeof(m)) === NotAnalytic()</code>. See <code>Comrade.jl</code> for example implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L187-L193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.DomainParams"><a class="docstring-binding" href="#ComradeBase.DomainParams"><code>ComradeBase.DomainParams</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type DomainParams</code></pre><p>Abstract type for multidomain i.e. time, frequency domain models.  This is to extend existing models that are just definedin the image and  visibility domain and automatically extend them to time and frequency domain.</p><p>The interface is simple and to extend this with your own time and frequency models, most users will just need to define </p><pre><code class="language-julia hljs">struct MyDomainParam{T} &lt;: DomainParams{T} end
function build_param(param::MyDomainParam{Float64}, p)
    ...
end</code></pre><p>where <code>p</code> is the point where the model will be evaluated at.</p><p>To evaluate the parameter family at a point <code>p</code> in the frequency and time  domain use <code>build_param(param, p)</code> or just <code>param(p)</code>.</p><p>For a model parameterized with a <code>&lt;:DomainParams</code> the a use should access  the parameters with <a href="#ComradeBase.getparam"><code>getparam</code></a> or the <code>@unpack_params</code> macro. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/models/multidomain.jl#L3-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.getparam"><a class="docstring-binding" href="#ComradeBase.getparam"><code>ComradeBase.getparam</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getparam(m, s::Symbol, p)</code></pre><p>Gets the parameter value <code>s</code> from the model <code>m</code> evaluated at the domain <code>p</code>.  This is similar to getproperty, but allows for the parameter to be a function of the  domain. Essentially is <code>m.s &lt;: DomainParams</code> then <code>m.s</code> is evaluated at the parameter <code>p</code>. If <code>m.s</code> is not a subtype of <code>DomainParams</code> then <code>m.s</code> is returned.</p><div class="admonition is-category-warn" id="Warn-b74673998ab0a37d"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-b74673998ab0a37d" title="Permalink"></a></header><div class="admonition-body"><p>Developers should not typically overload this function and instead target <a href="#ComradeBase.build_param"><code>build_param</code></a>.</p></div></div><div class="admonition is-category-warn" id="Warn-feb9aaaaf5cc49b5"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-feb9aaaaf5cc49b5" title="Permalink"></a></header><div class="admonition-body"><p>This feature is experimental and is not considered part of the public stable API.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/models/multidomain.jl#L43-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.@unpack_params"><a class="docstring-binding" href="#ComradeBase.@unpack_params"><code>ComradeBase.@unpack_params</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@unpack_params a,b,c,... = m(p)</code></pre><p>Extracts the parameters <code>a,b,c,...</code> from the model <code>m</code> evaluated at the domain <code>p</code>. This is a macro that essentially lowers to </p><pre><code class="language-julia hljs">a = getparam(m, :a, p)
b = getparam(m, :b, p)
...</code></pre><p>For any model that may depend on a <code>DomainParams</code> type this macro should be used to  extract the parameters. </p><div class="admonition is-category-warn" id="Warn-feb9aaaaf5cc49b5"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-feb9aaaaf5cc49b5" title="Permalink"></a></header><div class="admonition-body"><p>This feature is experimental and is not considered part of the public stable API.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/models/multidomain.jl#L91-L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.build_param"><a class="docstring-binding" href="#ComradeBase.build_param"><code>ComradeBase.build_param</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">build_param(param::DomainParams, p)</code></pre><p>Constucts the parameters for the <code>param</code> model at the point <code>p</code> in the (X/U, Y/V, Ti, Fr) domain. This is a required function for any <code>&lt;: DomainParams</code> and must return a number for the specific parameter at the point <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/models/multidomain.jl#L67-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.paramtype"><a class="docstring-binding" href="#ComradeBase.paramtype"><code>ComradeBase.paramtype</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">paramtype(::Type{&lt;:DomainParams})</code></pre><p>Computes the base parameter type of the DomainParams. If <code>!&lt;:DomainParams</code> then it just returns the type. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/models/multidomain.jl#L34-L39">source</a></section></details></article><h3 id="Image-Domain"><a class="docs-heading-anchor" href="#Image-Domain">Image Domain</a><a id="Image-Domain-1"></a><a class="docs-heading-anchor-permalink" href="#Image-Domain" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="ComradeBase.imagepixels"><a class="docstring-binding" href="#ComradeBase.imagepixels"><code>ComradeBase.imagepixels</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">imagepixels(fovx, fovy, nx, ny, x0=0, y0=0; posang=0.0, executor=Serial(), header=NoHeader())</code></pre><p>Construct a grid of pixels with a field of view <code>fovx</code> and <code>fovy</code> and <code>nx</code> and <code>ny</code> pixels. This points are the pixel centers and the field of view goes from the edge of the first pixel to the edge of the last pixel. The <code>x0</code>, <code>y0</code> offsets shift the image origin over by (<code>x0</code>, <code>y0</code>) in the image plane.</p><p><strong>Arguments:</strong></p><ul><li><code>fovx::Real</code>: The field of view in the x-direction</li><li><code>fovy::Real</code>: The field of view in the y-direction</li><li><code>nx::Integer</code>: The number of pixels in the x-direction</li><li><code>ny::Integer</code>: The number of pixels in the y-direction</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>x0::Real=0</code>: The x-offset of the image</li><li><code>y0::Real=0</code>: The y-offset of the image</li><li><code>posang::Real=0</code>: The position angle of the grid, relative to RA=0 axis.</li><li><code>executor=Serial()</code>: The executor to use for the grid, default is serial execution</li><li><code>header=NoHeader()</code>: The header to use for the grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/images/methods.jl#L66-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.RectiGrid"><a class="docstring-binding" href="#ComradeBase.RectiGrid"><code>ComradeBase.RectiGrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RectiGrid(dims::NamedTuple{Na}; executor=Serial(), header=ComradeBase.NoHeader(), posang=0.0)
RectiGrid(dims::NTuple{N, &lt;:DimensionalData.Dimension}; executor=Serial(), header=ComradeBase.NoHeader(), posang=0.0)</code></pre><p>Creates a rectilinear grid of pixels with the dimensions <code>dims</code>. The convention is that the first two dimension are the spatial dimensions <code>X/U</code> and <code>Y/V</code>. The remaining dimensions can be anything, for example:</p><ul><li>(:X, :Y, :Ti, :Fr)</li><li>(:X, :Y, :Fr, :Ti)</li><li>(:X, :Y) # spatial only</li></ul><p>where <code>X/U,Y/V</code> are the RA and DEC spatial dimensions in image/visibility space respectively,  <code>Ti</code> is the time dimension and <code>Fr</code> is the frequency dimension.</p><p>Note that the majority of the time users should just call <a href="#ComradeBase.imagepixels"><code>imagepixels</code></a> to create a spatial grid.</p><p><strong>Optional Arguments</strong></p><ul><li><code>executor</code>: specifies how different models  are executed. The default is <code>Serial</code> which mean serial CPU computations. For threaded  computations use <a href="#ComradeBase.ThreadsEx"><code>ThreadsEx()</code></a> or load <code>OhMyThreads.jl</code> to uses their schedulers.</li><li><code>header</code>: specified underlying header information for the grid. This is used to store  information about the image such as the source, RA and DEC, MJD.</li><li><code>posang</code>: specifies the position angle of the grid, relative to RA=0 axis. Note that when            <code>posang != 0</code> the X and Y coordinate are relative to the rotated grid and not           the on sky RA and DEC orientation. To see the true on sky points you can access           them by calling <code>domainpoints(grid)</code>.</li></ul><div class="admonition is-category-warn" id="Warn-dd22a767f9101644"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-dd22a767f9101644" title="Permalink"></a></header><div class="admonition-body"><p>The <code>posang</code> argument and the overall rotation of the grid is currently experimental and and may change abruptly in the future even on minor releases.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia hljs">dims = RectiGrid((X(-5.0:0.1:5.0), Y(-4.0:0.1:4.0), Ti([1.0, 1.5, 1.75]), Fr([230, 345])); executor=ThreadsEx())
dims = RectiGrid((X = -5.0:0.1:5.0, Y = -4.0:0.1:4.0, Ti = [1.0, 1.5, 1.75], Fr = [230, 345]); executor=ThreadsEx()))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/rectigrid.jl#L103-L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.UnstructuredDomain"><a class="docstring-binding" href="#ComradeBase.UnstructuredDomain"><code>ComradeBase.UnstructuredDomain</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnstructuredDomain(dims::NamedTuple; executor=Serial(), header=ComradeBase.NoHeader)</code></pre><p>Builds an unstructured grid (really a vector of points) from the dimensions <code>dims</code>. The <code>executor</code> is used controls how the grid is computed when calling <code>visibilitymap</code> or <code>intensitymap</code>. The default is <code>Serial</code> which mean regular CPU computations. For threaded execution use <a href="#ComradeBase.ThreadsEx"><code>ThreadsEx()</code></a> or load <code>OhMyThreads.jl</code> to uses their schedulers.</p><p>Note that unlike <code>RectiGrid</code> which assigns dimensions to the grid points, <code>UnstructuredDomain</code> does not. This is becuase the grid is unstructured the points are a cloud in a space</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/unstructured/domain.jl#L18-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DimensionalData.Dimensions.dims"><a class="docstring-binding" href="#DimensionalData.Dimensions.dims"><code>DimensionalData.Dimensions.dims</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dims(g::AbstractSingleDomain)</code></pre><p>Returns a tuple containing the dimensions of <code>g</code>. For a named version see <a href="#ComradeBase.named_dims"><code>ComradeBase.named_dims</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/domain.jl#L109-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.named_dims"><a class="docstring-binding" href="#ComradeBase.named_dims"><code>ComradeBase.named_dims</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">named_dims(g::AbstractSingleDomain)</code></pre><p>Returns a named tuple containing the dimensions of <code>g</code>. For a unnamed version see <a href="#DimensionalData.Dimensions.dims"><code>dims</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/domain.jl#L118-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.axisdims"><a class="docstring-binding" href="#ComradeBase.axisdims"><code>ComradeBase.axisdims</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">axisdims(img::IntensityMap)
axisdims(img::IntensityMap, p::Symbol)</code></pre><p>Returns the keys of the <code>IntensityMap</code> as the actual internal <code>AbstractRectiGrid</code> object. Optionall the user can ask for a specific dimension with <code>p</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/images/intensitymap.jl#L137-L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.domainpoints"><a class="docstring-binding" href="#ComradeBase.domainpoints"><code>ComradeBase.domainpoints</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">domainpoints(g::AbstractSingleDomain)</code></pre><p>Create a grid iterator that can be used to iterate through different points. All grid methods must implement this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/domain.jl#L87-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.fieldofview"><a class="docstring-binding" href="#ComradeBase.fieldofview"><code>ComradeBase.fieldofview</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fieldofview(img::IntensityMap)
fieldofview(img::IntensityMap)</code></pre><p>Returns a named tuple with the field of view of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/images/methods.jl#L104-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.pixelsizes"><a class="docstring-binding" href="#ComradeBase.pixelsizes"><code>ComradeBase.pixelsizes</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pixelsizes(img::IntensityMap)
pixelsizes(img::AbstractRectiGrid)</code></pre><p>Returns a named tuple with the spatial pixel sizes of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/rectigrid.jl#L18-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.phasecenter"><a class="docstring-binding" href="#ComradeBase.phasecenter"><code>ComradeBase.phasecenter</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">phasecenter(img::IntensityMap)</code></pre><p>Computes the phase center of an intensity map. Note this is the pixels that is in the middle of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/images/methods.jl#L50-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.executor"><a class="docstring-binding" href="#ComradeBase.executor"><code>ComradeBase.executor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">executor(g::AbstractSingleDomain)</code></pre><p>Returns the executor used to compute the intensitymap or visibilitymap</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/domain.jl#L100-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.Serial"><a class="docstring-binding" href="#ComradeBase.Serial"><code>ComradeBase.Serial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Serial()</code></pre><p>Uses serial execution when computing the intensitymap or visibilitymap</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/executors.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.ThreadsEx"><a class="docstring-binding" href="#ComradeBase.ThreadsEx"><code>ComradeBase.ThreadsEx</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ThreadsEx(;scheduler::Symbol = :dynamic)</code></pre><p>Uses Julia&#39;s Threads @threads macro when computing the intensitymap or visibilitymap. You can choose from Julia&#39;s various schedulers by passing the scheduler as a parameter. The default is :dynamic, but it isn&#39;t considered part of the stable API and may change at any moment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/executors.jl#L10-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.ReactantEx"><a class="docstring-binding" href="#ComradeBase.ReactantEx"><code>ComradeBase.ReactantEx</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ReactantEx</code></pre><p>Uses Reactant.jl for execution when computing the intensitymap or visibilitymap. Note that specifying this should be unnecessary as ComradeBase will automatically switch to this backend when it detects that it is inside a Reactant tracing context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/executors.jl#L22-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.header"><a class="docstring-binding" href="#ComradeBase.header"><code>ComradeBase.header</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">header(g::AbstractSingleDomain)</code></pre><p>Returns the headerinformation of the dimensions <code>g</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/domain.jl#L127-L131">source</a></section><section><div><pre><code class="language-julia hljs">header(img::IntensityMap)</code></pre><p>Retrieves the header of an IntensityMap</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/images/intensitymap.jl#L149-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.NoHeader"><a class="docstring-binding" href="#ComradeBase.NoHeader"><code>ComradeBase.NoHeader</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NoHeader</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/headers.jl#L47-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.MinimalHeader"><a class="docstring-binding" href="#ComradeBase.MinimalHeader"><code>ComradeBase.MinimalHeader</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MinimalHeader{T}</code></pre><p>A minimal header type for ancillary image information.</p><p><strong>Fields</strong></p><ul><li><code>source</code>: Common source name</li></ul><ul><li><code>ra</code>: Right ascension of the image in degrees (J2000)</li></ul><ul><li><code>dec</code>: Declination of the image in degrees (J2000)</li></ul><ul><li><code>mjd</code>: Modified Julian Date in days</li></ul><ul><li><code>frequency</code>: Frequency of the image in Hz</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/headers.jl#L5-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.DualMap"><a class="docstring-binding" href="#ComradeBase.DualMap"><code>ComradeBase.DualMap</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DualMap(img, vis, dims)</code></pre><p>A structure that holds both an image map and a visibility map along with their dual domain.</p><p>To access the image map use <code>imgmap(dm)</code>. To access the visibility map use <code>vismap(dm)</code>. To access the dual domain use <code>domain(dm)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/domain.jl#L168-L176">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.AbstractDualDomain"><a class="docstring-binding" href="#ComradeBase.AbstractDualDomain"><code>ComradeBase.AbstractDualDomain</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractDualDomain</code></pre><p>Defines a domain that is a combination of a image and visibility domain. There are two methods that must be implemented for this domain:     - <code>imgdomain(d::AbstractDualDomain)</code> which returns the image domain     - <code>visdomain(d::AbstractDualDomain)</code> which returns the visibility domain</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/domain.jl#L9-L16">source</a></section></details></article><h3 id="Image-Types"><a class="docs-heading-anchor" href="#Image-Types">Image Types</a><a id="Image-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Image-Types" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="ComradeBase.IntensityMap"><a class="docstring-binding" href="#ComradeBase.IntensityMap"><code>ComradeBase.IntensityMap</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct IntensityMap{T, N, D, G&lt;:(ComradeBase.AbstractRectiGrid{D}), A&lt;:AbstractArray{T, N}, R&lt;:Tuple, Na} &lt;: AbstractDimArray{T, N, D, A&lt;:AbstractArray{T, N}}</code></pre><p>This type is the basic array type for all images and models that obey the <code>ComradeBase</code> interface. The type is a subtype of <code>DimensionalData.AbstractDimArray</code> however, we make a few changes to support the Comrade API.</p><ol><li>The dimensions should be specified by an <code>AbstractRectiGrid</code> interface. Usually users just need the <a href="#ComradeBase.RectiGrid"><code>RectiGrid</code></a> grid, for rectilinear grids.</li><li>There are two ways to access the dimensions of the array. <code>dims(img)</code> will return the usual <code>DimArray</code> dimensions, i.e. a <code>Tuple{DimensionalData.Dim, ...}</code>. The other way to access the array dimensions is using the <code>getproperty</code>, e.g., <code>img.X</code> will return the RA/X grid locations but stripped of the usual <code>DimensionalData.Dimension</code> material. This <code>getproperty</code> behavior is *NOT CONSIDERED** part of the stable API and may be changed in the future.</li><li>Metadata is stored in the <code>AbstractRectiGrid</code> type through the <code>header</code> property and can be accessed through <code>metadata</code> or <code>header</code></li></ol><p>The most common way to create a <code>IntensityMap</code> is to use the function definitions</p><pre><code class="language-julia-repl hljs">julia&gt; g = imagepixels(10.0, 10.0, 128, 128; header=NoHeader())
julia&gt; X = g.X; Y = g.Y
julia&gt; data = rand(128, 128)
julia&gt; img1 = IntensityMap(data, g)
julia&gt; img2 = IntensityMap(data, (;X, Y); header=header(g))
julia&gt; img1 == img2
true
julia&gt; img3 = IntensityMap(data, 10.0, 10.0; header=NoHeader())</code></pre><p>Broadcasting, map, and reductions should all just obey the <code>DimensionalData</code> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/images/intensitymap.jl#L12-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.IntensityMap-Tuple{AbstractArray, ComradeBase.AbstractRectiGrid}"><a class="docstring-binding" href="#ComradeBase.IntensityMap-Tuple{AbstractArray, ComradeBase.AbstractRectiGrid}"><code>ComradeBase.IntensityMap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">IntensityMap(data::AbstractArray, g::AbstractRectiGrid; refdims=(), name=Symbol(&quot;&quot;))</code></pre><p>Creates a IntensityMap with the pixel fluxes <code>data</code> on the grid <code>g</code>. Optionally, you can specify a set of reference dimensions <code>refdims</code> as a tuple and a name for array <code>name</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/images/intensitymap.jl#L105-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.UnstructuredMap"><a class="docstring-binding" href="#ComradeBase.UnstructuredMap"><code>ComradeBase.UnstructuredMap</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnstructuredMap(data::AbstractVector, dims::UnstructuredDomain)</code></pre><p>A map that is defined on an unstructured domain. This is typically just a vector of values. The vector of locations of the visibilities are stored in <code>dims</code>. Otherwise this behaves very similarly to <code>IntensityMap</code>, except that is isn&#39;t a grid.</p><p>For instance the locations of the visibilities can be accessed with <code>axisdims</code>, as well as the usual <code>getproperty</code> and <code>propertynames</code> functions. Like with <code>IntensityMap</code> during execution the <code>executor</code> is used to determine the execution context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/images/map.jl#L3-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.baseimage"><a class="docstring-binding" href="#ComradeBase.baseimage"><code>ComradeBase.baseimage</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Returns the base image of a intensity map type object</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/images/images.jl#L77-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.centroid"><a class="docstring-binding" href="#ComradeBase.centroid"><code>ComradeBase.centroid</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">centroid(im::AbstractIntensityMap)</code></pre><p>Computes the image centroid aka the center of light of the image.</p><p>For polarized maps we return the centroid for Stokes I only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/images/methods.jl#L127-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.second_moment"><a class="docstring-binding" href="#ComradeBase.second_moment"><code>ComradeBase.second_moment</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">second_moment(im::AbstractIntensityMap; center=true)</code></pre><p>Computes the image second moment tensor of the image. By default we really return the second <strong>cumulant</strong> or centered second moment, which is specified by the <code>center</code> argument.</p><p>For polarized maps we return the second moment for Stokes I only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/images/methods.jl#L152-L160">source</a></section><section><div><pre><code class="language-julia hljs">second_moment(im::IntensityMap; center=true)</code></pre><p>Computes the image second moment tensor of the image. By default we really return the second <strong>cumulant</strong> or centered second moment, which is specified by the <code>center</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/images/methods.jl#L174-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.stokes"><a class="docstring-binding" href="#ComradeBase.stokes"><code>ComradeBase.stokes</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">stokes(m::AbstractPolarizedModel, p::Symbol)</code></pre><p>Extract the specific stokes component <code>p</code> from the polarized model <code>m</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L65-L69">source</a></section><section><div><pre><code class="language-julia hljs">stokes(m::AbstractArray{&lt;:StokesParams}, p::Symbol)</code></pre><p>Extract the specific stokes component <code>p</code> from the polarized image <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/images/images.jl#L59-L63">source</a></section></details></article><h2 id="Polarization"><a class="docs-heading-anchor" href="#Polarization">Polarization</a><a id="Polarization-1"></a><a class="docs-heading-anchor-permalink" href="#Polarization" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ComradeBase.AbstractPolarizedModel"><a class="docstring-binding" href="#ComradeBase.AbstractPolarizedModel"><code>ComradeBase.AbstractPolarizedModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractPolarizedModel &lt;: ComradeBase.AbstractModel</code></pre><p>A generic polarized model. To implement the use needs to follow the <a href="#ComradeBase.AbstractModel"><code>AbstractModel</code></a> implementation instructions. In addtion there is an optional method <code>stokes(model, p::Symbol)</code> which extracts the specific stokes parameter of the model. The default that the different stokes parameters are stored as fields of the model. To overwrite this behavior overload the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L53-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.StokesParams"><a class="docstring-binding" href="#PolarizedTypes.StokesParams"><code>PolarizedTypes.StokesParams</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct StokesParams{T} &lt;: StaticArraysCore.FieldVector{4, T}</code></pre><p>Static vector that holds the stokes parameters of a polarized complex visibility</p><p>To convert between a <code>StokesParams</code> and <code>CoherencyMatrix</code> use the <code>convert</code> function</p><pre><code class="language-julia hljs">convert(::CoherencyMatrix, StokesVector(1.0, 0.1, 0.1, 0.4))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/types.jl#L70-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.ElectricFieldBasis"><a class="docstring-binding" href="#PolarizedTypes.ElectricFieldBasis"><code>PolarizedTypes.ElectricFieldBasis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type ElectricFieldBasis</code></pre><p>An abstract type whose subtypes denote a specific electric field basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/types.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.RPol"><a class="docstring-binding" href="#PolarizedTypes.RPol"><code>PolarizedTypes.RPol</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct RPol &lt;: PolarizedTypes.ElectricFieldBasis</code></pre><p>The right circular electric field basis, i.e. a right-handed circular feed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/types.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.LPol"><a class="docstring-binding" href="#PolarizedTypes.LPol"><code>PolarizedTypes.LPol</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct LPol &lt;: PolarizedTypes.ElectricFieldBasis</code></pre><p>The left circular electric field basis, i.e. a left-handed circular feed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/types.jl#L15-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.XPol"><a class="docstring-binding" href="#PolarizedTypes.XPol"><code>PolarizedTypes.XPol</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct XPol &lt;: PolarizedTypes.ElectricFieldBasis</code></pre><p>The horizontal or X electric feed basis, i.e. the horizontal linear feed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/types.jl#L22-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.YPol"><a class="docstring-binding" href="#PolarizedTypes.YPol"><code>PolarizedTypes.YPol</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct YPol &lt;: PolarizedTypes.ElectricFieldBasis</code></pre><p>The vertical or Y electric feed basis, i.e. the vertical linear feed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/types.jl#L29-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.PolBasis"><a class="docstring-binding" href="#PolarizedTypes.PolBasis"><code>PolarizedTypes.PolBasis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct PolBasis{B1&lt;:Union{Missing, PolarizedTypes.ElectricFieldBasis}, B2&lt;:Union{Missing, PolarizedTypes.ElectricFieldBasis}}</code></pre><p>Denotes a general polarization basis, with basis vectors (B1,B2) which are typically <code>&lt;: Union{ElectricFieldBasis, Missing}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/types.jl#L44-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.CirBasis"><a class="docstring-binding" href="#PolarizedTypes.CirBasis"><code>PolarizedTypes.CirBasis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CirBasis &lt;: PolBasis</code></pre><p>Measurement uses the circular polarization basis, which is typically used for circular feed interferometers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/types.jl#L53-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.LinBasis"><a class="docstring-binding" href="#PolarizedTypes.LinBasis"><code>PolarizedTypes.LinBasis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinBasis &lt;: PolBasis</code></pre><p>Measurement uses the linear polarization basis, which is typically used for linear feed interferometers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/types.jl#L61-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.CoherencyMatrix"><a class="docstring-binding" href="#PolarizedTypes.CoherencyMatrix"><code>PolarizedTypes.CoherencyMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct CoherencyMatrix{B1, B2, T} &lt;: StaticArraysCore.FieldMatrix{2, 2, T}</code></pre><p>Coherency matrix for a single baseline with bases <code>B1</code> and <code>B2</code>. The two bases correspond to the type of feeds used for each telescope and should be subtypes of <code>PolBasis</code>. To see which bases are implemented type <code>subtypes(Rimes.PolBasis)</code> in the REPL.</p><p>For a circular basis the layout of the coherency matrix is</p><pre><code class="nohighlight hljs">RR* RL*
LR* RR*</code></pre><p>which can be constructed using</p><pre><code class="language-julia-repl hljs">c = CoherencyMatrix(RR, LR, RL, LL, CirBasis())</code></pre><p>For a linear basis the layout of the coherency matrix is</p><pre><code class="nohighlight hljs">XX* XY*
YX* YY*</code></pre><p>which can be constructed using</p><pre><code class="language-julia-repl hljs">c = CoherencyMatrix(XX, YX, XY, YY, CirBasis())</code></pre><p>For a mixed (e.g., circular and linear basis) the layout of the coherency matrix is</p><pre><code class="nohighlight hljs">RX* RY*
LX* LY*</code></pre><p>or e.g., linear and circular the layout of the coherency matrix is</p><pre><code class="nohighlight hljs">XR* XL*
YR* YL*</code></pre><p>These coherency matrices can be constructed using:</p><pre><code class="language-julia-repl hljs"># Circular and linear feeds i.e., |R&gt;&lt;X|
c = CoherencyMatrix(RX, LX, RY, LY, LinBasis(), CirBasis())
# Linear and circular feeds i.e., |X&gt;&lt;R|
c = CoherencyMatrix(XR, YR, XL, YL, LinBasis(), CirBasis())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/types.jl#L96-L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.evpa"><a class="docstring-binding" href="#PolarizedTypes.evpa"><code>PolarizedTypes.evpa</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">evpa(m::Union{StokesParams, CoherencyMatrix})</code></pre><p>Compute the evpa of a stokes vect or cohereny matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/functions.jl#L94-L97">source</a></section><section><div><pre><code class="language-julia hljs">evpa(pimg::AbstractPolarizedModel, p)</code></pre><p>electric vector position angle or EVPA of the polarized model <code>pimg</code> at <code>p</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/b008322399efdac0877d97e7e200e8abb94a4384/src/models/polarized.jl#L408-L412">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.m̆"><a class="docstring-binding" href="#PolarizedTypes.m̆"><code>PolarizedTypes.m̆</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">m̆(m::Union{StokesParameters{&lt;:Complex}, CoherencyMatrix)</code></pre><p>Computes the complex fractional linear polarization of the complex or visibility quantities. Note that this function can also be called used <a href="#PolarizedTypes.mbreve-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><code>mbreve</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/functions.jl#L77-L82">source</a></section><section><div><pre><code class="language-julia hljs">m̆(pimg::AbstractPolarizedModel, p)
mbreve(pimg::AbstractPolarizedModel, p)</code></pre><p>Computes the fractional linear polarization in the visibility domain</p><pre><code class="nohighlight hljs">m̆ = (Q̃ + iŨ)/Ĩ</code></pre><p>To create the symbol type <code>m\breve</code> in the REPL or use the <a href="#PolarizedTypes.mbreve-Tuple{ComradeBase.AbstractPolarizedModel, Any}"><code>mbreve</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/b008322399efdac0877d97e7e200e8abb94a4384/src/models/polarized.jl#L426-L436">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.linearpol"><a class="docstring-binding" href="#PolarizedTypes.linearpol"><code>PolarizedTypes.linearpol</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linearpol(s)
</code></pre><p>Computes <code>linearpol</code> from a set of stokes parameters <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/functions.jl#L1-L5">source</a></section><section><div><pre><code class="language-julia hljs">linearpol(pimg::AbstractPolarizedModel, p)</code></pre><p>Return the complex linear polarization of the model <code>m</code> at point <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/b008322399efdac0877d97e7e200e8abb94a4384/src/models/polarized.jl#L372-L376">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.innerprod"><a class="docstring-binding" href="#PolarizedTypes.innerprod"><code>PolarizedTypes.innerprod</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">innerprod(::Type{T}, XPol(), YPol())</code></pre><p>Computes the complex inner product of two elements of a complex Hilbert space <code>X</code> and <code>Y</code> where base element of the output is T.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/basis_transforms.jl#L30-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.basis_components"><a class="docstring-binding" href="#PolarizedTypes.basis_components"><code>PolarizedTypes.basis_components</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">basis_components([T=Float64,], e::ElectricFieldBasis, b::PolBasis)</code></pre><p>Returns a static vector that contains the components of the electric field basis vector <code>e</code> in terms of the polarization basis <code>b</code>. The first argument is optionally the eltype of the static vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; basis_components(Float64, R(), PolBasis{XPol,Y}())
2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):
 0.7071067811865475 + 0.0im
                0.0 - 0.7071067811865475im

julia&gt; basis_components(R(), PolBasis{XPol,Y}())
2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):
 0.7071067811865475 + 0.0im
                0.0 - 0.7071067811865475im


julia&gt; basis_components(Float64, X(), PolBasis{XPol,Y}())
2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):
 1.0 + 0.0im
 0.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/basis_transforms.jl#L1-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.basis_transform"><a class="docstring-binding" href="#PolarizedTypes.basis_transform"><code>PolarizedTypes.basis_transform</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">basis_transform([T=Float64,], b1::PolBasis, b2::PolBasis)
basis_transform([T=Float64,], b1::PolBasis=&gt;b2::PolBasis)</code></pre><p>Produces the transformation matrix that transforms the vector components from basis <code>b1</code> to basis <code>b2</code>. This means that if for example <code>E</code> is the circular basis then <code>basis_transform(CirBasis=&gt;LinBasis)E</code> is in the linear basis. In other words the <strong>columns</strong> of the transformation matrix are the coordinate vectors of the new basis vectors in the old basis.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; basis_transform(CirBasis()=&gt;LinBasis())
2×2 StaticArraysCore.SMatrix{2, 2, ComplexF64, 4} with indices SOneTo(2)×SOneTo(2):
 0.707107-0.0im       0.707107-0.0im
      0.0-0.707107im       0.0+0.707107im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/basis_transforms.jl#L75-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.polarization"><a class="docstring-binding" href="#PolarizedTypes.polarization"><code>PolarizedTypes.polarization</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">polarization(s)
</code></pre><p>Returns the (Q, U, V) polarization vector as a 3-element static vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/functions.jl#L10-L14">source</a></section><section><div><pre><code class="language-julia hljs">polarization(pimg::AbstractPolarizedModel, p)</code></pre><p>Return the polarization vector (Q, U, V) of the model <code>m</code> at point <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/b008322399efdac0877d97e7e200e8abb94a4384/src/models/polarized.jl#L390-L394">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolarizedTypes.fracpolarization"><a class="docstring-binding" href="#PolarizedTypes.fracpolarization"><code>PolarizedTypes.fracpolarization</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fracpolarization(s)
</code></pre><p>Returns the (Q/I, U/I, V/I) fractional polarization vector as a 3-element static vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/PolarizedTypes.jl/blob/v0.1.2/src/functions.jl#L61-L65">source</a></section><section><div><pre><code class="language-julia hljs">fracpolarization(pimg::AbstractPolarizedModel, p)</code></pre><p>Return the fractional polarization vector (Q/I, U/I, V/I) of the model <code>m</code> at point <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/b008322399efdac0877d97e7e200e8abb94a4384/src/models/polarized.jl#L399-L403">source</a></section></details></article><h2 id="Internal-Methods-not-part-of-public-API"><a class="docs-heading-anchor" href="#Internal-Methods-not-part-of-public-API">Internal Methods not part of public API</a><a id="Internal-Methods-not-part-of-public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Methods-not-part-of-public-API" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ComradeBase._visibilitymap"><a class="docstring-binding" href="#ComradeBase._visibilitymap"><code>ComradeBase._visibilitymap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_visibilitymap(model::AbstractModel, p)</code></pre><p>Internal method used for trait dispatch and unpacking of args arguments in <code>visibilities</code></p><div class="admonition is-category-warn" id="Warn-ff37ca6678c51554"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-ff37ca6678c51554" title="Permalink"></a></header><div class="admonition-body"><p>Not part of the public API so it may change at any moment.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L225-L232">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase._visibilitymap!"><a class="docstring-binding" href="#ComradeBase._visibilitymap!"><code>ComradeBase._visibilitymap!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_visibilitymap!(model::AbstractModel, p)</code></pre><p>Internal method used for trait dispatch and unpacking of args arguments in <code>visibilities!</code></p><div class="admonition is-category-warn" id="Warn-ff37ca6678c51554"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-ff37ca6678c51554" title="Permalink"></a></header><div class="admonition-body"><p>Not part of the public API so it may change at any moment.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/interface.jl#L235-L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.create_map"><a class="docstring-binding" href="#ComradeBase.create_map"><code>ComradeBase.create_map</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_map(array, g::AbstractSingleDomain)</code></pre><p>Create a map of values specialized by the grid <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/domain.jl#L22-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComradeBase.@threaded"><a class="docstring-binding" href="#ComradeBase.@threaded"><code>ComradeBase.@threaded</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@threaded executor expr</code></pre><p>Threads the for-loop expression <code>expr</code> using the specified <code>executor</code>. The executor must be one of <code>ThreadsEx</code> or <code>Serial</code>. Note that if the <code>Threads.nthreads() == 1</code> we automatically default to  a regular for-loop to prevent overhead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/ComradeBase.jl/blob/v0.9.10/src/domains/executors.jl#L38-L44">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« API</a><a class="docs-footer-nextpage" href="../examples/nonanalytic/">Non-Analytic Modeling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 8 February 2026 05:09">Sunday 8 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
