var documenterSearchIndex = {"docs":
[{"location":"base_api/#Base-API","page":"Base API","title":"Base API","text":"","category":"section"},{"location":"base_api/#Contents","page":"Base API","title":"Contents","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"Pages = [\"base_api.md\"]","category":"page"},{"location":"base_api/#Index","page":"Base API","title":"Index","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"Pages = [\"base_api.md\"]","category":"page"},{"location":"base_api/","page":"Base API","title":"Base API","text":"CurrentModule = ComradeBase","category":"page"},{"location":"base_api/#Model-API","page":"Base API","title":"Model API","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"ComradeBase.flux\nComradeBase.visibility\nComradeBase.visibilitymap\nComradeBase.visibilitymap!\nComradeBase.intensitymap\nComradeBase.intensitymap!\nComradeBase.allocate_vismap\nComradeBase.allocate_imgmap\nComradeBase.create_imgmap\nComradeBase.create_vismap\nComradeBase.amplitude(::Any, ::Any)\nComradeBase.amplitudemap\nComradeBase.bispectrum\nComradeBase.bispectrummap\nComradeBase.closure_phase\nComradeBase.closure_phasemap\nComradeBase.logclosure_amplitude\nComradeBase.logclosure_amplitudemap\nPolarizedTypes.mpol(::ComradeBase.AbstractPolarizedModel, ::Any)\nPolarizedTypes.polellipse(::ComradeBase.AbstractPolarizedModel, ::Any)\nPolarizedTypes.polarization(::ComradeBase.AbstractPolarizedModel, ::Any)\nPolarizedTypes.fracpolarization(::ComradeBase.AbstractPolarizedModel, ::Any)\nPolarizedTypes.mbreve(::ComradeBase.AbstractPolarizedModel, ::Any)","category":"page"},{"location":"base_api/#ComradeBase.flux","page":"Base API","title":"ComradeBase.flux","text":"flux(im::IntensityMap)\n\nComputes the flux of a intensity map\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibility","page":"Base API","title":"ComradeBase.visibility","text":"visibility(mimg, p)\n\nComputes the complex visibility of model m at coordinates p. p corresponds to the coordinates of the model. These need to have the properties U, V and sometimes Ti for time and Fr for frequency.\n\nNotes\n\nIf you want to compute the visibilities at a large number of positions consider using the visibilitymap.\n\nWarn\n\nThis is only defined for analytic models. If you want to compute the visibility for a single point for a non-analytic model, please use the visibilitymap function and create an UnstructuredDomain with a single point.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilitymap","page":"Base API","title":"ComradeBase.visibilitymap","text":"visibilitymap(model::AbstractModel, p)\n\nComputes the complex visibilities at the locations p.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilitymap!","page":"Base API","title":"ComradeBase.visibilitymap!","text":"visibilitymap!(vis::AbstractArray, model::AbstractModel, p)\n\nComputes the complex visibilities vis in place at the locations p\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap","page":"Base API","title":"ComradeBase.intensitymap","text":"intensitymap(model::AbstractModel, p::AbstractSingleDomain)\n\nComputes the intensity map of model. For the inplace version see intensitymap!\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap!","page":"Base API","title":"ComradeBase.intensitymap!","text":"intensitymap!(buffer::AbstractDimArray, model::AbstractModel)\n\nComputes the intensity map of model by modifying the buffer\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.allocate_vismap","page":"Base API","title":"ComradeBase.allocate_vismap","text":"allocate_vismap(m::AbstractModel, g::AbstractSingleDomain)\n\nAllocate the default map specialized by the grid g\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.allocate_imgmap","page":"Base API","title":"ComradeBase.allocate_imgmap","text":"allocate_imgmap(m::AbstractModel, g::AbstractSingleDomain)\n\nAllocate the default map specialized by the grid g\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.create_imgmap","page":"Base API","title":"ComradeBase.create_imgmap","text":"create_imgmap(array, g::AbstractSingleDomain)\n\nCreate a map of values specialized by the grid g in the image domain. The default is to call create_map with the same arguments.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.create_vismap","page":"Base API","title":"ComradeBase.create_vismap","text":"create_vismap(array, g::AbstractSingleDomain)\n\nCreate a map of values specialized by the grid g in the visibility domain. The default is to call create_map with the same arguments.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.amplitude-Tuple{Any, Any}","page":"Base API","title":"ComradeBase.amplitude","text":"amplitude(model, p)\n\nComputes the visibility amplitude of model m at the coordinate p. The coordinate p is expected to have the properties U, V, and sometimes Ti and Fr.\n\nIf you want to compute the amplitudemap at a large number of positions consider using the amplitudemap function.\n\n\n\n\n\n","category":"method"},{"location":"base_api/#ComradeBase.amplitudemap","page":"Base API","title":"ComradeBase.amplitudemap","text":"amplitudemap(m::AbstractModel, p)\n\nComputes the visibility amplitudemap of the model m at the coordinates p. The coordinates p are expected to have the properties U, V, and sometimes Ti and Fr.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.bispectrum","page":"Base API","title":"ComradeBase.bispectrum","text":"bispectrum(model, p1, p2, p3)\n\nComputes the complex bispectrum of model m at the uv-triangle p1 -> p2 -> p3\n\nIf you want to compute the bispectrum over a number of triangles consider using the bispectrummap function.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.bispectrummap","page":"Base API","title":"ComradeBase.bispectrummap","text":"bispectrummap(m, p1, p2, p3)\n\nComputes the closure phases of the model m at the triangles p1, p2, p3, where pi are coordinates.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.closure_phase","page":"Base API","title":"ComradeBase.closure_phase","text":"closure_phase(model, p1, p2, p3, p4)\n\nComputes the closure phase of model m at the uv-triangle u1,v1 -> u2,v2 -> u3,v3\n\nIf you want to compute closure phases over a number of triangles consider using the closure_phasemap function.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.closure_phasemap","page":"Base API","title":"ComradeBase.closure_phasemap","text":"closure_phasemap(m,\n               p1::AbstractArray\n               p2::AbstractArray\n               p3::AbstractArray\n               )\n\nComputes the closure phases of the model m at the triangles p1, p2, p3, where pi are coordinates.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.logclosure_amplitude","page":"Base API","title":"ComradeBase.logclosure_amplitude","text":"logclosure_amplitude(model, p1, p2, p3, p4)\n\nComputes the log-closure amplitude of model m at the uv-quadrangle u1,v1 -> u2,v2 -> u3,v3 -> u4,v4 using the formula\n\nC = logleftfracV(u1v1)V(u2v2)V(u3v3)V(u4v4)right\n\nIf you want to compute log closure amplitudemap over a number of triangles consider using the logclosure_amplitudemap function.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.logclosure_amplitudemap","page":"Base API","title":"ComradeBase.logclosure_amplitudemap","text":"logclosure_amplitudemap(m::AbstractModel,\n                      p1,\n                      p2,\n                      p3,\n                      p4\n                     )\n\nComputes the log closure amplitudemap of the model m at the quadrangles p1, p2, p3, p4.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#PolarizedTypes.mpol-Tuple{ComradeBase.AbstractPolarizedModel, Any}","page":"Base API","title":"PolarizedTypes.mpol","text":"mpol(pimg::AbstractPolarizedModel, p)\n\nReturn the fractional linear polarization of the model m at point p.\n\n\n\n\n\n","category":"method"},{"location":"base_api/#PolarizedTypes.polellipse-Tuple{ComradeBase.AbstractPolarizedModel, Any}","page":"Base API","title":"PolarizedTypes.polellipse","text":"polellipse(pimg::AbstractPolarizedModel, p)\n\nCompute the polarization of the polarized model.\n\n\n\n\n\n","category":"method"},{"location":"base_api/#PolarizedTypes.polarization-Tuple{ComradeBase.AbstractPolarizedModel, Any}","page":"Base API","title":"PolarizedTypes.polarization","text":"polarization(pimg::AbstractPolarizedModel, p)\n\nReturn the polarization vector (Q, U, V) of the model m at point p.\n\n\n\n\n\n","category":"method"},{"location":"base_api/#PolarizedTypes.fracpolarization-Tuple{ComradeBase.AbstractPolarizedModel, Any}","page":"Base API","title":"PolarizedTypes.fracpolarization","text":"fracpolarization(pimg::AbstractPolarizedModel, p)\n\nReturn the fractional polarization vector (Q/I, U/I, V/I) of the model m at point p.\n\n\n\n\n\n","category":"method"},{"location":"base_api/#PolarizedTypes.mbreve-Tuple{ComradeBase.AbstractPolarizedModel, Any}","page":"Base API","title":"PolarizedTypes.mbreve","text":"mbreve(pimg, p)\n\n\nExplicit m̆ function used for convenience.\n\n\n\n\n\n","category":"method"},{"location":"base_api/#Model-Interface","page":"Base API","title":"Model Interface","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"ComradeBase.AbstractModel\nComradeBase.visanalytic\nComradeBase.imanalytic\nComradeBase.ispolarized\nComradeBase.radialextent\nComradeBase.DensityAnalytic\nComradeBase.IsAnalytic\nComradeBase.NotAnalytic\nComradeBase.visibility_point\nComradeBase.visibilitymap_analytic\nComradeBase.visibilitymap_analytic!\nComradeBase.visibilitymap_numeric\nComradeBase.visibilitymap_numeric!\nComradeBase.intensity_point\nComradeBase.intensitymap_analytic\nComradeBase.intensitymap_analytic!\nComradeBase.intensitymap_numeric\nComradeBase.intensitymap_numeric!","category":"page"},{"location":"base_api/#ComradeBase.AbstractModel","page":"Base API","title":"ComradeBase.AbstractModel","text":"AbstractModel\n\nThe Comrade abstract model type. To instantiate your own model type you should subtybe from this model. Additionally you need to implement the following methods to satify the interface:\n\nMandatory Methods\n\nvisanalytic: defines whether the model visibilities can be computed analytically. If yes  then this should return IsAnalytic() and the user must to define visibility_point.  If not analytic then visanalytic should return NotAnalytic().\nimanalytic: defines whether the model intensities can be computed pointwise. If yes   then this should return IsAnalytic() and the user must to define intensity_point.   If not analytic then imanalytic should return NotAnalytic().\nradialextent: Provides a estimate of the radial extent of the model in the image domain.  This is used for estimating the size of the image, and for plotting.\nflux: Returns the total flux of the model.\nintensity_point: Defines how to compute model intensities pointwise. Note this is must be defined if imanalytic(::Type{YourModel})==IsAnalytic().\nvisibility_point: Defines how to compute model visibilties pointwise. Note this is   must be defined if visanalytic(::Type{YourModel})==IsAnalytic().\n\nOptional Methods:\n\nispolarized: Specified whether a model is intrinsically polarized (returns IsPolarized()) or is not (returns NotPolarized()), by default a model is NotPolarized()\nvisibilitymap_analytic: Vectorized version of visibility_point for models where visanalytic returns IsAnalytic()\nvisibilitymap_numeric: Vectorized version of visibility_point for models where visanalytic returns NotAnalytic() typically these are numerical FT's\nintensitymap_analytic: Computes the entire image for models where imanalytic returns IsAnalytic()\nintensitymap_numeric: Computes the entire image for models where imanalytic returns NotAnalytic()\nintensitymap_analytic!: Inplace version of intensitymap\nintensitymap_numeric!: Inplace version of intensitymap\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.visanalytic","page":"Base API","title":"ComradeBase.visanalytic","text":"visanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in Fourier domain, i.e. we can evaluate its fourier transform at an arbritrary point.\n\nIf IsAnalytic() then it will try to call visibility_point to calculate the complex visibilities. Otherwise it fallback to using the FFT that works for all models that can compute an image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.imanalytic","page":"Base API","title":"ComradeBase.imanalytic","text":"imanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in the image domain, i.e. we can evaluate its intensity at an arbritrary point.\n\nIf IsAnalytic() then it will try to call intensity_point to calculate the intensity.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.ispolarized","page":"Base API","title":"ComradeBase.ispolarized","text":"ispolarized(::Type)\n\nTrait function that defines whether a model is polarized or not.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.radialextent","page":"Base API","title":"ComradeBase.radialextent","text":"radialextent(model::AbstractModel)\n\nProvides an estimate of the radial size/extent of the model. This is used internally to estimate image size when plotting and using modelimage\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.DensityAnalytic","page":"Base API","title":"ComradeBase.DensityAnalytic","text":"DensityAnalytic\n\nInternal type for specifying the nature of the model functions. Whether they can be easily evaluated pointwise analytic. This is an internal type that may change.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.IsAnalytic","page":"Base API","title":"ComradeBase.IsAnalytic","text":"struct IsAnalytic <: ComradeBase.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has a analytic fourier transform and/or image.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.NotAnalytic","page":"Base API","title":"ComradeBase.NotAnalytic","text":"struct NotAnalytic <: ComradeBase.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has does not have a easy analytic fourier transform and/or intensity function.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.visibility_point","page":"Base API","title":"ComradeBase.visibility_point","text":"visibility_point(model::AbstractModel, p)\n\nFunction that computes the pointwise visibility. This must be implemented in the model interface if visanalytic(::Type{MyModel}) == IsAnalytic()\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilitymap_analytic","page":"Base API","title":"ComradeBase.visibilitymap_analytic","text":"visibilties_analytic(model, p)\n\nComputes the visibilties of a model using using the analytic visibility expression given by visibility_point.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilitymap_analytic!","page":"Base API","title":"ComradeBase.visibilitymap_analytic!","text":"visibilties_analytic!(vis, model)\n\nComputes the visibilties of a model in-place, using using the analytic visibility expression given by visibility_point.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilitymap_numeric","page":"Base API","title":"ComradeBase.visibilitymap_numeric","text":"visibilties_numeric(model, p)\n\nComputes the visibilties of a model using a numerical fourier transform. Note that none of these are implemented in ComradeBase. For implementations please see Comrade.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilitymap_numeric!","page":"Base API","title":"ComradeBase.visibilitymap_numeric!","text":"visibilties_numeric!(vis, model)\n\nComputes the visibilties of a model in-place using a numerical fourier transform. Note that none of these are implemented in ComradeBase. For implementations please see Comrade.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensity_point","page":"Base API","title":"ComradeBase.intensity_point","text":"intensity_point(model::AbstractModel, p)\n\nFunction that computes the pointwise intensity if the model has the trait in the image domain IsAnalytic(). Otherwise it will use construct the image in visibility space and invert it.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap_analytic","page":"Base API","title":"ComradeBase.intensitymap_analytic","text":"intensitymap_analytic(m::AbstractModel, p::AbstractSingleDomain)\n\nComputes the IntensityMap of a model m using the image dimensions p by broadcasting over the analytic intensity_point method.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap_analytic!","page":"Base API","title":"ComradeBase.intensitymap_analytic!","text":"intensitymap_analytic!(img::IntensityMap, m::AbstractModel)\n\nUpdates the img using the model m  by broadcasting over the analytic intensity_point method.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap_numeric","page":"Base API","title":"ComradeBase.intensitymap_numeric","text":"intensitymap_numeric(m::AbstractModel, p::AbstractSingleDomain)\n\nComputes the IntensityMap of a model m at the image positions p using a numerical method. This has to be specified uniquely for every model m if imanalytic(typeof(m)) === NotAnalytic(). See Comrade.jl for example implementations.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap_numeric!","page":"Base API","title":"ComradeBase.intensitymap_numeric!","text":"intensitymap_numeric!(img::IntensityMap, m::AbstractModel)\n\nUpdates the img using the model m  using a numerical method. This has to be specified uniquely for every model m if imanalytic(typeof(m)) === NotAnalytic(). See Comrade.jl for example implementations.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#Image-Domain","page":"Base API","title":"Image Domain","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"ComradeBase.imagepixels\nComradeBase.RectiGrid\nComradeBase.UnstructuredDomain\nComradeBase.dims\nComradeBase.named_dims\nComradeBase.axisdims\nComradeBase.domainpoints\nComradeBase.fieldofview\nComradeBase.pixelsizes\nComradeBase.phasecenter\nComradeBase.executor\nComradeBase.Serial\nComradeBase.ThreadsEx\nComradeBase.header\nComradeBase.NoHeader\nComradeBase.MinimalHeader","category":"page"},{"location":"base_api/#ComradeBase.imagepixels","page":"Base API","title":"ComradeBase.imagepixels","text":"imagepixels(fovx, fovy, nx, ny; x0=0, y0=0, executor=Serial(), header=NoHeader())\n\nConstruct a grid of pixels with a field of view fovx and fovy and nx and ny pixels. This points are the pixel centers and the field of view goes from the edge of the first pixel to the edge of the last pixel. The x0, y0 offsets shift the image origin over by (x0, y0) in the image plane.\n\nArguments:\n\nfovx::Real: The field of view in the x-direction\nfovy::Real: The field of view in the y-direction\nnx::Integer: The number of pixels in the x-direction\nny::Integer: The number of pixels in the y-direction\n\nKeyword Arguments:\n\nx0::Real=0: The x-offset of the image\ny0::Real=0: The y-offset of the image\nexecutor=Serial(): The executor to use for the grid, default is serial execution\nheader=NoHeader(): The header to use for the grid\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.RectiGrid","page":"Base API","title":"ComradeBase.RectiGrid","text":"RectiGrid(dims::Tuple, header=ComradeBase.NoHeader)\n\nBuilds the EHT image dimensions using the names Na and dimensions dims. You can also optionally has a header that stores additional information from e.g., a FITS header. The type parameter Na defines the names of each dimension. For image domain grids the names are usually one of\n\n(:X, :Y, :Ti, :Fr)\n(:X, :Y, :Fr,  :Ti)\n(:X, :Y) # spatial only\n\nwhere :X,:Y are the RA and DEC spatial dimensions respectively, :Ti is the the time direction and :Fr is the frequency direction. For visibility domain the dimensions usually are:\n\n(:U, :V, :Ti, :Fr)\n(:U, :V, :Fr, :Fr)\n(:U, :V) # spatial only\n\nNotes\n\nInstead use the direct IntensityMap function.\n\ndims = RectiGrid((X(-5.0:0.1:5.0), Y(-4.0:0.1:4.0), Ti([1.0, 1.5, 1.75]), Fr([230, 345])))\n\nNotes\n\nWarning it is rare you need to access this constructor directly. For spatial intensitymaps just use the imagepixels function.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.UnstructuredDomain","page":"Base API","title":"ComradeBase.UnstructuredDomain","text":"UnstructuredDomain(dims::AbstractArray; executor=Serial(), header=ComradeBase.NoHeader)\n\nBuilds an unstructured grid (really a vector of points) from the dimensions dims. The executor is used controls how the grid is computed when calling visibilitymap or intensitymap. The default is Serial which mean regular CPU computations. For threaded execution use ThreadsEx() or load OhMyThreads.jl to uses their schedulers.\n\nNote that unlike RectiGrid which assigns dimensions to the grid points, UnstructuredDomain does not. This is becuase the grid is unstructured the points are a cloud in a space\n\n\n\n\n\n","category":"type"},{"location":"base_api/#DimensionalData.Dimensions.dims","page":"Base API","title":"DimensionalData.Dimensions.dims","text":"dims(g::AbstractSingleDomain)\n\nReturns a tuple containing the dimensions of g. For a named version see ComradeBase.named_dims\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.named_dims","page":"Base API","title":"ComradeBase.named_dims","text":"named_dims(g::AbstractSingleDomain)\n\nReturns a named tuple containing the dimensions of g. For a unnamed version see dims\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.axisdims","page":"Base API","title":"ComradeBase.axisdims","text":"axisdims(img::IntensityMap)\naxisdims(img::IntensityMap, p::Symbol)\n\nReturns the keys of the IntensityMap as the actual internal AbstractRectiGrid object. Optionall the user can ask for a specific dimension with p\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.domainpoints","page":"Base API","title":"ComradeBase.domainpoints","text":"domainpoints(g::AbstractSingleDomain)\n\nCreate a grid iterator that can be used to iterate through different points. All grid methods must implement this method.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.fieldofview","page":"Base API","title":"ComradeBase.fieldofview","text":"fieldofview(img::IntensityMap)\nfieldofview(img::IntensityMap)\n\nReturns a named tuple with the field of view of the image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.pixelsizes","page":"Base API","title":"ComradeBase.pixelsizes","text":"pixelsizes(img::IntensityMap)\npixelsizes(img::AbstractRectiGrid)\n\nReturns a named tuple with the spatial pixel sizes of the image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.phasecenter","page":"Base API","title":"ComradeBase.phasecenter","text":"phasecenter(img::IntensityMap)\n\nComputes the phase center of an intensity map. Note this is the pixels that is in the middle of the image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.executor","page":"Base API","title":"ComradeBase.executor","text":"executor(g::AbstractSingleDomain)\n\nReturns the executor used to compute the intensitymap or visibilitymap\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.Serial","page":"Base API","title":"ComradeBase.Serial","text":"Serial()\n\nUses serial execution when computing the intensitymap or visibilitymap\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.ThreadsEx","page":"Base API","title":"ComradeBase.ThreadsEx","text":"ThreadsEx(scheduler::Symbol = :dynamic)\n\nUses Julia's Threads @threads macro when computing the intensitymap or visibilitymap. You can choose from Julia's various schedulers by passing the scheduler as a parameter. The default is :dynamic, but it isn't considered part of the stable API and may change at any moment.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.header","page":"Base API","title":"ComradeBase.header","text":"header(g::AbstractSingleDomain)\n\nReturns the headerinformation of the dimensions g\n\n\n\n\n\nheader(img::IntensityMap)\n\nRetrieves the header of an IntensityMap\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.NoHeader","page":"Base API","title":"ComradeBase.NoHeader","text":"NoHeader\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.MinimalHeader","page":"Base API","title":"ComradeBase.MinimalHeader","text":"MinimalHeader{T}\n\nA minimal header type for ancillary image information.\n\nFields\n\nsource: Common source name\n\nra: Right ascension of the image in degrees (J2000)\n\ndec: Declination of the image in degrees (J2000)\n\nmjd: Modified Julian Date in days\n\nfrequency: Frequency of the image in Hz\n\n\n\n\n\n","category":"type"},{"location":"base_api/#Image-Types","page":"Base API","title":"Image Types","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"ComradeBase.IntensityMap\nComradeBase.IntensityMap(::AbstractArray, ::AbstractRectiGrid)\nComradeBase.UnstructuredMap\nComradeBase.baseimage\nComradeBase.centroid\nComradeBase.second_moment\nComradeBase.load\nComradeBase.save\nComradeBase.stokes","category":"page"},{"location":"base_api/#ComradeBase.IntensityMap","page":"Base API","title":"ComradeBase.IntensityMap","text":"struct IntensityMap{T, N, D, G<:(ComradeBase.AbstractRectiGrid{D}), A<:AbstractArray{T, N}, R<:Tuple, Na} <: AbstractDimArray{T, N, D, A<:AbstractArray{T, N}}\n\nThis type is the basic array type for all images and models that obey the ComradeBase interface. The type is a subtype of DimensionalData.AbstractDimArray however, we make a few changes to support the Comrade API.\n\nThe dimensions should be specified by an AbstractRectiGrid interface. Usually users just need the RectiGrid grid, for rectilinear grids.\nThere are two ways to access the dimensions of the array. dims(img) will return the usual DimArray dimensions, i.e. a Tuple{DimensionalData.Dim, ...}. The other way to access the array dimensions is using the getproperty, e.g., img.X will return the RA/X grid locations but stripped of the usual DimensionalData.Dimension material. This getproperty behavior is *NOT CONSIDERED** part of the stable API and may be changed in the future.\nMetadata is stored in the AbstractRectiGrid type through the header property and can be accessed through metadata or header\n\nThe most common way to create a IntensityMap is to use the function definitions\n\njulia> g = imagepixels(10.0, 10.0, 128, 128; header=NoHeader())\njulia> X = g.X; Y = g.Y\njulia> data = rand(128, 128)\njulia> img1 = IntensityMap(data, g)\njulia> img2 = IntensityMap(data, (;X, Y); header=header(g))\njulia> img1 == img2\ntrue\njulia> img3 = IntensityMap(data, 10.0, 10.0; header=NoHeader())\n\nBroadcasting, map, and reductions should all just obey the DimensionalData interface.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.IntensityMap-Tuple{AbstractArray, ComradeBase.AbstractRectiGrid}","page":"Base API","title":"ComradeBase.IntensityMap","text":"IntensityMap(data::AbstractArray, g::AbstractRectiGrid; refdims=(), name=Symbol(\"\"))\n\nCreates a IntensityMap with the pixel fluxes data on the grid g. Optionally, you can specify a set of reference dimensions refdims as a tuple and a name for array name.\n\n\n\n\n\n","category":"method"},{"location":"base_api/#ComradeBase.UnstructuredMap","page":"Base API","title":"ComradeBase.UnstructuredMap","text":"UnstructuredMap(data::AbstractVector, dims::UnstructuredDomain)\n\nA map that is defined on an unstructured domain. This is typically just a vector of values. The vector of locations of the visibilities are stored in dims. Otherwise this behaves very similarly to IntensityMap, except that is isn't a grid.\n\nFor instance the locations of the visibilities can be accessed with axisdims, as well as the usual getproperty and propertynames functions. Like with IntensityMap during execution the executor is used to determine the execution context.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.baseimage","page":"Base API","title":"ComradeBase.baseimage","text":"Returns the base image of a intensity map type object\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.centroid","page":"Base API","title":"ComradeBase.centroid","text":"centroid(im::AbstractIntensityMap)\n\nComputes the image centroid aka the center of light of the image.\n\nFor polarized maps we return the centroid for Stokes I only.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.second_moment","page":"Base API","title":"ComradeBase.second_moment","text":"second_moment(im::AbstractIntensityMap; center=true)\n\nComputes the image second moment tensor of the image. By default we really return the second cumulant or centered second moment, which is specified by the center argument.\n\nFor polarized maps we return the second moment for Stokes I only.\n\n\n\n\n\nsecond_moment(im::AbstractIntensityMap; center=true)\n\nComputes the image second moment tensor of the image. By default we really return the second cumulant or centered second moment, which is specified by the center argument.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.load","page":"Base API","title":"ComradeBase.load","text":"ComradeBase.load(fitsfile::String, IntensityMap)\n\nThis loads in a fits file that is more robust to the various imaging algorithms in the EHT, i.e. is works with clean, smili, eht-imaging. The function returns an tuple with an intensitymap and a second named tuple with ancillary information about the image, like the source name, location, mjd, and radio frequency.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.save","page":"Base API","title":"ComradeBase.save","text":"ComradeBase.save(file::String, img::IntensityMap, obs)\n\nSaves an image to a fits file. You can optionally pass an EHTObservation so that ancillary information will be added.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.stokes","page":"Base API","title":"ComradeBase.stokes","text":"stokes(m::AbstractPolarizedModel, p::Symbol)\n\nExtract the specific stokes component p from the polarized model m\n\n\n\n\n\nstokes(m::AbstractArray{<:StokesParams}, p::Symbol)\n\nExtract the specific stokes component p from the polarized image m.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#Polarization","page":"Base API","title":"Polarization","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"ComradeBase.AbstractPolarizedModel\nPolarizedTypes.StokesParams\nPolarizedTypes.ElectricFieldBasis\nPolarizedTypes.RPol\nPolarizedTypes.LPol\nPolarizedTypes.XPol\nPolarizedTypes.YPol\nPolarizedTypes.PolBasis\nPolarizedTypes.CirBasis\nPolarizedTypes.LinBasis\nPolarizedTypes.CoherencyMatrix\nPolarizedTypes.evpa\nPolarizedTypes.m̆\nPolarizedTypes.linearpol\nPolarizedTypes.innerprod\nPolarizedTypes.basis_components\nPolarizedTypes.basis_transform\nPolarizedTypes.polarization\nPolarizedTypes.fracpolarization","category":"page"},{"location":"base_api/#ComradeBase.AbstractPolarizedModel","page":"Base API","title":"ComradeBase.AbstractPolarizedModel","text":"abstract type AbstractPolarizedModel <: ComradeBase.AbstractModel\n\nA generic polarized model. To implement the use needs to follow the AbstractModel implementation instructions. In addtion there is an optional method stokes(model, p::Symbol) which extracts the specific stokes parameter of the model. The default that the different stokes parameters are stored as fields of the model. To overwrite this behavior overload the function.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.StokesParams","page":"Base API","title":"PolarizedTypes.StokesParams","text":"struct StokesParams{T} <: StaticArraysCore.FieldVector{4, T}\n\nStatic vector that holds the stokes parameters of a polarized complex visibility\n\nTo convert between a StokesParams and CoherencyMatrix use the convert function\n\nconvert(::CoherencyMatrix, StokesVector(1.0, 0.1, 0.1, 0.4))\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.ElectricFieldBasis","page":"Base API","title":"PolarizedTypes.ElectricFieldBasis","text":"abstract type ElectricFieldBasis\n\nAn abstract type whose subtypes denote a specific electric field basis.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.RPol","page":"Base API","title":"PolarizedTypes.RPol","text":"struct RPol <: PolarizedTypes.ElectricFieldBasis\n\nThe right circular electric field basis, i.e. a right-handed circular feed.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.LPol","page":"Base API","title":"PolarizedTypes.LPol","text":"struct LPol <: PolarizedTypes.ElectricFieldBasis\n\nThe left circular electric field basis, i.e. a left-handed circular feed.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.XPol","page":"Base API","title":"PolarizedTypes.XPol","text":"struct XPol <: PolarizedTypes.ElectricFieldBasis\n\nThe horizontal or X electric feed basis, i.e. the horizontal linear feed.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.YPol","page":"Base API","title":"PolarizedTypes.YPol","text":"struct YPol <: PolarizedTypes.ElectricFieldBasis\n\nThe vertical or Y electric feed basis, i.e. the vertical linear feed.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.PolBasis","page":"Base API","title":"PolarizedTypes.PolBasis","text":"struct PolBasis{B1<:Union{Missing, PolarizedTypes.ElectricFieldBasis}, B2<:Union{Missing, PolarizedTypes.ElectricFieldBasis}}\n\nDenotes a general polarization basis, with basis vectors (B1,B2) which are typically <: Union{ElectricFieldBasis, Missing}\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.CirBasis","page":"Base API","title":"PolarizedTypes.CirBasis","text":"CirBasis <: PolBasis\n\nMeasurement uses the circular polarization basis, which is typically used for circular feed interferometers.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.LinBasis","page":"Base API","title":"PolarizedTypes.LinBasis","text":"LinBasis <: PolBasis\n\nMeasurement uses the linear polarization basis, which is typically used for linear feed interferometers.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.CoherencyMatrix","page":"Base API","title":"PolarizedTypes.CoherencyMatrix","text":"struct CoherencyMatrix{B1, B2, T} <: StaticArraysCore.FieldMatrix{2, 2, T}\n\nCoherency matrix for a single baseline with bases B1 and B2. The two bases correspond to the type of feeds used for each telescope and should be subtypes of PolBasis. To see which bases are implemented type subtypes(Rimes.PolBasis) in the REPL.\n\nFor a circular basis the layout of the coherency matrix is\n\nRR* RL*\nLR* RR*\n\nwhich can be constructed using\n\nc = CoherencyMatrix(RR, LR, RL, LL, CirBasis())\n\nFor a linear basis the layout of the coherency matrix is\n\nXX* XY*\nYX* YY*\n\nwhich can be constructed using\n\nc = CoherencyMatrix(XX, YX, XY, YY, CirBasis())\n\nFor a mixed (e.g., circular and linear basis) the layout of the coherency matrix is\n\nRX* RY*\nLX* LY*\n\nor e.g., linear and circular the layout of the coherency matrix is\n\nXR* XL*\nYR* YL*\n\nThese coherency matrices can be constructed using:\n\n# Circular and linear feeds i.e., |R><X|\nc = CoherencyMatrix(RX, LX, RY, LY, LinBasis(), CirBasis())\n# Linear and circular feeds i.e., |X><R|\nc = CoherencyMatrix(XR, YR, XL, YL, LinBasis(), CirBasis())\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.evpa","page":"Base API","title":"PolarizedTypes.evpa","text":"evpa(m::Union{StokesParams, CoherencyMatrix})\n\nCompute the evpa of a stokes vect or cohereny matrix.\n\n\n\n\n\nevpa(pimg::AbstractPolarizedModel, p)\n\nelectric vector position angle or EVPA of the polarized model pimg at p\n\n\n\n\n\n","category":"function"},{"location":"base_api/#PolarizedTypes.m̆","page":"Base API","title":"PolarizedTypes.m̆","text":"m̆(m::Union{StokesParameters{<:Complex}, CoherencyMatrix)\n\nComputes the complex fractional linear polarization of the complex or visibility quantities. Note that this function can also be called used mbreve\n\n\n\n\n\nm̆(pimg::AbstractPolarizedModel, p)\nmbreve(pimg::AbstractPolarizedModel, p)\n\nComputes the fractional linear polarization in the visibility domain\n\nm̆ = (Q̃ + iŨ)/Ĩ\n\nTo create the symbol type m\\breve in the REPL or use the mbreve function.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#PolarizedTypes.linearpol","page":"Base API","title":"PolarizedTypes.linearpol","text":"linearpol(s)\n\n\nComputes linearpol from a set of stokes parameters s.\n\n\n\n\n\nlinearpol(pimg::AbstractPolarizedModel, p)\n\nReturn the complex linear polarization of the model m at point p.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#PolarizedTypes.innerprod","page":"Base API","title":"PolarizedTypes.innerprod","text":"innerprod(::Type{T}, XPol(), YPol())\n\nComputes the complex inner product of two elements of a complex Hilbert space X and Y where base element of the output is T.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#PolarizedTypes.basis_components","page":"Base API","title":"PolarizedTypes.basis_components","text":"basis_components([T=Float64,], e::ElectricFieldBasis, b::PolBasis)\n\nReturns a static vector that contains the components of the electric field basis vector e in terms of the polarization basis b. The first argument is optionally the eltype of the static vector.\n\nExamples\n\njulia> basis_components(Float64, R(), PolBasis{XPol,Y}())\n2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):\n 0.7071067811865475 + 0.0im\n                0.0 - 0.7071067811865475im\n\njulia> basis_components(R(), PolBasis{XPol,Y}())\n2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):\n 0.7071067811865475 + 0.0im\n                0.0 - 0.7071067811865475im\n\n\njulia> basis_components(Float64, X(), PolBasis{XPol,Y}())\n2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):\n 1.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"base_api/#PolarizedTypes.basis_transform","page":"Base API","title":"PolarizedTypes.basis_transform","text":"basis_transform([T=Float64,], b1::PolBasis, b2::PolBasis)\nbasis_transform([T=Float64,], b1::PolBasis=>b2::PolBasis)\n\nProduces the transformation matrix that transforms the vector components from basis b1 to basis b2. This means that if for example E is the circular basis then basis_transform(CirBasis=>LinBasis)E is in the linear basis. In other words the columns of the transformation matrix are the coordinate vectors of the new basis vectors in the old basis.\n\nExample\n\njulia> basis_transform(CirBasis()=>LinBasis())\n2×2 StaticArraysCore.SMatrix{2, 2, ComplexF64, 4} with indices SOneTo(2)×SOneTo(2):\n 0.707107-0.0im       0.707107-0.0im\n      0.0-0.707107im       0.0+0.707107im\n\n\n\n\n\n","category":"function"},{"location":"base_api/#PolarizedTypes.polarization","page":"Base API","title":"PolarizedTypes.polarization","text":"polarization(s)\n\n\nReturns the (Q, U, V) polarization vector as a 3-element static vector.\n\n\n\n\n\npolarization(pimg::AbstractPolarizedModel, p)\n\nReturn the polarization vector (Q, U, V) of the model m at point p.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#PolarizedTypes.fracpolarization","page":"Base API","title":"PolarizedTypes.fracpolarization","text":"fracpolarization(s)\n\n\nReturns the (Q/I, U/I, V/I) fractional polarization vector as a 3-element static vector.\n\n\n\n\n\nfracpolarization(pimg::AbstractPolarizedModel, p)\n\nReturn the fractional polarization vector (Q/I, U/I, V/I) of the model m at point p.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#Internal-Methods-not-part-of-public-API","page":"Base API","title":"Internal Methods not part of public API","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"ComradeBase._visibilitymap\nComradeBase._visibilitymap!\nComradeBase.create_map","category":"page"},{"location":"base_api/#ComradeBase._visibilitymap","page":"Base API","title":"ComradeBase._visibilitymap","text":"_visibilitymap(model::AbstractModel, p)\n\nInternal method used for trait dispatch and unpacking of args arguments in visibilities\n\nwarn: Warn\nNot part of the public API so it may change at any moment.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase._visibilitymap!","page":"Base API","title":"ComradeBase._visibilitymap!","text":"_visibilitymap!(model::AbstractModel, p)\n\nInternal method used for trait dispatch and unpacking of args arguments in visibilities!\n\nwarn: Warn\nNot part of the public API so it may change at any moment.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.create_map","page":"Base API","title":"ComradeBase.create_map","text":"create_map(array, g::AbstractSingleDomain)\n\nCreate a map of values specialized by the grid g.\n\n\n\n\n\n","category":"function"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Contents","page":"API","title":"Contents","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Model-Definitions","page":"API","title":"Model Definitions","text":"","category":"section"},{"location":"api/#Combinators","page":"API","title":"Combinators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Base.:+(::VLBISkyModels.AbstractModel, ::VLBISkyModels.AbstractModel)\nVLBISkyModels.added\nVLBISkyModels.convolved\nVLBISkyModels.components\nVLBISkyModels.smoothed\nVLBISkyModels.CompositeModel\nVLBISkyModels.AddModel\nVLBISkyModels.ConvolvedModel","category":"page"},{"location":"api/#Base.:+-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractModel}","page":"API","title":"Base.:+","text":"Base.:+(m1::AbstractModel, m2::AbstractModel)\n\nCombine two models to create a composite AddModel. This adds two models pointwise, i.e.\n\njulia> m1 = Gaussian()\njulia> m2 = Disk()\njulia> visibility(m1+m2, 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#VLBISkyModels.added","page":"API","title":"VLBISkyModels.added","text":"added(m1::AbstractModel, m2::AbstractModel)\n\nCombine two models to create a composite AddModel. This adds two models pointwise, i.e.\n\njulia> m1 = Gaussian()\njulia> m2 = Disk()\njulia> visibility(added(m1,m2), 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.convolved","page":"API","title":"VLBISkyModels.convolved","text":"convolved(m1::AbstractModel, m2::AbstractModel)\n\nConvolve two models to create a composite ConvolvedModel.\n\njulia> m1 = Ring()\njulia> m2 = Disk()\njulia> convolved(m1, m2)\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.components","page":"API","title":"VLBISkyModels.components","text":"components(m::AbstractModel)\n\nReturns the model components for a composite model. This will return a Tuple with all the models you have constructed.\n\nExample\n\njulia> m = Gaussian() + Disk()\njulia> components(m)\n(Gaussian{Float64}(), Disk{Float64}())\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.smoothed","page":"API","title":"VLBISkyModels.smoothed","text":"smoothed(m::AbstractModel, σ::Number)\n\nSmooths a model m with a Gaussian kernel with standard deviation σ.\n\nNotes\n\nThis uses convolved to created the model, i.e.\n\njulia> m1 = Disk()\njulia> m2 = Gaussian()\njulia> convolved(m1, m2) == smoothed(m1, 1.0)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.CompositeModel","page":"API","title":"VLBISkyModels.CompositeModel","text":"abstract type CompositeModel{M1, M2} <: ComradeBase.AbstractModel\n\nAbstract type that denotes a composite model. Where we have combined two models together.\n\nImplementation\n\nAny implementation of a composite type must define the following methods:\n\nvisibility_point\nuv_combinator\nimanalytic\nvisanalytic\nComradeBase.intensity_point if model intensity is IsAnalytic\nintensitymap_numeric! if model intensity is NotAnalytic\nintensitymap_numeric if model intensity is NotAnalytic\nflux\nradialextent\n\nIn addition there are additional optional methods a person can define if needed:\n\nintensitymap_analytic! if model intensity is IsAnalytic  (optional)\nintensitymap_analytic if model intensity is IsAnalytic (optional)\nvisibilitymap_analytic if visanalytic is IsAnalytic (optional)\nvisibilitymap_numeric  if visanalytic is Not Analytic (optional)\nvisibilitymap_analytic! if visanalytic is IsAnalytic (optional)\nvisibilitymap_numeric!  if visanalytic is Not Analytic (optional)\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.AddModel","page":"API","title":"VLBISkyModels.AddModel","text":"struct AddModel{T1, T2} <: VLBISkyModels.CompositeModel{T1, T2}\n\nPointwise addition of two models in the image and visibility domain. An end user should instead call added or Base.+ when constructing a model\n\nExample\n\njulia> m1 = Disk() + Gaussian()\njulia> m2 = added(Disk(), Gaussian()) + Ring()\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ConvolvedModel","page":"API","title":"VLBISkyModels.ConvolvedModel","text":"struct ConvolvedModel{M1, M2} <: VLBISkyModels.CompositeModel{M1, M2}\n\nPointwise addition of two models in the image and visibility domain. An end user should instead call convolved. Also see smoothed(m, σ) for a simplified function that convolves a model m with a Gaussian with standard deviation σ.\n\n\n\n\n\n","category":"type"},{"location":"api/#Geometric-and-Image-Models","page":"API","title":"Geometric and Image Models","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.GeometricModel\nVLBISkyModels.ConcordanceCrescent\nVLBISkyModels.Crescent\nVLBISkyModels.Disk\nVLBISkyModels.SlashedDisk\nVLBISkyModels.ExtendedRing\nVLBISkyModels.Gaussian\nVLBISkyModels.MRing\nVLBISkyModels.Ring\nVLBISkyModels.ParabolicSegment\nVLBISkyModels.ZeroModel\nVLBISkyModels.MultiComponentModel\nVLBISkyModels.PolarizedModel\nVLBISkyModels.AbstractImageTemplate\nVLBISkyModels.RingTemplate\nVLBISkyModels.RadialGaussian\nVLBISkyModels.RadialDblPower\nVLBISkyModels.RadialTruncExp\nVLBISkyModels.AzimuthalUniform\nVLBISkyModels.AzimuthalCosine\nVLBISkyModels.GaussianRing\nVLBISkyModels.SlashedGaussianRing\nVLBISkyModels.EllipticalGaussianRing\nVLBISkyModels.EllipticalSlashedGaussianRing\nVLBISkyModels.CosineRing\nVLBISkyModels.CosineRingwFloor\nVLBISkyModels.CosineRingwGFloor\nVLBISkyModels.EllipticalCosineRing\nVLBISkyModels.LogSpiral\nVLBISkyModels.Constant\nVLBISkyModels.GaussDisk\nVLBISkyModels.ContinuousImage","category":"page"},{"location":"api/#VLBISkyModels.GeometricModel","page":"API","title":"VLBISkyModels.GeometricModel","text":"abstract type GeometricModel{T} <: ComradeBase.AbstractModel\n\nA type that defines it is a geometric model. These are usually primitive models, and are usually analytic in Fourier and the image domain. As a result a user only needs to implement the following methods\n\nvisibility_point\nintensity_point\nradialextent\n\nNote that if the geometric model isn't analytic then the usual methods listed in ComradeBase.AbstractModel for non-analytic models need to be implemented.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ConcordanceCrescent","page":"API","title":"VLBISkyModels.ConcordanceCrescent","text":"struct ConcordanceCrescent{T} <: VLBISkyModels.GeometricModel{T}\n\nCreates the ConcordanceCrescent model, i.e. a flat-top crescent with a displacment and a slash and shadow depth. Note this creates a crescent with unit flux. If you want a different flux please use the renomed modifier.\n\nFields\n\nrouter: Outer radius of the crescent\n\nrinner: Inner radius of the crescent (i.e. inside this radius there is a hole)\n\nshift: Displacment of the inner disk radius\n\nslash: Strength of the linear slash. Note that s∈[0.0,1.0] to ensure positivity in the image.\n\nNotes\n\nUnlike the Gaussian and Disk models this does not create the unit version. In fact, this model could have been created using the Disk and primitives by using VLBISkyModels's model composition functionality.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Crescent","page":"API","title":"VLBISkyModels.Crescent","text":"Creates a Kamruddin and Dexter crescent model. This works by composing two disk models together.\n\nArguments\n\nrouter: The radius of the outer disk\nrinner: The radius of the inner disk\nshift: How much the inner disk radius is shifted (positive is to the right)\nfloor: The floor of the inner disk 0 means the inner intensity is zero and 1 means it is a large disk.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.Disk","page":"API","title":"VLBISkyModels.Disk","text":"Disk{T}() where {T}\n\nTophat disk geometrical model, i.e. the intensity profile\n\n    I(xy) = begincases pi^-1  x^2+y^2  1  0  x^2+y^2 geq 0 endcases\n\ni.e. a unit radius and unit flux disk.\n\nBy default if T isn't given, Disk defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.SlashedDisk","page":"API","title":"VLBISkyModels.SlashedDisk","text":"SlashedDisk{T}(slash::T) where {T}\n\nTophat disk geometrical model, i.e. the intensity profile\n\n    I(xy) = begincases pi^-1  x^2+y^2  1  0  x^2+y^2 geq 0 endcases\n\ni.e. a unit radius and unit flux disk.\n\nBy default if T isn't given, Disk defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ExtendedRing","page":"API","title":"VLBISkyModels.ExtendedRing","text":"struct ExtendedRing{T} <: VLBISkyModels.GeometricModel{T}\n\nA symmetric extended ring whose radial profile follows an inverse gamma distributions.\n\nThe formula in the image domain is given by\n\nI(r,θ) = βᵅrᵅ⁻²exp(-β/r)/2πΓ(α)\n\nwhere α = shape and β = shape+1\n\nNote\n\nWe mainly use this as an example of a non-analytic Fourier transform (although it has a complicated expression)\n\nFields\n\nshape: shape of the radial distribution\n\nNote that if T isn't specified at construction then it defaults to Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Gaussian","page":"API","title":"VLBISkyModels.Gaussian","text":"struct Gaussian{T} <: VLBISkyModels.GeometricModel{T}\n\nGaussian with unit standard deviation and flux.\n\nBy default if T isn't given, Gaussian defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.MRing","page":"API","title":"VLBISkyModels.MRing","text":"struct MRing{T, V<:Union{AbstractArray{T, 1}, Tuple{Vararg{T, N}} where {N, T}}} <: VLBISkyModels.GeometricModel{T}\n\nm-ring geometric model. This is a infinitely thin unit flux delta ring whose angular structure is given by a Fourier expansion. That is,\n\nI(r,θ) = (2π)⁻¹δ(r-1)∑ₙ(αₙcos(nθ) - βₙsin(nθ))\n\nThe N in the type defines the order of the Fourier expansion.\n\nFields\n\nα: Real Fourier mode coefficients\n\nβ: Imaginary Fourier mode coefficients\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Ring","page":"API","title":"VLBISkyModels.Ring","text":"struct Ring{T} <: VLBISkyModels.GeometricModel{T}\n\nA infinitely thin ring model, whose expression in the image domain is     I(r,θ) = δ(r - 1)/2π i.e. a unit radius and flux delta ring.\n\nBy default if T isn't given, Gaussian defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ParabolicSegment","page":"API","title":"VLBISkyModels.ParabolicSegment","text":"struct ParabolicSegment{T} <: VLBISkyModels.GeometricModel{T}\n\nA infinitely thin parabolic segment in the image domain. The segment is centered at zero, with roots ±1 and a yintercept of 1.\n\nNote that if T isn't specified at construction then it defaults to Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ZeroModel","page":"API","title":"VLBISkyModels.ZeroModel","text":"struct ZeroModel{T} <: ComradeBase.AbstractModel\n\nDefines a model that is empty that is it return zero for everything.\n\nNotes\n\nThis returns 0 by using FillArrays so everything should be non-allocating\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.MultiComponentModel","page":"API","title":"VLBISkyModels.MultiComponentModel","text":"MultiComponentModel(beam::AbstractModel, fluxes::AbstractVector, x::AbstractVector, y::AbstractVector)\n\nBuild a model with a base model type beam where fluxes, x, y corresond to the flux, and positions of the components. This can be used to construct clean like models.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.PolarizedModel","page":"API","title":"VLBISkyModels.PolarizedModel","text":"struct PolarizedModel{TI, TQ, TU, TV} <: ComradeBase.AbstractPolarizedModel\n\nWrapped model for a polarized model. This uses the stokes representation of the image.\n\nFields\n\nI: Stokes I model\n\nQ: Stokes Q Model\n\nU: Stokes U Model\n\nV: Stokes V Model\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.AbstractImageTemplate","page":"API","title":"VLBISkyModels.AbstractImageTemplate","text":"abstract type AbstractImageTemplate <: ComradeBase.AbstractModel\n\nAn abstract ComradeBase.AbstractModel that serves as the parent type of all the VIDA templates implemented in this repo.\n\nBy default this model assumes the following ComradeBase traits\n\nComradeBase.visanalytic(::Type{<:AbstractImageTemplate}) = NoAnalytic()\nComradeBase.imanalytic(::Type{<:AbstractImageTemplate})  = IsAnalytic()\nComradeBase.ispolarized(::Type{<:AbstractImageTemplate}) = NotPolarized()\n\nAs a result if a user wishes the implement their own subtype (e.g., MyTemplate) of AbstratImageTemplate they will need to implement the following methods\n\nComradeBase.intensity_point(m::MyTemplate, p): which computes the potentially unormalized brightness of the template at the point p.\nComradeBase.radialextent(m::MyTemplate): which computes the rough radial extent of the model m.\n\nFor more information about the total interface see VLBISkyModels.jl\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.RingTemplate","page":"API","title":"VLBISkyModels.RingTemplate","text":"struct RingTemplate{R<:VLBISkyModels.AbstractRadial, A<:VLBISkyModels.AbstractAzimuthal} <: VLBISkyModels.AbstractImageTemplate\n\nA flexible ring template that forms a ring by taking the product of a radial and azimuthal brightness profile.\n\nA list of radial profiles is given by subtypes(AbstractRadial)\n\nA list of azimuthal profiles is given by subtypes(AbstractAzimuthal)\n\nExamples\n\njulia> rad = RadialGaussian(0.1)\njulia> azi = AzimuthalUniform()\njulia> ring = modify(RingTemplate(rad, azi), Stretch(10.0), Shift(1.0, 2.0))\n\nFields\n\nradial: Radial profile of the ring\n\nazimuthal: Azimuthal profile of the ring\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.RadialGaussian","page":"API","title":"VLBISkyModels.RadialGaussian","text":"RadialGaussian(σ)\n\nCreate a profile that is a radial gaussian ring with radius unity and standard deviation σ.\n\nNotes\n\nThis is usually couple with a azimuthal profile to create a general ring template\n\njulia> rad = RadialGaussian(0.1)\njulia> azi = AzimuthalUniform()\njulia> t = RingTemplate(rad, azi)\n\nArguments\n\nσ: The standard deviation for the Gaussian ring.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.RadialDblPower","page":"API","title":"VLBISkyModels.RadialDblPower","text":"RadialDblPower(αinner, αouter)\n\nRadial profile that given by a double power-law with the function form\n\n    r^αinner*inv(1+ r^(αinner + αouter + 1))\n\nNotes\n\nThis is usually couple with a azimuthal profile to create a general ring template\n\njulia> rad = RadialDblPower(3.0, 3.0)\njulia> azi = AzimuthalUniform()\njulia> t = RingTemplate(rad, azi)\n\nArguments\n\nαinner the power law index for r<1.\nαouter the power law index for r≥1.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.RadialTruncExp","page":"API","title":"VLBISkyModels.RadialTruncExp","text":"RadialTruncExp(σ)\n\nRadial profile that has a exponential profile up to a cutoff radius of 1 where for r<1 the profile is identically zero.\n\nThis evalutes to\n\n    exp(-(r-1)/σ)\n\nNotes\n\nThis is usually couple with a azimuthal profile to create a general ring template\n\njulia> rad = RadialTruncExp(2.0)\njulia> azi = AzimuthalUniform()\njulia> t = RingTemplate(rad, azi)\n\nArguments\n\nσ: Exponential inverse fall off parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.AzimuthalUniform","page":"API","title":"VLBISkyModels.AzimuthalUniform","text":"AzimuthalUniform()\nAzimuthalUniform{T}()\n\nA azimuthal profile that is uniform for all angles.\n\nNotes\n\nThis is usually couple with a radial profile to create a general ring template\n\njulia> rad = RadialDblPower(3.0, 3.0)\njulia> azi = AzimuthalUniform() # Defaults to Float64\njulia> t = RingTemplate(rad, azi)\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.AzimuthalCosine","page":"API","title":"VLBISkyModels.AzimuthalCosine","text":"AzimuthalCosine(s::NTuple{N,T}, ξ::NTuple{N, T}) where {N, T}\n\nA azimuthal profile that is  given by a cosine expansion of order N. The expansion is given by\n\n    1 - ∑ₙ sₙcos(nϕ - ξₙ)\n\nNotes\n\nThis is usually couple with a radial profile to create a general ring template\n\njulia> rad = RadialDblPower(3.0, 3.0)\njulia> azi = AzimuthalCosine((0.5, 0.2), (0.0, π/4)) # Defaults to Float64\njulia> t = RingTemplate(rad, azi)\n\nArguments\n\ns : amplitudes of the N order cosine expansion of the azimuthal brightness\nξs: phase of the N order cosine expansion of the azimuthal brightness\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.GaussianRing","page":"API","title":"VLBISkyModels.GaussianRing","text":"GaussianRing(σ)\n\n\nImplements the gaussian ring template.\n\nNotes\n\nThis is a convienence constructor that uses RingTemplate under the hood. To create this function your self do\n\nRingTemplate(RadialGaussian(σ), AzimuthalUniform())\n\nArguments\n\nσ : standard deviation of the Gaussian ring\n\n\n\n\n\nGaussianRing(r0, σ, x0, y0)\n\n\nImplements the gaussian ring template.\n\nNotes\n\nThis is a convienence constructor that uses RingTemplate under the hood. To create this function your self do\n\nmodify(GaussianRing(σ/r0), Stretch(r0), Shift(x0, y0))\n\nArguments\n\nr0: radius of the ring\nσ : standard deviation of the Gaussian ring\nx0: location of the ring center horizontally\ny0: location of the ring center vertically\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.SlashedGaussianRing","page":"API","title":"VLBISkyModels.SlashedGaussianRing","text":"SlashedGaussianRing(σ, s)\n\n\nImplements the slashed gaussian ring template, that uses a cosine to implement the slash and has a brightness position angle of 0 degrees east of north.\n\nArguments\n\nσ : standard deviation of the Gaussian ring\ns : Slash amplitude. 0 means no slash, and 1 is maximal.\n\nNotes\n\nThis is a convienence constructor that uses RingTemplate under the hood. To create this function your self do\n\nRingTemplate(RadialGaussian(σ), AzimuthalCosine((s,), (zero(s),)))\n\n\n\n\n\nSlashedGaussianRing(r0, σ, s, ξ, x0, y0)\n\n\nImplements the slashed gaussian ring template, that uses a cosine to implement the slash.\n\nArguments\n\nr0: radius of the ring\nσ : standard deviation of the Gaussian ring\ns : Slash amplitude. 0 means no slash, and 1 is maximal.\nξs: azimuthal peak brightness P.A. measured east of north\nx0: location of the ring center horizontally\ny0: location of the ring center vertically\n\nNotes\n\nThis is a convienence constructor that uses RingTemplate under the hood. To create this function your self do\n\nmodify(SlashedGaussianRing(σ/r0, s), Stretch(r0), Rotate(ξ), Shift(x0, y0))\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.EllipticalGaussianRing","page":"API","title":"VLBISkyModels.EllipticalGaussianRing","text":"EllipticalGaussianRing(r0, σ, τ, ξτ, x0, y0)\n\n\nImplements the elliptical gaussian ring template with semi-minor axis a and semi-major axis b.\n\nArguments\n\nr0: geometric mean radius (√ab) of the ring\nσ : standard deviation of the Gaussian ring\nτ : asymmetry of the ring τ = 1-b/a\nξτ: semi-major axis measured east of north\nx0: location of the ring center horizontally\ny0: location of the ring center vertically\n\nNotes\n\nThis is a convienence constructor that uses RingTemplate under  the hood. To create this function your self do\n\njulia  modify(GaussianRing(σ/r0), Stretch(r0*sqrt(1-τ), r0/sqrt(1-τ)), Rotate(ξτ), Shift(x0, y0))\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.EllipticalSlashedGaussianRing","page":"API","title":"VLBISkyModels.EllipticalSlashedGaussianRing","text":"EllipticalSlashedGaussianRing(r0, σ, τ, ξτ, s, ξs, x0, y0)\n\n\nCombination of the elliptical and slashed gaussian ring.\n\nDetails\n\nAdds ellipticity to the ring. The radius r0 of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.\n\nr0 = √(a*b).\n\nThe ellipticity τ is given by τ = 1-b/a.\n\nThe brightness asymmetry uses a cosine to implement the slash.\n\nArguments\n\nr0: geometric mean radius (√ab) of the Gaussian ring\nσ : standard deviation of the Gaussian ring\nτ : asymmetry of the Gaussian ring τ = 1-b/a\nξτ: semi-major axis measured east of north\ns : Slash amplitude. 0 means no slash, and 1 is maximal.\nξs: azimuthal peak brightness P.A. measured east of north\nx0: location of the ring center horizontally\ny0: location of the ring center vertically\n\nNotes\n\nThis is a convienence constructor that uses RingTemplate under  the hood. To create this function your self we define\n\njulia  modify(SlashedGaussianRing(σ/r0, s),             Rotate(ξs-ξτ),             Stretch(r0*sqrt(1-τ), r0/sqrt(1-τ)),             Rotate(ξτ),             Shift(x0, y0)         )\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.CosineRing","page":"API","title":"VLBISkyModels.CosineRing","text":"struct CosineRing{N, M, T} <: VLBISkyModels.AbstractImageTemplate\n\nA flexible symmetric ring model. The thickness is modeled as a cosine expansion with N terms and the slash by a expansion with M terms.\n\nDetails\n\nThe ring is forced to be symmetric for a significant speed boost over CosineRing. The thickness of the ring is modeled by a cosine expansion in azimuthal angle. N specifies the number of cosine modes to fit, where the first mode is the constant thickness portion and so has no corresponding angle. The slash is modeled as a separate cosine expansion, with M terms. Here the zero order term is forced to be unity, so M defines the M additional terms.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.CosineRingwFloor","page":"API","title":"VLBISkyModels.CosineRingwFloor","text":"CosineRingwFloor(r0, σ0, σ, ξσ, s, ξs, floor, x0, y0)\n\n\nA Cosine ring with a GaussDisk at the center of the ring that matches the r0 and σ0 of the CosineRing.\n\nThis is a convienence constructor of the more basic VLBISkyModel image constructors. It is equivalent to\n\njulia> CosineRing(r0, σ0, σ, ξσ, s, ξs, x0, y0) + floor*modify(GaussDisk(σ0/r0), Stretch(r0), Shift(x0, y0))\n\nDetails\n\nAdds ellipticity to the ring. The radius r0 of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.\n\nr0 = √(a*b).\n\nThe ellipticity τ is given by τ = 1-b/a.\n\nArguments\n\nr0: geometric mean radius (√ab) of the ring\nσ0: standard deviation of the Gaussian ring\nσ : amplitudes of the N order cosine expansion of the ring thickness\nξσ: phase of the N order cosine expansion of the ring thickness\ns : amplitudes of the M order cosine expansion of the azimuthal brightness\nξs: phase of the M order cosine expansion of the azimuthal brightness\nfloor: The flux of the center Gaussian. This is relative to the CosineRing.\nx0: location of the ring center horizontally\ny0: location of the ring center vertically\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.CosineRingwGFloor","page":"API","title":"VLBISkyModels.CosineRingwGFloor","text":"CosineRingwGFloor(r0, σ0, σ, ξσ, s, ξs, floor, σG, x0, y0)\n\n\nA Cosine ring with a Gaussian blob at the center of the ring. This is a convienence constructor of the more basic VLBISkyModel image constructors. It is equivalent to\n\njulia> CosineRing(r0, σ0, σ, ξσ, s, ξs, x0, y0) + floor*modify(Gaussian(), Stretch(σG), Shift(x0, y0))\n\nDetails\n\nAdds ellipticity to the ring. The radius r0 of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.\n\nr0 = √(a*b).\n\nThe ellipticity τ is given by τ = 1-b/a.\n\nArguments\n\nr0: geometric mean radius (√ab) of the ring\nσ0: standard deviation of the Gaussian ring\nσ : amplitudes of the N order cosine expansion of the ring thickness\nξσ: phase of the N order cosine expansion of the ring thickness\ns : amplitudes of the M order cosine expansion of the azimuthal brightness\nξs: phase of the M order cosine expansion of the azimuthal brightness\nfloor: The flux of the center Gaussian. This is relative to the CosineRing.\nσG: The size of the central Gaussian.\nx0: location of the ring center horizontally\ny0: location of the ring center vertically\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.EllipticalCosineRing","page":"API","title":"VLBISkyModels.EllipticalCosineRing","text":"EllipticalCosineRing(r0, σ0, σ, ξσ, τ, ξτ, s, ξs, x0, y0)\n\n\nAn Elliptical Cosine ring. This is a convienence constructor of the more basic VLBISkyModel image constructors. It is equivalent to\n\njulia> modify(CosineRing(σ0/r0, σ/r0, ξσ, s, ξs .- ξτ),\n            Stretch(r0*sqrt(1-τ), r0/sqrt(1-τ)),\n            Rotate(ξτ),\n            Shift(x0, y0)\n        )\n\nDetails\n\nAdds ellipticity to the ring. The radius r0 of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.\n\nr0 = √(a*b).\n\nThe ellipticity τ is given by τ = 1-b/a.\n\nArguments\n\nr0: geometric mean radius (√ab) of the ring\nσ0: standard deviation of the Gaussian ring\nσ : amplitudes of the N order cosine expansion of the ring thickness\nξσ: phase of the N order cosine expansion of the ring thickness\nτ : asymmetry of the ring τ = 1-b/a\nξτ: semi-major axis measured east of north\ns : amplitudes of the M order cosine expansion of the azimuthal brightness\nξs: phase of the M order cosine expansion of the azimuthal brightness\nx0: horizontal location of the ring center\ny0: vertical location of the ring center vertically\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.LogSpiral","page":"API","title":"VLBISkyModels.LogSpiral","text":"struct LogSpiral{T<:Real} <: VLBISkyModels.AbstractImageTemplate\n\nTemplate type for a logarithmic spiral segment\n\nFields\n\nκ:  Unit curvature of the logarithmic spiral\nσ:  thickness of the Gaussian spiral arm\nδϕ:  Azimuthal extent of the spiral arm\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Constant","page":"API","title":"VLBISkyModels.Constant","text":"struct Constant{T} <: VLBISkyModels.AbstractImageTemplate\n\nAn constant template.\n\nDetails\n\nDefines an image that just has constant flux. This is very useful for soaking up low levels of flux in image reconstructions that can bias the results.\n\nSince images or normalized to unity, this means the Constant template has no additional parameters.\n\nFields\n\nscale: Sets the angular scale of the image. This is usually equal to the image FOV\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.GaussDisk","page":"API","title":"VLBISkyModels.GaussDisk","text":"struct GaussDisk{T} <: VLBISkyModels.AbstractImageTemplate\n\nA smoothed disk model\n\nDetails\n\nDefines a template for an image that has a smoothed disk model.\n\nFields\n\nα: Disk edge standard deviation\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ContinuousImage","page":"API","title":"VLBISkyModels.ContinuousImage","text":"ContinuousImage{A<:IntensityMap, P} <: AbstractModel\nContinuousImage(img::Intensitymap, kernel)\n\nThe basic continuous image model for VLBISkyModels. This expects a IntensityMap style object as its imag as well as a image kernel or pulse that allows you to evaluate the image at any image and visibility location. The image model is\n\nI(x,y) = ∑ᵢ Iᵢⱼ κ(x-xᵢ, y-yᵢ)\n\nwhere Iᵢⱼ are the flux densities of the image img and κ is the intensity function for the kernel.\n\n\n\n\n\n","category":"type"},{"location":"api/#Image-Pulses","page":"API","title":"Image Pulses","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.Pulse\nVLBISkyModels.DeltaPulse\nVLBISkyModels.BSplinePulse\nVLBISkyModels.RaisedCosinePulse\nVLBISkyModels.BicubicPulse\nVLBISkyModels.Butterworth","category":"page"},{"location":"api/#VLBISkyModels.Pulse","page":"API","title":"VLBISkyModels.Pulse","text":"Pulse\n\nPixel response function for a radio image model. This makes a discrete sampling continuous by picking a certain smoothing kernel for the image.\n\nNotes\n\nTo see the implemented Pulses please use the subtypes function i.e. subtypes(Pulse)\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.DeltaPulse","page":"API","title":"VLBISkyModels.DeltaPulse","text":"struct DeltaPulse{T} <: VLBISkyModels.Pulse\n\nA dirac comb pulse function. This means the image is just the dicrete Fourier transform\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.BSplinePulse","page":"API","title":"VLBISkyModels.BSplinePulse","text":"$(TYPEDEF)\n\nUses the basis spline (BSpline) kernel of order N. These are the kernel that come from recursively convolving the tophat kernel\n\n    B_0(x) = begincases 1  x  1  0  otherwise endcases\n\nN times.\n\nNotes\n\nBSpline kernels have a number of nice properties:\n\nSimple frequency response sinc(u2)^N\npreserve total intensity\n\nFor N>1 these kernels aren't actually interpolation kernels however, this doesn't matter for us.\n\nCurrently only the 0,1,3 order kernels are implemented.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.RaisedCosinePulse","page":"API","title":"VLBISkyModels.RaisedCosinePulse","text":"struct RaisedCosinePulse{T} <: VLBISkyModels.Pulse\n\nRaisedCosinePulse()\nRaisedCosinePulse(rolloff)\n\nRaised cosine pulse function. This tends to be a very flat response, where the roll off controls the speed of decay. By default we set rolloff = 0.5.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.BicubicPulse","page":"API","title":"VLBISkyModels.BicubicPulse","text":"struct BicubicPulse{T} <: VLBISkyModels.Pulse\n\nBicubicPulse(b = 0.5)\n\nThe bicubic pulse for imaging. This pulse tends to have a flat spectrum but for most values of b can produce negative intensities in an image. This is the pulse used in Broderick et al. 2020.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Butterworth","page":"API","title":"VLBISkyModels.Butterworth","text":"Butterworth{N}()\nButterworth{N, T}()\n\nConstruct a model that corresponds to the Butterworth filter of order N. The type of the output is given by T and if not given defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#Fourier-Duality-Models","page":"API","title":"Fourier Duality Models","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.FourierDualDomain\nVLBISkyModels.xygrid\nVLBISkyModels.uvgrid\nVLBISkyModels.uviterator\nVLBISkyModels.DFTAlg\nVLBISkyModels.FFTAlg\nVLBISkyModels.NFFTAlg\nVLBISkyModels.InterpolatedModel","category":"page"},{"location":"api/#VLBISkyModels.FourierDualDomain","page":"API","title":"VLBISkyModels.FourierDualDomain","text":"FourierDualDomain(imgdomain::AbstractSingleDomain, visdomain::AbstractSingleDomain, algorithm)\n\nConstructs a set of grids that live in the image and visibility domains. The transformation between the grids is specified by the algorithm which is a subtype of VLBISkyModels.FourierTransform.\n\nArguments\n\nimgdomain: The image domain grid\nvisdomain: The visibility domain grid\nalgorithm: The Fourier transform algorithm to use see subtypes(VLBISkyModels.FourierTransform) for a list\n\n\n\n\n\nFourierDualDomain(imgdomain::AbstractRectiGrid, alg::FFTAlg)\n\nConstructs a FourierDualDomain that uses the FFT algorithm to compute the transformation. For this no visibilty domain is specified since we assume it is the default grid from the FFT with padding specified in FFTAlg.\n\nArguments\n\nimgdomain: The image domain grid\nalg: The FFT algorithm to use\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.xygrid","page":"API","title":"VLBISkyModels.xygrid","text":"xygrid(grid::AbstractRectiGrid)\n\nConverts from a visi1bility domain recti-grid with spatial dimensions (U,V) to a image domain grid with spatial dimensions (X,Y). Note the other dimensions are not changed.\n\nFor the inverse see uvgrid\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.uvgrid","page":"API","title":"VLBISkyModels.uvgrid","text":"uvgrid(grid::AbstractRectiGrid)\n\nConverts from a image domain recti-grid with spatial dimension (X,Y) to a Fourier or visibility domain grid with spatial dimensions (U,V). Note the other dimensions are not changed.\n\nFor the inverse see xygrid\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.uviterator","page":"API","title":"VLBISkyModels.uviterator","text":"uviterator(nx, dx, ny dy)\n\nConstruct the u,v iterators for the Fourier transform of the image with pixel sizes dx, dy and number of pixels nx, ny\n\nIf you are extending Fourier transform stuff please use these functions to ensure that the centroid is being properly computed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.DFTAlg","page":"API","title":"VLBISkyModels.DFTAlg","text":"DFTAlg\n\nUses a discrete fourier transform. This is not very efficient for larger images. In those cases  NFFTAlg or FFTAlg are more reasonable. For small images this is a reasonable choice especially since it's easy to define derivatives.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.FFTAlg","page":"API","title":"VLBISkyModels.FFTAlg","text":"struct FFTAlg{T} <: VLBISkyModels.FourierTransform\n\nUse an FFT to compute the approximate numerical visibilitymap of a model. For a DTFT see DFTAlg or for an NFFT NFFTAlg\n\nFields\n\npadfac: The amount to pad the image by. Note we actually round up to use small prime factor.\n\nflags: FFTW flags or wisdom for the transformation. The default is FFTW.ESTIMATE, but you can use FFTW.MEASURE for better performance if you plan on evaluating the sample FFT multiple times.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.NFFTAlg","page":"API","title":"VLBISkyModels.NFFTAlg","text":"NFFTAlg\n\nUses a non-uniform FFT to compute the visibilitymap. You can optionally pass uv which are the uv positions you will compute the NFFT at. This can allow for the NFFT plan to be cached improving performance\n\nFields\n\npadfac: Amount to pad the image\n\nm: Kernel size parameters. This controls the accuracy of NFFT you do not usually need to change this\n\nσ: Over sampling factor. This controls the accuracy of NFFT you do not usually need to change this.\n\nwindow: Window function for the NFFT. You do not usually need to change this\n\nprecompute: NFFT interpolation algorithm.\n\nblocking: Flag block partioning should be used to speed up computation\n\nsortNodes: Flag if the node should be sorted in a lexicographic way\n\nstoreDeconvolutionIdx: Flag if the deconvolve indices should be stored, Currently required for GPU\n\nfftflags: Flag passed to inner AbstractFFT. The fastest FFTW is FFTW.MEASURE but takes the longest to precompute\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.InterpolatedModel","page":"API","title":"VLBISkyModels.InterpolatedModel","text":"InterpolatedModel(model, grid; algorithm)\n\n\nComputes an representation of the model in the Fourier domain using interpolations and FFTs. This is useful to construct models that aren't directly representable in the Fourier domain.\n\nNote\n\nThis is mostly used for testing and debugging purposes. In general people should use the FourierDualDomain functionality to compute the Fourier transform of a model.\n\n\n\n\n\n","category":"type"},{"location":"api/#Modifiers","page":"API","title":"Modifiers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.modify\nVLBISkyModels.basemodel\nVLBISkyModels.unmodified\nVLBISkyModels.renormed\nVLBISkyModels.rotated\nVLBISkyModels.posangle\nVLBISkyModels.shifted\nVLBISkyModels.stretched\nVLBISkyModels.ModifiedModel\nVLBISkyModels.ModelModifier\nVLBISkyModels.Stretch\nVLBISkyModels.Shift\nVLBISkyModels.Rotate\nVLBISkyModels.Renormalize","category":"page"},{"location":"api/#VLBISkyModels.modify","page":"API","title":"VLBISkyModels.modify","text":"modify(m::AbstractModel, transforms...)\n\nModify a given model using the set of transforms. This is the most general function that allows you to apply a sequence of model transformation for example\n\nmodify(Gaussian(), Stretch(2.0, 1.0), Rotate(π/4), Shift(1.0, 2.0), Renorm(2.0))\n\nwill create a asymmetric Gaussian with position angle π/4 shifted to the position (1.0, 2.0) with a flux of 2 Jy. This is similar to Flux's chain.\n\n\n\n\n\nmodify(img::IntensityMap, transforms...)\n\nThis modifies the img by applying the transforms... returning a transformed IntensityMap\n\nnote: Note\n\n\nUnlike when modify is applied to a <:AbstractModel this returns an already modified image.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.basemodel","page":"API","title":"VLBISkyModels.basemodel","text":"basemodel(model::ModifiedModel)\n\nReturns the ModifiedModel with the last transformation stripped.\n\nExample\n\njulia> basemodel(stretched(Disk(), 1.0, 2.0)) == Disk()\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.unmodified","page":"API","title":"VLBISkyModels.unmodified","text":"unmodified(model::ModifiedModel)\n\nReturns the un-modified model\n\nExample\n\njulia> m = stretched(rotated(Gaussian(), π/4), 2.0, 1.0)\njulia> umodified(m) == Gaussian()\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.renormed","page":"API","title":"VLBISkyModels.renormed","text":"renormed(model, f)\n\n\nRenormalizes the model m to have total flux f*flux(m). This can also be done directly by calling Base.:* i.e.,\n\njulia> renormed(m, f) == f*M\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.rotated","page":"API","title":"VLBISkyModels.rotated","text":"rotated(model, ξ)\n\n\nRotates the model by an amount ξ in radians in the clockwise direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.posangle","page":"API","title":"VLBISkyModels.posangle","text":"posangle(model)\n\n\nReturns the rotation angle of the rotated model\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.shifted","page":"API","title":"VLBISkyModels.shifted","text":"shifted(model, Δx, Δy)\n\n\nShifts the model m in the image domain by an amount Δx,Δy in the x and y directions respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.stretched","page":"API","title":"VLBISkyModels.stretched","text":"stretched(model, α, β)\n\n\nStretches the model m according to the formula     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.ModifiedModel","page":"API","title":"VLBISkyModels.ModifiedModel","text":"struct ModifiedModel{M, MT<:Tuple} <: ComradeBase.AbstractModel\n\nContainer type for models that have been transformed in some way. For a list of potential modifiers or transforms see subtypes(ModelModifiers).\n\nFields\n\nmodel: base model\ntransform: model transforms\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ModelModifier","page":"API","title":"VLBISkyModels.ModelModifier","text":"abstract type ModelModifier{T}\n\nGeneral type for a model modifier. These transform any model using simple Fourier transform properties. To modify a model you can use the ModifiedModel constructor or the modify function.\n\njulia> visanalytic(stretched(Disk(), 2.0, 2.0)) == visanalytic(Disk())\ntrue\n\nTo implement a model transform you need to specify the following methods:\n\ntransform_uv\ntransform_image\nscale_uv\nscale_image\nradialextent\n\nSee thee docstrings of those methods for guidance on implementation details.\n\nAdditionally these methods assume the modifiers are of the form\n\nI(x,y) -> fᵢ(x,y)I(gᵢ(x,y)) V(u,v) -> fᵥ(u,v)V(gᵥ(u,v))\n\nwhere g are the transformimage/uv functions and f are the scaleimage/uv function.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Stretch","page":"API","title":"VLBISkyModels.Stretch","text":"Stretch(α, β)\nStretch(r)\n\nStretched the model in the x and y directions, i.e. the new intensity is     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.\n\nExample\n\njulia> modify(Gaussian(), Stretch(2.0)) == stretched(Gaussian(), 2.0, 1.0)\ntrue\n\nIf only a single argument is given it assumes the same stretch is applied in both direction.\n\njulia> Stretch(2.0) == Stretch(2.0, 2.0)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Shift","page":"API","title":"VLBISkyModels.Shift","text":"struct Shift{T} <: VLBISkyModels.ModelModifier{T}\n\nShifts the model by Δx units in the x-direction and Δy units in the y-direction.\n\nExample\n\njulia> modify(Gaussian(), Shift(2.0, 1.0)) == shifted(Gaussian(), 2.0, 1.0)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Rotate","page":"API","title":"VLBISkyModels.Rotate","text":"Rotate(ξ)\n\nType for the rotated model. This is more fine grained constrol of rotated model.\n\nExample\n\njulia> modify(Gaussian(), Rotate(2.0)) == rotated(Gaussian(), 2.0)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Renormalize","page":"API","title":"VLBISkyModels.Renormalize","text":"struct Renormalize{T} <: VLBISkyModels.ModelModifier{T}\n\nRenormalizes the flux of the model to the new value scale*flux(model). We have also overloaded the Base.:* operator as syntactic sugar although I may get rid of this.\n\nExample\n\njulia> modify(Gaussian(), Renormalize(2.0)) == 2.0*Gaussian()\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#Model-Evaluation","page":"API","title":"Model Evaluation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"For more docstrings on how to evaluate models see Base API.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Visualization","page":"API","title":"Visualization","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.imageviz\nVLBISkyModels.polimage","category":"page"},{"location":"api/#VLBISkyModels.imageviz","page":"API","title":"VLBISkyModels.imageviz","text":"imageviz(img::IntensityMap; scale_length = fieldofview(img.X/4), kwargs...)\n\nA default image visualization for a IntensityMap.\n\nIf eltype(img) <: Real i.e. an image of a single stokes parameter this will plot the image with a colorbar in units of Jy/μas². The plot will accept any kwargs that are a supported by the Makie.Image type an can be queried by typing ?image in the REPL\n\nIf eltype(img) <: StokesParams i.e. full polarized image this will use polimage. The plot will accept any kwargs that are a supported by the PolImage type an can be queried by typing ?polimage in the REPL.\n\ntip: Tip\nTo customize the image, i.e. specify a specific axis we recommend to use image and polimage directly.\n\nwarn: Warn\nTo load this function definition you need to import CairoMakie first\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.polimage","page":"API","title":"VLBISkyModels.polimage","text":"polimage(img::IntensityMap{<:StokesParams};\n            colormap = :bone,\n            colorrange = Makie.automatic,\n            pcolorrange=Makie.automatic,\n            pcolormap=Reverse(:jet1),\n            nvec = 30,\n            min_frac = 0.1,\n            min_pol_frac=0.2,\n            length_norm=1.0,\n            plot_total=true)\n\nPlot a polarized intensity map using the image img.\n\nThe plot follows the conventions from EHTC M87 Paper VII.\n\nThe stokes I image will be plotted with the attributes\n\ncolormap\ncolorrange\nalpha\ncolorscale\n\nThe polarized image will consist of a set. The attribute plot_total changes what polarized quantities are considered.\n\nIf plot_total = true\n\nThe total polarization will be considered and the markers will be given by ellipses.\nThe orientation of the ellipse is equal to the EVPA.\nThe area of the ellipse is proportional to |V|².\nThe semi-major axis is related to the total polarized intensity times the length_norm.\nThe color of the ellipse is given by the fractional total polarization times the\n\nsign of Stokes V.\n\nIf plot_total = false\n\nOnly the linear polarization is considered and the markers will be ticks.\nThe orientation of the ticks is equal to the EVPA.\nThe length of the ticks is equal to the total linear polarized intensity, i.e. √(Q² + U²) times the length_norm.\nThe color of the tick is given by the fractional linear polarization.\n\nAttributes\n\ncolormap: The colormap of the stokes I image. The default is :bone.\ncolorrange: The color range of the stokes I image. The default is (0, maximum(stokes(img, :I)))\npcolorrange: The color range for the polarized image\npcolormap: The colormap used for fractional total/linear polarization markers.\nnvec: The number of polarization vectors to plot\nmin_frac: Any markers with I < min_frac*maximum(I)) will not be plotted\nmin_pol_frac: Any markers with P < min_frac*maximum(P)) where P is the total/linear polarization flux             will not be plotted.\nlength_norm: Specifies the normalization used for the ticks. The default is that the pixel                 with the largest polarization intensity will have a tick length = 10x the                 pixel separation. For an image with a maximum polarized intensity of 10Jy/μas²                 and pixel spacing of 1μas the marker length will be equal to 10μas.\nplot_total: If true plot the total polarization. If false only plot the linear polarization.\n\nwarning: Warning\nThe polarized plotting is intrinsically defined using astronomer/EHT polarization conventions This means that in order to have the polarization ticks plotted in a way that makes sense you need to have xreversed=true when defining your axis.\n\n\n\n\n\n","category":"function"},{"location":"api/#Misc.","page":"API","title":"Misc.","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.center_image\nVLBISkyModels.convolve\nVLBISkyModels.convolve!\nVLBISkyModels.smooth\nVLBISkyModels.PoincareSphere2Map\nVLBISkyModels.PolExp2Map\nVLBISkyModels.regrid\nVLBISkyModels.rad2μas\nVLBISkyModels.μas2rad","category":"page"},{"location":"api/#VLBISkyModels.center_image","page":"API","title":"VLBISkyModels.center_image","text":"center_image(img::SpatialIntensityMap)\n\ncenters the img such that the centroid of the image is approximately at the origin.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.convolve","page":"API","title":"VLBISkyModels.convolve","text":"convolve(img::IntensityMap, m::AbstractModel)\n\nConvolves an img with a given analytic model m. This is useful for blurring the image with some model. For instance to convolve a image with a Gaussian you would do\n\nconvolve(img, Gaussian())\n\nFor the inplace version of the function see convolve!\n\nNotes\n\nThis method does not automatically pad your image. If there is substantial flux at the boundaries you will start to see artifacts.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.convolve!","page":"API","title":"VLBISkyModels.convolve!","text":"convolve!(img::IntensityMap, m::AbstractModel)\n\nConvolves an img with a given analytic model m. This is useful for blurring the image with some model. For instance to convolve a image with a Gaussian you would do\n\nconvolve!(img, Gaussian())\n\nNotes\n\nThis method does not automatically pad your image. If there is substantial flux at the boundaries you will start to see artifacts.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.smooth","page":"API","title":"VLBISkyModels.smooth","text":"smooth(img::SpatialIntensityMap)\n\nSmooths the img using a symmetric Gaussian with σ standard deviation.\n\nFor more flexible convolution please see convolve.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.PoincareSphere2Map","page":"API","title":"VLBISkyModels.PoincareSphere2Map","text":"PoincareSphere2Map(I, p, X, grid)\nPoincareSphere2Map(I::IntensityMap, p, X)\nPoincareSphere2Map(I, p, X, cache::AbstractCache)\n\nConstructs an polarized intensity map model using the Poincare parameterization. The arguments are:\n\nI is a grid of fluxes for each pixel.\np is a grid of numbers between 0, 1 and the represent the total fractional polarization\nX is a grid, where each element is 3 numbers that represents the point on the Poincare sphere that is, X[1,1] is a NTuple{3} such that ||X[1,1]|| == 1.\ngrid is the dimensional grid that gives the pixels locations of the intensity map.\n\nnote: Note\nIf I is an IntensityMap then grid is not required since the same grid that was use for I will be used to construct the polarized intensity map. If a cache is passed instead this will return a ContinuousImage object.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.PolExp2Map","page":"API","title":"VLBISkyModels.PolExp2Map","text":"PolExp2Map(a, b, c, d, grid::AbstractRectiGrid)\n\nConstructs an polarized intensity map model using the matrix exponential representation from Arras 2021 (Thesis).\n\nEach Stokes parameter is parameterized as\n\nI = exp(a)cosh(p)\nQ = exp(a)sinh(p)b/p\nU = exp(a)sinh(p)c/p\nV = exp(a)sinh(p)d/p\n\nwhere a,b,c,d are real numbers with no conditions, and p=√(a² + b² + c²).\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.regrid","page":"API","title":"VLBISkyModels.regrid","text":"regrid(img, g)\n\n\nRegrids the spatial parts of an image img on the new domain g\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.rad2μas","page":"API","title":"VLBISkyModels.rad2μas","text":"rad2μas(x)\n\nConverts a number from radians to micro-arcseconds (μas)\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.μas2rad","page":"API","title":"VLBISkyModels.μas2rad","text":"μas2rad(x)\n\nConverts a number from micro-arcseconds (μas) to rad\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-(Not-Public-API)","page":"API","title":"Internal (Not Public API)","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.AbstractFourierDualDomain\nVLBISkyModels.scale_uv\nVLBISkyModels.scale_image\nVLBISkyModels.transform_uv\nVLBISkyModels.transform_image\nVLBISkyModels.unpack\nVLBISkyModels.StokesIntensityMap\nVLBISkyModels.FFTPlan\nVLBISkyModels.NUFTPlan","category":"page"},{"location":"api/#VLBISkyModels.AbstractFourierDualDomain","page":"API","title":"VLBISkyModels.AbstractFourierDualDomain","text":"abstract type AbstractFourierDualDomain <: ComradeBase.AbstractDomain\n\nThis defines an abstract cache that can be used to hold or precompute some computations.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.scale_uv","page":"API","title":"VLBISkyModels.scale_uv","text":"scale_image(model::AbstractModifier, u, u)\n\nReturns a number on how to scale the image visibility at u v for an modified model\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.scale_image","page":"API","title":"VLBISkyModels.scale_image","text":"scale_image(model::AbstractModifier, x, y)\n\nReturns a number of how to to scale the image intensity at x y for an modified model\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.transform_uv","page":"API","title":"VLBISkyModels.transform_uv","text":"transform_uv(model::AbstractModifier, u, u)\n\nReturns a transformed u and v according to the model modifier\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.transform_image","page":"API","title":"VLBISkyModels.transform_image","text":"transform_image(model::AbstractModifier, x, y)\n\nReturns a transformed x and y according to the model modifier\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.unpack","page":"API","title":"VLBISkyModels.unpack","text":"unpack(m::AbstractModel)\n\nUnpacks all elements of a struct into a named tuple. Note that this may include elements that aren't direcltly model parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.StokesIntensityMap","page":"API","title":"VLBISkyModels.StokesIntensityMap","text":"struct StokesIntensityMap{T, N, SI, SQ, SU, SV}\n\nGeneral struct that holds intensity maps for each stokes parameter. Each image I, Q, U, V must share the same axis dimensions. This type also obeys much of the usual array interface in Julia. The following methods have been implemented:\n\nsize\neltype (returns StokesParams)\nndims\ngetindex\nsetindex!\npixelsizes\nfieldofview\nimagepixels\ndomainpoints\nstokes\n\nwarning: Warning\nThis may eventually be phased out for IntensityMaps whose base types are StokesParams, but currently we use this for speed reasons with Zygote.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.FFTPlan","page":"API","title":"VLBISkyModels.FFTPlan","text":"struct FFTPlan{A<:FFTAlg, P} <: VLBISkyModels.AbstractPlan\n\nThe cache used when the FFT algorithm is used to compute visibilties. This is an internal type and is not part of the public API\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.NUFTPlan","page":"API","title":"VLBISkyModels.NUFTPlan","text":"struct NUFTPlan{A, P, M} <: VLBISkyModels.AbstractNUFTPlan\n\nInternal type used to store the cache for a non-uniform Fourier transform (NUFT).\n\nThe user should instead create this using the FourierDualDomain function.\n\n\n\n\n\n","category":"type"},{"location":"interface/#Model-Interface","page":"Model Interface","title":"Model Interface","text":"","category":"section"},{"location":"interface/#Primitive-Geometric-Models","page":"Model Interface","title":"Primitive Geometric Models","text":"","category":"section"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"VLBISkyModels aims to be more modular and extensible than previous VLBI modeling packages. Namely, simple models are composed to construct complicated source morphologies instead of making many different models. This is accomplished with a type and trait-based hierarchy.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Additionally, ComradeBase is a low-dependency version of this package that defines this type and trait hierarchy that users can more easily incorporate into their packages.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"To see how this works, we will go through a simplified implementation of the Gaussian model in VLBISkyModels. The Gaussian model is a simple, compact emission structure model that can constrain the typical characteristic size of an image feature from VLBI data. To construct a Gaussian model, we will first define a struct:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"struct MyGaussian <: VLBISkyModels.AbstractModel end","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Notice that we don't provide any more information about the model, e.g., size, shape, flux, etc. This is because we will use VLBISkyModels's extensive set of modifiers to change the structure of the model. Now a Gaussian is the simplest model structure we can consider. We can consider this Gaussian to be a primitive model. That means a Gaussian is not a combination or modification of an existing model. To tell VLBISkyModels that this is the case, we define the following method:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Now a Gaussian has an analytic expression in the image and Fourier domain. We can tell VLBISkyModels this by setting:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"# Fourier and image domains are analytic\nVLBISkyModels.visanalytic(::Type{<:MyGaussian}) = IsAnalytic()\nVLBISkyModels.imanalytic(::Type{<:MyGaussian}) = IsAnalytic()","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Finally, we can specify if the model is intrinsically polarized by using the IsPolarized and NotPolarized() trait","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"VLBISkyModels.ispolarized(::Type{<:MyGaussian}) = NotPolarized()","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"note: Note\nThe actual implementation defines the Gaussian to be a subtype of VLBISkyModels.GeometricModel, which automatically defines these methods. However, for models that aren't a subtype of GeometricModel, we assume the image domain IsAnalytic() and the Fourier domain is NotAnalytic().","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Since both the image and visibility domain representation of the Gaussian are analytic, we need to define an intensity_point and visibility_point method. For a Gaussian, these are given by","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"function ComradeBase.intensity_point(::MyGaussian, p)\n    (;X, Y) = p\n    return exp(-(X^2+Y^2)/2)/2π\nend\n\nfunction ComradeBase.visibility_point(::MyGaussian, u, v, time, freq) where {T}\n    return exp(-2π^2*(u^2 + v^2)) + 0im\nend","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Additionally, most models in VLBISkyModels has two additional functions one can implement if possible:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"flux(m::MyGaussian): This defines the flux of a model. If this isn't defined, the model won't have a flux until an image is created. For a Gaussian, the definition is flux(::MyGaussian) = 1.0.\nradialextent(::MyGaussian): This defines the model's default radial extent. For a Gaussian, we will consider the radial extent to be 5σ, so radialextent(::MyGaussian) = 5.0.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"This completely defines the model interface for VLBISkyModels. With this, you can call the usual user API to evaluate, fit, and plot the model. Additionally, we can start talking about adding multiple Gaussians and modifying them. For instance, suppose you want an elliptical Gaussian with a flux of 2 Jy. This can be created by VLBISkyModels as follows:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"using Plots\ngauss = MyGaussian()\nellgauss = 2.0*rotated(stretched(gauss, 1.0, 0.5), π/4)\nfig = plot(gauss, layout=(1,2), size=(800,300))\nplot!(fig[2], ellgauss, size=(800,350))","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"(Image: Image)","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"using Plots\nu = rand(100)*0.5; v=rand(100)*0.5\nvg  = visibilitymap(gauss, u, v)\nveg = visibilitymap(ellgauss, u, v)\n\nPlots.scatter(hypot.(u, v), abs.(vg), label=\"Gaussian\")\nPlots.scatter!(hypot.(u, v), abs.(veg), label=\"Elliptical Gaussian\")","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"(Image: Image)","category":"page"},{"location":"interface/#Models-without-an-Analytic-Fourier-Transform","page":"Model Interface","title":"Models without an Analytic Fourier Transform","text":"","category":"section"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"EditURL = \"../../../examples/nonanalytic.jl\"","category":"page"},{"location":"examples/nonanalytic/#Modeling-with-non-analytic-Fourier-transforms","page":"nonanalytic","title":"Modeling with non-analytic Fourier transforms","text":"","category":"section"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"using VLBISkyModels\n\nusing Pkg #hide\nPkg.activate(joinpath(dirname(pathof(VLBISkyModels)), \"..\", \"examples\")) #hide\n\nusing CairoMakie","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"While most of the models implemented in VLBISkyModels have an analytic Fourier transform this is not required. In this notebook we will describe how a user can do Bayesian model fitting with a non-analytic model.","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"The ExtendedRing model is an example of a non-analytic model. The image structure is given by","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"I(r) = fracbeta^alpha2pi Gamma(alpha) r^-alpha-2e^-betar","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"This can be created as follows","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"m = ExtendedRing(8.0)","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"The argument is \\alpha in the above equation. beta is given by (1+alpha).","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"This model does not have a simple analytic Fourier transform, e.g.","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"VLBISkyModels.visanalytic(ExtendedRing)","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"Therefore, to find the Fourier transform of the image we need to revert to numerical methods. For this notebook we will use the fast Fourier transform or FFT. Specifically we will use FFTW. To compute a numerical Fourier transform we first need to specify the image domain","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"gim = imagepixels(10.0, 10.0, 256, 256)","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"Second we need to specify the list of points in the uv domain we are interested in. Since VLBI tends sparsely sample the UV plan we provide a specific type for this type called UnstructuredDomain that can be used to specify the UV points,","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"u = randn(1000)/2\nv = randn(1000)/2\nguv = UnstructuredDomain((U=u, V=v))","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"We can now create a dual domain that contains both the image and the UV points and the specific Fourier transform algorithm we want to use. The options for algorithms are:","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"NFFTAlg: Uses the Non-Uniform Fast Fourier Transform. Fast and accurate, this is the recommended algorithm for most cases.\nDFTAlg: Uses the Discrete Time Non-Uniform Fourier transform. Slow but exact, so only use for small image grids.\nFFTAlg: Moderately fast and moderately accurate. Typically only used internally for testing.","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"For this example we will use NFFTAlg since it is the recommended algorithm for most cases.","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"gfour = FourierDualDomain(gim, guv, NFFTAlg())","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"Given this FourierDualDomain everything now works as before with analytic models. For example we can compute the intensitymap of the model as","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"img = intensitymap(m, gfour)\nimageviz(img)","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"and the visibility map using","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"vis = visibilitymap(m, gfour)\nfig, ax = scatter(hypot.(vis.U, vis.V), real.(vis), label=\"Real\")\nscatter!(ax, hypot.(vis.U, vis.V), imag.(vis), label=\"Imag\")\naxislegend(ax)\nax.xlabel = \"uv-dist\"\nax.ylabel = \"Flux\"\nfig","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"Additionally, you can also modify the models and add them in complete generality. For example","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"mmod = modify(m, Shift(2.0, 2.0)) + Gaussian()\nmimg = intensitymap(mmod, gfour)\nmvis = visibilitymap(mmod, gfour)","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"Plotting everything gives","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"fig = Figure(;size=(800, 400))\nax1 = Axis(fig[1, 1]; xreversed=true, xlabel=\"RA (radians)\", ylabel=\"Dec (radians)\", aspect=1)\nax2 = Axis(fig[1, 2]; xlabel=\"uv-dist\", ylabel=\"Amplitude\")\nimage!(ax1, mimg, colormap=:afmhot)\nscatter!(ax2, hypot.(mvis.U, mvis.V), abs.(mvis), label=\"Real\")\nfig","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"","category":"page"},{"location":"examples/nonanalytic/","page":"nonanalytic","title":"nonanalytic","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = VLBISkyModels","category":"page"},{"location":"#VLBISkyModels","page":"Home","title":"VLBISkyModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"VLBISkyModels provides an interface and library for of models that can be used to describe the on-sky emission seen by VLBI interferometers. This used to live in the Bayesian VLBI modeling package Comrade.jl but has been recently separated for modularity within the Julia VLBI community. To see how to use VLBISkyModels within Comrade see the their docs.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This repository has tries to follow ColPrac. If you would like to contribute please feel free to open a issue or pull-request.","category":"page"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The minimum Julia version we require is 1.7. In the future we may increase this as Julia advances.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"interface.md\",\n    \"api.md\",\n    \"nonanalytic\"\n]","category":"page"}]
}
