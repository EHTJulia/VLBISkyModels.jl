var documenterSearchIndex = {"docs":
[{"location":"base_api/#Base-API","page":"Base API","title":"Base API","text":"","category":"section"},{"location":"base_api/#Contents","page":"Base API","title":"Contents","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"Pages = [\"base_api.md\"]","category":"page"},{"location":"base_api/#Index","page":"Base API","title":"Index","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"Pages = [\"base_api.md\"]","category":"page"},{"location":"base_api/","page":"Base API","title":"Base API","text":"CurrentModule = ComradeBase","category":"page"},{"location":"base_api/#Model-API","page":"Base API","title":"Model API","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"ComradeBase.flux\nComradeBase.visibility\nComradeBase.visibilities\nComradeBase.visibilities!\nComradeBase.intensitymap\nComradeBase.intensitymap!\nComradeBase.IntensityMap\nComradeBase.amplitude(::Any, ::Any)\nComradeBase.amplitudes\nComradeBase.bispectrum\nComradeBase.bispectra\nComradeBase.closure_phase\nComradeBase.closure_phases\nComradeBase.logclosure_amplitude\nComradeBase.logclosure_amplitudes\nPolarizedTypes.mpol(::ComradeBase.AbstractPolarizedModel, ::Any)\nPolarizedTypes.polellipse(::ComradeBase.AbstractPolarizedModel, ::Any)\nPolarizedTypes.polarization(::ComradeBase.AbstractPolarizedModel, ::Any)\nPolarizedTypes.fracpolarization(::ComradeBase.AbstractPolarizedModel, ::Any)\nPolarizedTypes.mbreve(::ComradeBase.AbstractPolarizedModel, ::Any)","category":"page"},{"location":"base_api/#ComradeBase.flux","page":"Base API","title":"ComradeBase.flux","text":"flux(im::IntensityMap)\nflux(img::StokesIntensityMap)\n\nComputes the flux of a intensity map\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibility","page":"Base API","title":"ComradeBase.visibility","text":"visibility(mimg, p)\n\nComputes the complex visibility of model m at coordinates p. p corresponds to the coordinates of the model. These need to have the properties U, V and sometimes Ti for time and Fr for frequency.\n\nNotes\n\nIf you want to compute the visibilities at a large number of positions consider using the visibilities.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilities","page":"Base API","title":"ComradeBase.visibilities","text":"visibilities(model::AbstractModel, args...)\n\nComputes the complex visibilities at the locations given by args...\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilities!","page":"Base API","title":"ComradeBase.visibilities!","text":"visibilities!(vis::AbstractArray, model::AbstractModel, args...)\n\nComputes the complex visibilities vis in place at the locations given by args...\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap","page":"Base API","title":"ComradeBase.intensitymap","text":"intensitymap(model::AbstractModel, p::AbstractDims)\n\nComputes the intensity map of model. For the inplace version see intensitymap!\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap!","page":"Base API","title":"ComradeBase.intensitymap!","text":"intensitymap!(buffer::AbstractDimArray, model::AbstractModel)\n\nComputes the intensity map of model by modifying the buffer\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.IntensityMap","page":"Base API","title":"ComradeBase.IntensityMap","text":"IntensityMap(data::AbstractArray, dims::NamedTuple)\nIntensityMap(data::AbstractArray, grid::AbstractDims)\n\nConstructs an intensitymap using the image dimensions given by dims. This returns a KeyedArray with keys given by an ImageDimensions object.\n\ndims = (X=range(-10.0, 10.0, length=100), Y = range(-10.0, 10.0, length=100),\n        T = [0.1, 0.2, 0.5, 0.9, 1.0], F = [230e9, 345e9]\n        )\nimgk = IntensityMap(rand(100,100,5,1), dims)\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.amplitude-Tuple{Any, Any}","page":"Base API","title":"ComradeBase.amplitude","text":"amplitude(model, p)\n\nComputes the visibility amplitude of model m at the coordinate p. The coordinate p is expected to have the properties U, V, and sometimes Ti and Fr.\n\nIf you want to compute the amplitudes at a large number of positions consider using the amplitudes function.\n\n\n\n\n\n","category":"method"},{"location":"base_api/#ComradeBase.amplitudes","page":"Base API","title":"ComradeBase.amplitudes","text":"amplitudes(m::AbstractModel, u::AbstractArray, v::AbstractArray)\n\nComputes the visibility amplitudes of the model m at the coordinates p. The coordinates p are expected to have the properties U, V, and sometimes Ti and Fr.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.bispectrum","page":"Base API","title":"ComradeBase.bispectrum","text":"bispectrum(model, p1, p2, p3)\n\nComputes the complex bispectrum of model m at the uv-triangle p1 -> p2 -> p3\n\nIf you want to compute the bispectrum over a number of triangles consider using the bispectra function.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.bispectra","page":"Base API","title":"ComradeBase.bispectra","text":"bispectra(m, p1, p2, p3)\n\nComputes the closure phases of the model m at the triangles p1, p2, p3, where pi are coordinates.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.closure_phase","page":"Base API","title":"ComradeBase.closure_phase","text":"closure_phase(model, p1, p2, p3, p4)\n\nComputes the closure phase of model m at the uv-triangle u1,v1 -> u2,v2 -> u3,v3\n\nIf you want to compute closure phases over a number of triangles consider using the closure_phases function.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.closure_phases","page":"Base API","title":"ComradeBase.closure_phases","text":"closure_phases(m,\n               p1::AbstractArray\n               p2::AbstractArray\n               p3::AbstractArray\n               )\n\nComputes the closure phases of the model m at the triangles p1, p2, p3, where pi are coordinates.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.logclosure_amplitude","page":"Base API","title":"ComradeBase.logclosure_amplitude","text":"logclosure_amplitude(model, p1, p2, p3, p4)\n\nComputes the log-closure amplitude of model m at the uv-quadrangle u1,v1 -> u2,v2 -> u3,v3 -> u4,v4 using the formula\n\nC = logleftfracV(u1v1)V(u2v2)V(u3v3)V(u4v4)right\n\nIf you want to compute log closure amplitudes over a number of triangles consider using the logclosure_amplitudes function.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.logclosure_amplitudes","page":"Base API","title":"ComradeBase.logclosure_amplitudes","text":"logclosure_amplitudes(m::AbstractModel,\n                      p1,\n                      p2,\n                      p3,\n                      p4\n                     )\n\nComputes the log closure amplitudes of the model m at the quadrangles p1, p2, p3, p4.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#PolarizedTypes.mpol-Tuple{ComradeBase.AbstractPolarizedModel, Any}","page":"Base API","title":"PolarizedTypes.mpol","text":"mpol(pimg::AbstractPolarizedModel, p)\n\nReturn the fractional linear polarization of the model m at point p.\n\n\n\n\n\n","category":"method"},{"location":"base_api/#PolarizedTypes.polellipse-Tuple{ComradeBase.AbstractPolarizedModel, Any}","page":"Base API","title":"PolarizedTypes.polellipse","text":"polellipse(pimg::AbstractPolarizedModel, p)\n\nCompute the polarization of the polarized model.\n\n\n\n\n\n","category":"method"},{"location":"base_api/#PolarizedTypes.polarization-Tuple{ComradeBase.AbstractPolarizedModel, Any}","page":"Base API","title":"PolarizedTypes.polarization","text":"polarization(pimg::AbstractPolarizedModel, p)\n\nReturn the polarization vector (Q, U, V) of the model m at point p.\n\n\n\n\n\n","category":"method"},{"location":"base_api/#PolarizedTypes.fracpolarization-Tuple{ComradeBase.AbstractPolarizedModel, Any}","page":"Base API","title":"PolarizedTypes.fracpolarization","text":"fracpolarization(pimg::AbstractPolarizedModel, p)\n\nReturn the fractional polarization vector (Q/I, U/I, V/I) of the model m at point p.\n\n\n\n\n\n","category":"method"},{"location":"base_api/#PolarizedTypes.mbreve-Tuple{ComradeBase.AbstractPolarizedModel, Any}","page":"Base API","title":"PolarizedTypes.mbreve","text":"mbreve(pimg, p)\n\n\nExplicit m̆ function used for convenience.\n\n\n\n\n\n","category":"method"},{"location":"base_api/#Model-Interface","page":"Base API","title":"Model Interface","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"ComradeBase.AbstractModel\nComradeBase.isprimitive\nComradeBase.visanalytic\nComradeBase.imanalytic\nComradeBase.ispolarized\nComradeBase.radialextent\nComradeBase.PrimitiveTrait\nComradeBase.IsPrimitive\nComradeBase.NotPrimitive\nComradeBase.DensityAnalytic\nComradeBase.IsAnalytic\nComradeBase.NotAnalytic\nComradeBase.visibility_point\nComradeBase.visibilities_analytic\nComradeBase.visibilities_analytic!\nComradeBase.visibilities_numeric\nComradeBase.visibilities_numeric!\nComradeBase.intensity_point\nComradeBase.intensitymap_analytic\nComradeBase.intensitymap_analytic!\nComradeBase.intensitymap_numeric\nComradeBase.intensitymap_numeric!","category":"page"},{"location":"base_api/#ComradeBase.AbstractModel","page":"Base API","title":"ComradeBase.AbstractModel","text":"AbstractModel\n\nThe Comrade abstract model type. To instantiate your own model type you should subtybe from this model. Additionally you need to implement the following methods to satify the interface:\n\nMandatory Methods\n\nisprimitive: defines whether a model is standalone or is defined in terms of other models.  is the model is primitive then this should return IsPrimitive() otherwise it returns  NotPrimitive()\nvisanalytic: defines whether the model visibilities can be computed analytically. If yes  then this should return IsAnalytic() and the user must to define visibility_point.  If not analytic then visanalytic should return NotAnalytic().\nimanalytic: defines whether the model intensities can be computed pointwise. If yes   then this should return IsAnalytic() and the user must to define intensity_point.   If not analytic then imanalytic should return NotAnalytic().\nradialextent: Provides a estimate of the radial extent of the model in the image domain.  This is used for estimating the size of the image, and for plotting.\nflux: Returns the total flux of the model.\nintensity_point: Defines how to compute model intensities pointwise. Note this is must be defined if imanalytic(::Type{YourModel})==IsAnalytic().\nvisibility_point: Defines how to compute model visibilties pointwise. Note this is   must be defined if visanalytic(::Type{YourModel})==IsAnalytic().\n\nOptional Methods:\n\nispolarized: Specified whether a model is intrinsically polarized (returns IsPolarized()) or is not (returns NotPolarized()), by default a model is NotPolarized()\nvisibilities_analytic: Vectorized version of visibility_point for models where visanalytic returns IsAnalytic()\nvisibilities_numeric: Vectorized version of visibility_point for models where visanalytic returns NotAnalytic() typically these are numerical FT's\nintensitymap_analytic: Computes the entire image for models where imanalytic returns IsAnalytic()\nintensitymap_numeric: Computes the entire image for models where imanalytic returns NotAnalytic()\nintensitymap_analytic!: Inplace version of intensitymap\nintensitymap_numeric!: Inplace version of intensitymap\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.isprimitive","page":"Base API","title":"ComradeBase.isprimitive","text":"isprimitive(::Type)\n\nDispatch function that specifies whether a type is a primitive Comrade model. This function is used for dispatch purposes when composing models.\n\nNotes\n\nIf a user is specifying their own model primitive model outside of Comrade they need to specify if it is primitive\n\nstruct MyPrimitiveModel end\nComradeBase.isprimitive(::Type{MyModel}) = ComradeBase.IsPrimitive()\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visanalytic","page":"Base API","title":"ComradeBase.visanalytic","text":"visanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in Fourier domain, i.e. we can evaluate its fourier transform at an arbritrary point.\n\nIf IsAnalytic() then it will try to call visibility_point to calculate the complex visibilities. Otherwise it fallback to using the FFT that works for all models that can compute an image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.imanalytic","page":"Base API","title":"ComradeBase.imanalytic","text":"imanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in the image domain, i.e. we can evaluate its intensity at an arbritrary point.\n\nIf IsAnalytic() then it will try to call intensity_point to calculate the intensity.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.ispolarized","page":"Base API","title":"ComradeBase.ispolarized","text":"ispolarized(::Type)\n\nTrait function that defines whether a model is polarized or not.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.radialextent","page":"Base API","title":"ComradeBase.radialextent","text":"radialextent(model::AbstractModel)\n\nProvides an estimate of the radial size/extent of the model. This is used internally to estimate image size when plotting and using modelimage\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.PrimitiveTrait","page":"Base API","title":"ComradeBase.PrimitiveTrait","text":"abstract type PrimitiveTrait\n\nThis trait specifies whether the model is a primitive\n\nNotes\n\nThis will likely turn into a trait in the future so people can inject their models into Comrade more easily.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.IsPrimitive","page":"Base API","title":"ComradeBase.IsPrimitive","text":"struct IsPrimitive\n\nTrait for primitive model\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.NotPrimitive","page":"Base API","title":"ComradeBase.NotPrimitive","text":"struct NotPrimitive\n\nTrait for not-primitive model\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.DensityAnalytic","page":"Base API","title":"ComradeBase.DensityAnalytic","text":"DensityAnalytic\n\nInternal type for specifying the nature of the model functions. Whether they can be easily evaluated pointwise analytic. This is an internal type that may change.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.IsAnalytic","page":"Base API","title":"ComradeBase.IsAnalytic","text":"struct IsAnalytic <: ComradeBase.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has a analytic fourier transform and/or image.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.NotAnalytic","page":"Base API","title":"ComradeBase.NotAnalytic","text":"struct NotAnalytic <: ComradeBase.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has does not have a easy analytic fourier transform and/or intensity function.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.visibility_point","page":"Base API","title":"ComradeBase.visibility_point","text":"visibility_point(model::AbstractModel, p)\n\nFunction that computes the pointwise visibility. This must be implemented in the model interface if visanalytic(::Type{MyModel}) == IsAnalytic()\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilities_analytic","page":"Base API","title":"ComradeBase.visibilities_analytic","text":"visibilties_analytic(model, u, v, time, freq)\n\nComputes the visibilties of a model using using the analytic visibility expression given by visibility_point.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilities_analytic!","page":"Base API","title":"ComradeBase.visibilities_analytic!","text":"visibilties_analytic!(vis, model, u, v, time, freq)\n\nComputes the visibilties of a model in-place, using using the analytic visibility expression given by visibility_point.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilities_numeric","page":"Base API","title":"ComradeBase.visibilities_numeric","text":"visibilties_numeric(model, u, v, time, freq)\n\nComputes the visibilties of a model using a numerical fourier transform. Note that none of these are implemented in ComradeBase. For implementations please see Comrade.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.visibilities_numeric!","page":"Base API","title":"ComradeBase.visibilities_numeric!","text":"visibilties_numeric!(vis, model, u, v, time, freq)\n\nComputes the visibilties of a model in-place using a numerical fourier transform. Note that none of these are implemented in ComradeBase. For implementations please see Comrade.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensity_point","page":"Base API","title":"ComradeBase.intensity_point","text":"intensity_point(model::AbstractModel, p)\n\nFunction that computes the pointwise intensity if the model has the trait in the image domain IsAnalytic(). Otherwise it will use construct the image in visibility space and invert it.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap_analytic","page":"Base API","title":"ComradeBase.intensitymap_analytic","text":"intensitymap_analytic(m::AbstractModel, p::AbstractDims)\n\nComputes the IntensityMap of a model m using the image dimensions p by broadcasting over the analytic intensity_point method.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap_analytic!","page":"Base API","title":"ComradeBase.intensitymap_analytic!","text":"intensitymap_analytic!(img::IntensityMap, m::AbstractModel)\nintensitymap_analytic!(img::StokesIntensityMap, m::AbstractModel)\n\nUpdates the img using the model m  by broadcasting over the analytic intensity_point method.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap_numeric","page":"Base API","title":"ComradeBase.intensitymap_numeric","text":"intensitymap_numeric(m::AbstractModel, p::AbstractDims)\n\nComputes the IntensityMap of a model m at the image positions p using a numerical method. This has to be specified uniquely for every model m if imanalytic(typeof(m)) === NotAnalytic(). See Comrade.jl for example implementations.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.intensitymap_numeric!","page":"Base API","title":"ComradeBase.intensitymap_numeric!","text":"intensitymap_numeric!(img::IntensityMap, m::AbstractModel)\nintensitymap_numeric!(img::StokesIntensityMap, m::AbstractModel)\n\nUpdates the img using the model m  using a numerical method. This has to be specified uniquely for every model m if imanalytic(typeof(m)) === NotAnalytic(). See Comrade.jl for example implementations.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#Image-Types","page":"Base API","title":"Image Types","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"ComradeBase.IntensityMap(::AbstractArray, ::AbstractDims)\nComradeBase.StokesIntensityMap\nComradeBase.imagepixels\nComradeBase.GriddedKeys\nComradeBase.dims\nComradeBase.named_dims\nComradeBase.axisdims\nComradeBase.stokes\nComradeBase.imagegrid\nComradeBase.fieldofview\nComradeBase.pixelsizes\nComradeBase.phasecenter\nComradeBase.centroid\nComradeBase.second_moment\nComradeBase.header\nComradeBase.NoHeader\nComradeBase.MinimalHeader\nComradeBase.load\nComradeBase.save","category":"page"},{"location":"base_api/#ComradeBase.IntensityMap-Tuple{AbstractArray, ComradeBase.AbstractDims}","page":"Base API","title":"ComradeBase.IntensityMap","text":"IntensityMap(data::AbstractArray, dims::NamedTuple)\nIntensityMap(data::AbstractArray, grid::AbstractDims)\n\nConstructs an intensitymap using the image dimensions given by dims. This returns a KeyedArray with keys given by an ImageDimensions object.\n\ndims = (X=range(-10.0, 10.0, length=100), Y = range(-10.0, 10.0, length=100),\n        T = [0.1, 0.2, 0.5, 0.9, 1.0], F = [230e9, 345e9]\n        )\nimgk = IntensityMap(rand(100,100,5,1), dims)\n\n\n\n\n\n","category":"method"},{"location":"base_api/#ComradeBase.StokesIntensityMap","page":"Base API","title":"ComradeBase.StokesIntensityMap","text":"struct StokesIntensityMap{T, N, SI, SQ, SU, SV}\n\nGeneral struct that holds intensity maps for each stokes parameter. Each image I, Q, U, V must share the same axis dimensions. This type also obeys much of the usual array interface in Julia. The following methods have been implemented:\n\nsize\neltype (returns StokesParams)\nndims\ngetindex\nsetindex!\npixelsizes\nfieldofview\nimagepixels\nimagegrid\nstokes\n\nwarning: Warning\nThis may eventually be phased out for IntensityMaps whose base types are StokesParams, but currently we use this for speed reasons with Zygote.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.imagepixels","page":"Base API","title":"ComradeBase.imagepixels","text":"imagepixels(img::IntensityMap)\nimagepixels(img::IntensityMapTypes)\n\nReturns a abstract spatial dimension with the image pixels locations X and Y.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.GriddedKeys","page":"Base API","title":"ComradeBase.GriddedKeys","text":"struct GriddedKeys{N, G, Hd<:ComradeBase.AbstractHeader, T} <: ComradeBase.AbstractDims{N, T}\n\nThis struct holds the dimensions that the EHT expect. The first type parameter N defines the names of each dimension. These names are usually one of     - (:X, :Y, :T, :F)     - (:X, :Y, :F, :T)     - (:X, :Y) # spatial only where :X,:Y are the RA and DEC spatial dimensions respectively, :T is the the time direction and :F is the frequency direction.\n\nFieldnames\n\ndims\nheader\n\nNotes\n\nWarning it is rare you need to access this constructor directly. Instead use the direct IntensityMap function.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.dims","page":"Base API","title":"ComradeBase.dims","text":"dims(g::AbstractDims)\n\nReturns a tuple containing the dimensions of g. For a named version see ComradeBase.named_dims\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.named_dims","page":"Base API","title":"ComradeBase.named_dims","text":"named_dims(g::AbstractDims)\n\nReturns a named tuple containing the dimensions of g. For a unnamed version see dims\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.axisdims","page":"Base API","title":"ComradeBase.axisdims","text":"axisdims(img::IntensityMap)\n\nReturns the keys of the IntensityMap as the actual internal AbstractDims object.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.stokes","page":"Base API","title":"ComradeBase.stokes","text":"stokes(m::AbstractPolarizedModel, p::Symbol)\n\nExtract the specific stokes component p from the polarized model m\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.imagegrid","page":"Base API","title":"ComradeBase.imagegrid","text":"imagegrid(k::IntensityMap)\n\nReturns the grid the IntensityMap is defined as. Note that this is unallocating since it lazily computes the grid. The grid is an example of a KeyedArray and works similarly. This is useful for broadcasting a model across an abritrary grid.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.fieldofview","page":"Base API","title":"ComradeBase.fieldofview","text":"fieldofview(img::IntensityMap)\nfieldofview(img::IntensityMapTypes)\n\nReturns a named tuple with the field of view of the image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.pixelsizes","page":"Base API","title":"ComradeBase.pixelsizes","text":"pixelsizes(img::IntensityMap)\npixelsizes(img::IntensityMapTypes)\n\nReturns a named tuple with the spatial pixel sizes of the image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.phasecenter","page":"Base API","title":"ComradeBase.phasecenter","text":"phasecenter(img::IntensityMap)\nphasecenter(img::StokesIntensitymap)\n\nComputes the phase center of an intensity map. Note this is the pixels that is in the middle of the image.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.centroid","page":"Base API","title":"ComradeBase.centroid","text":"centroid(im::AbstractIntensityMap)\n\nComputes the image centroid aka the center of light of the image.\n\nFor polarized maps we return the centroid for Stokes I only.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.second_moment","page":"Base API","title":"ComradeBase.second_moment","text":"second_moment(im::AbstractIntensityMap; center=true)\n\nComputes the image second moment tensor of the image. By default we really return the second cumulant or centered second moment, which is specified by the center argument.\n\nFor polarized maps we return the second moment for Stokes I only.\n\n\n\n\n\nsecond_moment(im::AbstractIntensityMap; center=true)\n\nComputes the image second moment tensor of the image. By default we really return the second cumulant or centered second moment, which is specified by the center argument.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.header","page":"Base API","title":"ComradeBase.header","text":"header(g::AbstractDims)\n\nReturns the headerinformation of the dimensions g\n\n\n\n\n\nheader(img::IntensityMap)\n\nRetrieves the header of an IntensityMap\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.NoHeader","page":"Base API","title":"ComradeBase.NoHeader","text":"NoHeader\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.MinimalHeader","page":"Base API","title":"ComradeBase.MinimalHeader","text":"MinimalHeader{T}\n\nA minimal header type for ancillary image information.\n\nFields\n\nsource: Common source name\n\nra: Right ascension of the image in degrees (J2000)\n\ndec: Declination of the image in degrees (J2000)\n\nmjd: Modified Julian Date in days\n\nfrequency: Frequency of the image in Hz\n\n\n\n\n\n","category":"type"},{"location":"base_api/#ComradeBase.load","page":"Base API","title":"ComradeBase.load","text":"ComradeBase.load(fitsfile::String, IntensityMap)\n\nThis loads in a fits file that is more robust to the various imaging algorithms in the EHT, i.e. is works with clean, smili, eht-imaging. The function returns an tuple with an intensitymap and a second named tuple with ancillary information about the image, like the source name, location, mjd, and radio frequency.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase.save","page":"Base API","title":"ComradeBase.save","text":"ComradeBase.save(file::String, img::IntensityMap, obs)\n\nSaves an image to a fits file. You can optionally pass an EHTObservation so that ancillary information will be added.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#Polarization","page":"Base API","title":"Polarization","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"ComradeBase.AbstractPolarizedModel\nPolarizedTypes.StokesParams\nPolarizedTypes.ElectricFieldBasis\nPolarizedTypes.RPol\nPolarizedTypes.LPol\nPolarizedTypes.XPol\nPolarizedTypes.YPol\nPolarizedTypes.PolBasis\nPolarizedTypes.CirBasis\nPolarizedTypes.LinBasis\nPolarizedTypes.CoherencyMatrix\nPolarizedTypes.evpa\nPolarizedTypes.m̆\nPolarizedTypes.linearpol\nPolarizedTypes.innerprod\nPolarizedTypes.basis_components\nPolarizedTypes.basis_transform\nPolarizedTypes.polarization\nPolarizedTypes.fracpolarization","category":"page"},{"location":"base_api/#ComradeBase.AbstractPolarizedModel","page":"Base API","title":"ComradeBase.AbstractPolarizedModel","text":"abstract type AbstractPolarizedModel <: ComradeBase.AbstractModel\n\nType the classifies a model as being intrinsically polarized. This means that any call to visibility must return a StokesParams to denote the full stokes polarization of the model.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.StokesParams","page":"Base API","title":"PolarizedTypes.StokesParams","text":"struct StokesParams{T} <: StaticArraysCore.FieldVector{4, T}\n\nStatic vector that holds the stokes parameters of a polarized complex visibility\n\nTo convert between a StokesParams and CoherencyMatrix use the convert function\n\nconvert(::CoherencyMatrix, StokesVector(1.0, 0.1, 0.1, 0.4))\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.ElectricFieldBasis","page":"Base API","title":"PolarizedTypes.ElectricFieldBasis","text":"abstract type ElectricFieldBasis\n\nAn abstract type whose subtypes denote a specific electric field basis.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.RPol","page":"Base API","title":"PolarizedTypes.RPol","text":"struct RPol <: PolarizedTypes.ElectricFieldBasis\n\nThe right circular electric field basis, i.e. a right-handed circular feed.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.LPol","page":"Base API","title":"PolarizedTypes.LPol","text":"struct LPol <: PolarizedTypes.ElectricFieldBasis\n\nThe left circular electric field basis, i.e. a left-handed circular feed.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.XPol","page":"Base API","title":"PolarizedTypes.XPol","text":"struct XPol <: PolarizedTypes.ElectricFieldBasis\n\nThe horizontal or X electric feed basis, i.e. the horizontal linear feed.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.YPol","page":"Base API","title":"PolarizedTypes.YPol","text":"struct YPol <: PolarizedTypes.ElectricFieldBasis\n\nThe vertical or Y electric feed basis, i.e. the vertical linear feed.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.PolBasis","page":"Base API","title":"PolarizedTypes.PolBasis","text":"struct PolBasis{B1<:Union{Missing, PolarizedTypes.ElectricFieldBasis}, B2<:Union{Missing, PolarizedTypes.ElectricFieldBasis}}\n\nDenotes a general polarization basis, with basis vectors (B1,B2) which are typically <: Union{ElectricFieldBasis, Missing}\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.CirBasis","page":"Base API","title":"PolarizedTypes.CirBasis","text":"CirBasis <: PolBasis\n\nMeasurement uses the circular polarization basis, which is typically used for circular feed interferometers.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.LinBasis","page":"Base API","title":"PolarizedTypes.LinBasis","text":"LinBasis <: PolBasis\n\nMeasurement uses the linear polarization basis, which is typically used for linear feed interferometers.\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.CoherencyMatrix","page":"Base API","title":"PolarizedTypes.CoherencyMatrix","text":"struct CoherencyMatrix{B1, B2, T} <: StaticArraysCore.FieldMatrix{2, 2, T}\n\nCoherency matrix for a single baseline with bases B1 and B2. The two bases correspond to the type of feeds used for each telescope and should be subtypes of PolBasis. To see which bases are implemented type subtypes(Rimes.PolBasis) in the REPL.\n\nFor a circular basis the layout of the coherency matrix is\n\nRR* RL*\nLR* RR*\n\nwhich can be constructed using\n\nc = CoherencyMatrix(RR, LR, RL, LL, CirBasis())\n\nFor a linear basis the layout of the coherency matrix is\n\nXX* XY*\nYX* YY*\n\nwhich can be constructed using\n\nc = CoherencyMatrix(XX, YX, XY, YY, CirBasis())\n\nFor a mixed (e.g., circular and linear basis) the layout of the coherency matrix is\n\nRX* RY*\nLX* LY*\n\nor e.g., linear and circular the layout of the coherency matrix is\n\nXR* XL*\nYR* YL*\n\nThese coherency matrices can be constructed using:\n\n# Circular and linear feeds i.e., |R><X|\nc = CoherencyMatrix(RX, LX, RY, LY, LinBasis(), CirBasis())\n# Linear and circular feeds i.e., |X><R|\nc = CoherencyMatrix(XR, YR, XL, YL, LinBasis(), CirBasis())\n\n\n\n\n\n","category":"type"},{"location":"base_api/#PolarizedTypes.evpa","page":"Base API","title":"PolarizedTypes.evpa","text":"evpa(pimg::AbstractPolarizedModel, p)\n\nelectric vector position angle or EVPA of the polarized model pimg at p\n\n\n\n\n\nevpa(m::Union{StokesParams, CoherencyMatrix})\n\nCompute the evpa of a stokes vect or cohereny matrix.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#PolarizedTypes.m̆","page":"Base API","title":"PolarizedTypes.m̆","text":"m̆(pimg::AbstractPolarizedModel, p)\nmbreve(pimg::AbstractPolarizedModel, p)\n\nComputes the fractional linear polarization in the visibility domain\n\nm̆ = (Q̃ + iŨ)/Ĩ\n\nTo create the symbol type m\\breve in the REPL or use the mbreve function.\n\n\n\n\n\nm̆(m::Union{StokesParameters{<:Complex}, CoherencyMatrix)\n\nComputes the complex fractional linear polarization of the complex or visibility quantities. Note that this function can also be called used mbreve\n\n\n\n\n\n","category":"function"},{"location":"base_api/#PolarizedTypes.linearpol","page":"Base API","title":"PolarizedTypes.linearpol","text":"linearpol(pimg::AbstractPolarizedModel, p)\n\nReturn the complex linear polarization of the model m at point p.\n\n\n\n\n\nlinearpol(s)\n\n\nComputes linearpol from a set of stokes parameters s.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#PolarizedTypes.innerprod","page":"Base API","title":"PolarizedTypes.innerprod","text":"innerprod(::Type{T}, XPol(), YPol())\n\nComputes the complex inner product of two elements of a complex Hilbert space X and Y where base element of the output is T.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#PolarizedTypes.basis_components","page":"Base API","title":"PolarizedTypes.basis_components","text":"basis_components([T=Float64,], e::ElectricFieldBasis, b::PolBasis)\n\nReturns a static vector that contains the components of the electric field basis vector e in terms of the polarization basis b. The first argument is optionally the eltype of the static vector.\n\nExamples\n\njulia> basis_components(Float64, R(), PolBasis{XPol,Y}())\n2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):\n 0.7071067811865475 + 0.0im\n                0.0 - 0.7071067811865475im\n\njulia> basis_components(R(), PolBasis{XPol,Y}())\n2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):\n 0.7071067811865475 + 0.0im\n                0.0 - 0.7071067811865475im\n\n\njulia> basis_components(Float64, X(), PolBasis{XPol,Y}())\n2-element StaticArraysCore.SVector{2, ComplexF64} with indices SOneTo(2):\n 1.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"base_api/#PolarizedTypes.basis_transform","page":"Base API","title":"PolarizedTypes.basis_transform","text":"basis_transform([T=Float64,], b1::PolBasis, b2::PolBasis)\nbasis_transform([T=Float64,], b1::PolBasis=>b2::PolBasis)\n\nProduces the transformation matrix that transforms the vector components from basis b1 to basis b2. This means that if for example E is the circular basis then basis_transform(CirBasis=>LinBasis)E is in the linear basis. In other words the columns of the transformation matrix are the coordinate vectors of the new basis vectors in the old basis.\n\nExample\n\njulia> basis_transform(CirBasis()=>LinBasis())\n2×2 StaticArraysCore.SMatrix{2, 2, ComplexF64, 4} with indices SOneTo(2)×SOneTo(2):\n 0.707107-0.0im       0.707107-0.0im\n      0.0-0.707107im       0.0+0.707107im\n\n\n\n\n\n","category":"function"},{"location":"base_api/#PolarizedTypes.polarization","page":"Base API","title":"PolarizedTypes.polarization","text":"polarization(pimg::AbstractPolarizedModel, p)\n\nReturn the polarization vector (Q, U, V) of the model m at point p.\n\n\n\n\n\npolarization(s)\n\n\nReturns the (Q, U, V) polarization vector as a 3-element static vector.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#PolarizedTypes.fracpolarization","page":"Base API","title":"PolarizedTypes.fracpolarization","text":"fracpolarization(pimg::AbstractPolarizedModel, p)\n\nReturn the fractional polarization vector (Q/I, U/I, V/I) of the model m at point p.\n\n\n\n\n\nfracpolarization(s)\n\n\nReturns the (Q/I, U/I, V/I) fractional polarization vector as a 3-element static vector.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#Internal-Methods-not-part-of-public-API","page":"Base API","title":"Internal Methods not part of public API","text":"","category":"section"},{"location":"base_api/","page":"Base API","title":"Base API","text":"ComradeBase._visibilities\nComradeBase._visibilities!","category":"page"},{"location":"base_api/#ComradeBase._visibilities","page":"Base API","title":"ComradeBase._visibilities","text":"_visibilities(model::AbstractModel, args...)\n\nInternal method used for trait dispatch and unpacking of args arguments in visibilities\n\nwarn: Warn\nNot part of the public API so it may change at any moment.\n\n\n\n\n\n","category":"function"},{"location":"base_api/#ComradeBase._visibilities!","page":"Base API","title":"ComradeBase._visibilities!","text":"_visibilities!(model::AbstractModel, args...)\n\nInternal method used for trait dispatch and unpacking of args arguments in visibilities!\n\nwarn: Warn\nNot part of the public API so it may change at any moment.\n\n\n\n\n\n","category":"function"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Contents","page":"API","title":"Contents","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Model-Definitions","page":"API","title":"Model Definitions","text":"","category":"section"},{"location":"api/#Combinators","page":"API","title":"Combinators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Base.:+(::VLBISkyModels.AbstractModel, ::VLBISkyModels.AbstractModel)\nVLBISkyModels.added\nVLBISkyModels.convolved\nVLBISkyModels.components\nVLBISkyModels.smoothed\nVLBISkyModels.CompositeModel\nVLBISkyModels.AddModel\nVLBISkyModels.ConvolvedModel","category":"page"},{"location":"api/#Base.:+-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractModel}","page":"API","title":"Base.:+","text":"Base.:+(m1::AbstractModel, m2::AbstractModel)\n\nCombine two models to create a composite AddModel. This adds two models pointwise, i.e.\n\njulia> m1 = Gaussian()\njulia> m2 = Disk()\njulia> visibility(m1+m2, 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#VLBISkyModels.added","page":"API","title":"VLBISkyModels.added","text":"added(m1::AbstractModel, m2::AbstractModel)\n\nCombine two models to create a composite AddModel. This adds two models pointwise, i.e.\n\njulia> m1 = Gaussian()\njulia> m2 = Disk()\njulia> visibility(added(m1,m2), 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.convolved","page":"API","title":"VLBISkyModels.convolved","text":"convolved(m1::AbstractModel, m2::AbstractModel)\n\nConvolve two models to create a composite ConvolvedModel.\n\njulia> m1 = Ring()\njulia> m2 = Disk()\njulia> convolved(m1, m2)\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.components","page":"API","title":"VLBISkyModels.components","text":"components(m::AbstractModel)\n\nReturns the model components for a composite model. This will return a Tuple with all the models you have constructed.\n\nExample\n\njulia> m = Gaussian() + Disk()\njulia> components(m)\n(Gaussian{Float64}(), Disk{Float64}())\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.smoothed","page":"API","title":"VLBISkyModels.smoothed","text":"smoothed(m::AbstractModel, σ::Number)\n\nSmooths a model m with a Gaussian kernel with standard deviation σ.\n\nNotes\n\nThis uses convolved to created the model, i.e.\n\njulia> m1 = Disk()\njulia> m2 = Gaussian()\njulia> convolved(m1, m2) == smoothed(m1, 1.0)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.CompositeModel","page":"API","title":"VLBISkyModels.CompositeModel","text":"abstract type CompositeModel{M1, M2} <: ComradeBase.AbstractModel\n\nAbstract type that denotes a composite model. Where we have combined two models together.\n\nImplementation\n\nAny implementation of a composite type must define the following methods:\n\nvisibility_point\nuv_combinator\nimanalytic\nvisanalytic\nComradeBase.intensity_point if model intensity is IsAnalytic\nintensitymap_numeric! if model intensity is NotAnalytic\nintensitymap_numeric if model intensity is NotAnalytic\nflux\nradialextent\n\nIn addition there are additional optional methods a person can define if needed:\n\nintensitymap_analytic! if model intensity is IsAnalytic  (optional)\nintensitymap_analytic if model intensity is IsAnalytic (optional)\nvisibilities_analytic if visanalytic is IsAnalytic (optional)\nvisibilities_numeric  if visanalytic is Not Analytic (optional)\nvisibilities_analytic! if visanalytic is IsAnalytic (optional)\nvisibilities_numeric!  if visanalytic is Not Analytic (optional)\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.AddModel","page":"API","title":"VLBISkyModels.AddModel","text":"struct AddModel{T1, T2} <: VLBISkyModels.CompositeModel{T1, T2}\n\nPointwise addition of two models in the image and visibility domain. An end user should instead call added or Base.+ when constructing a model\n\nExample\n\njulia> m1 = Disk() + Gaussian()\njulia> m2 = added(Disk(), Gaussian()) + Ring()\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ConvolvedModel","page":"API","title":"VLBISkyModels.ConvolvedModel","text":"struct ConvolvedModel{M1, M2} <: VLBISkyModels.CompositeModel{M1, M2}\n\nPointwise addition of two models in the image and visibility domain. An end user should instead call convolved. Also see smoothed(m, σ) for a simplified function that convolves a model m with a Gaussian with standard deviation σ.\n\n\n\n\n\n","category":"type"},{"location":"api/#Geometric-and-Image-Models","page":"API","title":"Geometric and Image Models","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.GeometricModel\nVLBISkyModels.ConcordanceCrescent\nVLBISkyModels.Crescent\nVLBISkyModels.Disk\nVLBISkyModels.SlashedDisk\nVLBISkyModels.ExtendedRing\nVLBISkyModels.Gaussian\nVLBISkyModels.MRing\nVLBISkyModels.Ring\nVLBISkyModels.ParabolicSegment\nVLBISkyModels.ContinuousImage\nVLBISkyModels.ZeroModel\nVLBISkyModels.MultiComponentModel\nVLBISkyModels.PolarizedModel","category":"page"},{"location":"api/#VLBISkyModels.GeometricModel","page":"API","title":"VLBISkyModels.GeometricModel","text":"abstract type GeometricModel{T} <: ComradeBase.AbstractModel\n\nA type that defines it is a geometric model. These are usually primitive models, and are usually analytic in Fourier and the image domain. As a result a user only needs to implement the following methods\n\nvisibility_point\nintensity_point\nradialextent\n\nNote that if the geometric model isn't analytic then the usual methods listed in ComradeBase.AbstractModel for non-analytic models need to be implemented.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ConcordanceCrescent","page":"API","title":"VLBISkyModels.ConcordanceCrescent","text":"struct ConcordanceCrescent{T} <: VLBISkyModels.GeometricModel{T}\n\nCreates the ConcordanceCrescent model, i.e. a flat-top crescent with a displacment and a slash and shadow depth. Note this creates a crescent with unit flux. If you want a different flux please use the renomed modifier.\n\nFields\n\nrouter: Outer radius of the crescent\n\nrinner: Inner radius of the crescent (i.e. inside this radius there is a hole)\n\nshift: Displacment of the inner disk radius\n\nslash: Strength of the linear slash. Note that s∈[0.0,1.0] to ensure positivity in the image.\n\nNotes\n\nUnlike the Gaussian and Disk models this does not create the unit version. In fact, this model could have been created using the Disk and primitives by using VLBISkyModels's model composition functionality.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Crescent","page":"API","title":"VLBISkyModels.Crescent","text":"Creates a Kamruddin and Dexter crescent model. This works by composing two disk models together.\n\nArguments\n\nrouter: The radius of the outer disk\nrinner: The radius of the inner disk\nshift: How much the inner disk radius is shifted (positive is to the right)\nfloor: The floor of the inner disk 0 means the inner intensity is zero and 1 means it is a large disk.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.Disk","page":"API","title":"VLBISkyModels.Disk","text":"Disk{T}() where {T}\n\nTophat disk geometrical model, i.e. the intensity profile\n\n    I(xy) = begincases pi^-1  x^2+y^2  1  0  x^2+y^2 geq 0 endcases\n\ni.e. a unit radius and unit flux disk.\n\nBy default if T isn't given, Disk defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.SlashedDisk","page":"API","title":"VLBISkyModels.SlashedDisk","text":"SlashedDisk{T}(slash::T) where {T}\n\nTophat disk geometrical model, i.e. the intensity profile\n\n    I(xy) = begincases pi^-1  x^2+y^2  1  0  x^2+y^2 geq 0 endcases\n\ni.e. a unit radius and unit flux disk.\n\nBy default if T isn't given, Disk defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ExtendedRing","page":"API","title":"VLBISkyModels.ExtendedRing","text":"struct ExtendedRing{T} <: VLBISkyModels.GeometricModel{T}\n\nA symmetric extended ring whose radial profile follows an inverse gamma distributions.\n\nThe formula in the image domain is given by\n\nI(r,θ) = βᵅrᵅ⁻²exp(-β/r)/2πΓ(α)\n\nwhere α = shape and β = shape+1\n\nNote\n\nWe mainly use this as an example of a non-analytic Fourier transform (although it has a complicated expression)\n\nFields\n\nshape: shape of the radial distribution\n\nNote that if T isn't specified at construction then it defaults to Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Gaussian","page":"API","title":"VLBISkyModels.Gaussian","text":"struct Gaussian{T} <: VLBISkyModels.GeometricModel{T}\n\nGaussian with unit standard deviation and flux.\n\nBy default if T isn't given, Gaussian defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.MRing","page":"API","title":"VLBISkyModels.MRing","text":"struct MRing{T, V<:Union{AbstractArray{T, 1}, Tuple{Vararg{T, N}} where {N, T}}} <: VLBISkyModels.GeometricModel{T}\n\nm-ring geometric model. This is a infinitely thin unit flux delta ring whose angular structure is given by a Fourier expansion. That is,\n\nI(r,θ) = (2π)⁻¹δ(r-1)∑ₙ(αₙcos(nθ) - βₙsin(nθ))\n\nThe N in the type defines the order of the Fourier expansion.\n\nFields\n\nα: Real Fourier mode coefficients\n\nβ: Imaginary Fourier mode coefficients\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Ring","page":"API","title":"VLBISkyModels.Ring","text":"struct Ring{T} <: VLBISkyModels.GeometricModel{T}\n\nA infinitely thin ring model, whose expression in the image domain is     I(r,θ) = δ(r - 1)/2π i.e. a unit radius and flux delta ring.\n\nBy default if T isn't given, Gaussian defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ParabolicSegment","page":"API","title":"VLBISkyModels.ParabolicSegment","text":"struct ParabolicSegment{T} <: VLBISkyModels.GeometricModel{T}\n\nA infinitely thin parabolic segment in the image domain. The segment is centered at zero, with roots ±1 and a yintercept of 1.\n\nNote that if T isn't specified at construction then it defaults to Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ContinuousImage","page":"API","title":"VLBISkyModels.ContinuousImage","text":"ContinuousImage{A<:IntensityMap, P} <: AbstractModel\nContinuousImage(img::Intensitymap, kernel)\n\nThe basic continuous image model for VLBISkyModels. This expects a IntensityMap style object as its imag as well as a image kernel or pulse that allows you to evaluate the image at any image and visibility location. The image model is\n\nI(x,y) = ∑ᵢ Iᵢⱼ κ(x-xᵢ, y-yᵢ)\n\nwhere Iᵢⱼ are the flux densities of the image img and κ is the intensity function for the kernel.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ZeroModel","page":"API","title":"VLBISkyModels.ZeroModel","text":"struct ZeroModel{T} <: ComradeBase.AbstractModel\n\nDefines a model that is empty that is it return zero for everything.\n\nNotes\n\nThis returns 0 by using FillArrays so everything should be non-allocating\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.MultiComponentModel","page":"API","title":"VLBISkyModels.MultiComponentModel","text":"MultiComponentModel(beam::AbstractModel, fluxes::AbstractVector, x::AbstractVector, y::AbstractVector)\n\nBuild a model with a base model type beam where fluxes, x, y corresond to the flux, and positions of the components. This can be used to easily construct clean like models.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.PolarizedModel","page":"API","title":"VLBISkyModels.PolarizedModel","text":"struct PolarizedModel{TI, TQ, TU, TV} <: ComradeBase.AbstractPolarizedModel\n\nWrapped model for a polarized model. This uses the stokes representation of the image.\n\nFields\n\nI: Stokes I model\n\nQ: Stokes Q Model\n\nU: Stokes U Model\n\nV: Stokes V Model\n\n\n\n\n\n","category":"type"},{"location":"api/#Image-Pulses","page":"API","title":"Image Pulses","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.Pulse\nVLBISkyModels.DeltaPulse\nVLBISkyModels.BSplinePulse\nVLBISkyModels.RaisedCosinePulse\nVLBISkyModels.BicubicPulse\nVLBISkyModels.Butterworth","category":"page"},{"location":"api/#VLBISkyModels.Pulse","page":"API","title":"VLBISkyModels.Pulse","text":"Pulse\n\nPixel response function for a radio image model. This makes a discrete sampling continuous by picking a certain smoothing kernel for the image.\n\nNotes\n\nTo see the implemented Pulses please use the subtypes function i.e. subtypes(Pulse)\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.DeltaPulse","page":"API","title":"VLBISkyModels.DeltaPulse","text":"struct DeltaPulse{T} <: VLBISkyModels.Pulse\n\nA dirac comb pulse function. This means the image is just the dicrete Fourier transform\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.BSplinePulse","page":"API","title":"VLBISkyModels.BSplinePulse","text":"$(TYPEDEF)\n\nUses the basis spline (BSpline) kernel of order N. These are the kernel that come from recursively convolving the tophat kernel\n\n    B_0(x) = begincases 1  x  1  0  otherwise endcases\n\nN times.\n\nNotes\n\nBSpline kernels have a number of nice properties:\n\nSimple frequency response sinc(u2)^N\npreserve total intensity\n\nFor N>1 these kernels aren't actually interpolation kernels however, this doesn't matter for us.\n\nCurrently only the 0,1,3 order kernels are implemented.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.RaisedCosinePulse","page":"API","title":"VLBISkyModels.RaisedCosinePulse","text":"struct RaisedCosinePulse{T} <: VLBISkyModels.Pulse\n\nRaisedCosinePulse()\nRaisedCosinePulse(rolloff)\n\nRaised cosine pulse function. This tends to be a very flat response, where the roll off controls the speed of decay. By default we set rolloff = 0.5.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.BicubicPulse","page":"API","title":"VLBISkyModels.BicubicPulse","text":"struct BicubicPulse{T} <: VLBISkyModels.Pulse\n\nBicubicPulse(b = 0.5)\n\nThe bicubic pulse for imaging. This pulse tends to have a flat spectrum but for most values of b can produce negative intensities in an image. This is the pulse used in Broderick et al. 2020.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Butterworth","page":"API","title":"VLBISkyModels.Butterworth","text":"Butterworth{N}()\nButterworth{N, T}()\n\nConstruct a model that corresponds to the Butterworth filter of order N. The type of the output is given by T and if not given defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#Model-Image-(non-analytic-FFT)","page":"API","title":"Model Image (non analytic FFT)","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.create_cache\nVLBISkyModels.update_cache\nVLBISkyModels.modelimage\nVLBISkyModels.uviterator\nVLBISkyModels.fouriermap\nVLBISkyModels.ModelImage\nVLBISkyModels.DFTAlg\nVLBISkyModels.FFTAlg\nVLBISkyModels.FFTCache\nVLBISkyModels.NFFTAlg\nVLBISkyModels.NUFTCache\nVLBISkyModels.ObservedNUFT","category":"page"},{"location":"api/#VLBISkyModels.create_cache","page":"API","title":"VLBISkyModels.create_cache","text":"create_cache(alg::AbstractFourierTransform, img::AbstractIntensityMap)\n\nCreates a Fourier transform cache for a img using algorithm alg. For non-analytic visibility models this can significantly speed up computations.\n\nExamples\n\njulia> u,v = rand(100), rand(100)\njulia> cache = create_cache(DFTAlg(u, v), IntensityMap(randn(50,50), 10.0, 10.0))\njulia> cache = create_cache(NFFTAlg(u, v), IntensityMap(randn(50,50), 10.0, 10.0))\njulia> cache = create_cache(FFTAlg(), IntensityMap(randn(50,50), 10.0, 10.0))\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.update_cache","page":"API","title":"VLBISkyModels.update_cache","text":"update_cache(cache, img)\n\nUpdate the Fourier transform cache. This will reuse an FFT/NFFT plan saving some computational time.\n\nNote\n\nThis is an intenal method than an end user shouldn't have to usually call.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.modelimage","page":"API","title":"VLBISkyModels.modelimage","text":"modelimage(model::AbstractModel, image::AbstractIntensityMap, alg=FFTAlg())\n\nConstruct a ModelImage from a model, image and the optionally specified visibility algorithm alg\n\nNotes\n\nFor analytic models this is a no-op and returns the model. For non-analytic models this creates a ModelImage object which uses alg to compute the non-analytic Fourier transform.\n\n\n\n\n\nmodelimage(model, cache::AbstractCach))\n\nConstruct a ModelImage from the model and using a precompute Fourier transform cache. You can optionally specify th which will compute the internal image buffer using the`.\n\nExample\n\njulia> m = ExtendedRing(10.0)\njulia> cache = create_cache(DFTAlg(), IntensityMap(zeros(128, 128), 50.0, 50.0)) # used threads to make the image\njulia> mimg = modelimage(m, cache, true)\n\nNotes\n\nFor analytic models this is a no-op and returns the model.\n\n\n\n\n\nmodelimage(m;\n           fovx=2*radialextent(m),\n           fovy=2*radialextent(m),\n           nx=512,\n           ny=512,\n           alg=FFTAlg(),\n           pulse=ComradeBase.DeltaPulse(),\n            )\n\nConstruct a ModelImage where just the model m is specified.\n\nIf fovx or fovy aren't given modelimage will guess a reasonable field of view based on the radialextent function. nx and ny are the number of pixels in the x and y direction. The pulse is the pulse used for the image and alg\n\nNotes\n\nFor analytic models this is a no-op and returns the model.\n\n\n\n\n\nmodelimage(img::ContinuousImage, alg=NFFTAlg())\n\nCreate a model image directly using an image, i.e. treating it as the model. You can optionally specify the Fourier transform algorithm using alg\n\n\n\n\n\nmodelimage(img::ContinuousImage, cache::AbstractCache)\n\nCreate a model image directly using an image, i.e. treating it as the model. Additionally reuse a previously compute image cache. This can be used when directly modeling an image of a fixed size and number of pixels.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.uviterator","page":"API","title":"VLBISkyModels.uviterator","text":"uviterator(nx, dx, ny dy)\n\nConstruct the u,v iterators for the Fourier transform of the image with pixel sizes dx, dy and number of pixels nx, ny\n\nIf you are extending Fourier transform stuff please use these functions to ensure that the centroid is being properly computed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.fouriermap","page":"API","title":"VLBISkyModels.fouriermap","text":"fouriermap(m, x)\n\nCreate a Fourier or visibility map of a model m where the image is specified in the image domain by the pixel locations x and y\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.ModelImage","page":"API","title":"VLBISkyModels.ModelImage","text":"struct ModelImage{M, I, C} <: VLBISkyModels.AbstractModelImage{M}\n\nContainer for non-analytic model that contains a image cache which will hold the image, a Fourier transform cache, which usually an instance of a <: FourierCache.\n\nNote\n\nThis is an internal implementation detail that shouldn't usually be called directly. Instead the user should use the exported function modelimage, for example\n\nusing Comrade\nm = ExtendedRing(20.0, 5.0)\n\n# This creates an version where the image is dynamically specified according to the\n# radial extent of the image\nmimg = modelimage(m) # you can also optionally pass the number of pixels nx and ny\n\n# Or you can create an IntensityMap\nimg = intensitymap(m, 100.0, 100.0, 512, 512)\nmimg = modelimage(m, img)\n\n# Or precompute a cache\ncache = create_cache(FFTAlg(), img)\nmimg = modelimage(m, cache)\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.DFTAlg","page":"API","title":"VLBISkyModels.DFTAlg","text":"DFTAlg\n\nUses a discrete fourier transform. This is not very efficient for larger images. In those cases  NFFTAlg or FFTAlg are more reasonable. For small images this is a reasonable choice especially since it's easy to define derivatives.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.FFTAlg","page":"API","title":"VLBISkyModels.FFTAlg","text":"struct FFTAlg <: VLBISkyModels.FourierTransform\n\nUse an FFT to compute the approximate numerical visibilities of a model. For a DTFT see DFTAlg or for an NFFT NFFTAlg\n\nFields\n\npadfac: The amount to pad the image by. Note we actually round up to the nearest factor of 2, but this will be improved in the future to use small primes\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.FFTCache","page":"API","title":"VLBISkyModels.FFTCache","text":"struct FFTCache{A<:FFTAlg, P, I, Pu, S} <: VLBISkyModels.AbstractCache\n\nThe cache used when the FFT algorithm is used to compute visibilties. This is an internal type and is not part of the public API\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.NFFTAlg","page":"API","title":"VLBISkyModels.NFFTAlg","text":"NFFTAlg\n\nUses a non-uniform FFT to compute the visibilities. You can optionally pass uv which are the uv positions you will compute the NFFT at. This can allow for the NFFT plan to be cached improving performance\n\nFields\n\npadfac: Amount to pad the image\n\nm: Kernel size parameters. This controls the accuracy of NFFT you do not usually need to change this\n\nσ: Over sampling factor. This controls the accuracy of NFFT you do not usually need to change this.\n\nwindow: Window function for the NFFT. You do not usually need to change this\n\nprecompute: NFFT interpolation algorithm.\n\nblocking: Flag block partioning should be used to speed up computation\n\nsortNodes: Flag if the node should be sorted in a lexicographic way\n\nstoreDeconvolutionIdx: Flag if the deconvolve indices should be stored, Currently required for GPU\n\nfftflags: Flag passed to inner AbstractFFT. The fastest FFTW is FFTW.MEASURE but takes the longest to precompute\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.NUFTCache","page":"API","title":"VLBISkyModels.NUFTCache","text":"struct NUFTCache{A, P, M, PI, I} <: VLBISkyModels.AbstractCache\n\nInternal type used to store the cache for a non-uniform Fourier transform (NUFT).\n\nThe user should instead create this using the create_cache function.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ObservedNUFT","page":"API","title":"VLBISkyModels.ObservedNUFT","text":"struct ObservedNUFT{A<:VLBISkyModels.NUFT, T} <: VLBISkyModels.NUFT\n\nContainer type for a non-uniform Fourier transform (NUFT). This stores the uv-positions that the model will be sampled at in the Fourier domain, allowing certain transformtion factors (e.g., NUFT matrix) to be cached.\n\nThis is an internal type, an end user should instead create this using NFFTAlg or DFTAlg.\n\n\n\n\n\n","category":"type"},{"location":"api/#Modifiers","page":"API","title":"Modifiers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.modify\nVLBISkyModels.basemodel\nVLBISkyModels.unmodified\nVLBISkyModels.renormed\nVLBISkyModels.rotated\nVLBISkyModels.posangle\nVLBISkyModels.shifted\nVLBISkyModels.stretched\nVLBISkyModels.ModifiedModel\nVLBISkyModels.ModelModifier\nVLBISkyModels.Stretch\nVLBISkyModels.Shift\nVLBISkyModels.Rotate\nVLBISkyModels.Renormalize","category":"page"},{"location":"api/#VLBISkyModels.modify","page":"API","title":"VLBISkyModels.modify","text":"modify(m::AbstractModel, transforms...)\n\nModify a given model using the set of transforms. This is the most general function that allows you to apply a sequence of model transformation for example\n\nmodify(Gaussian(), Stretch(2.0, 1.0), Rotate(π/4), Shift(1.0, 2.0), Renorm(2.0))\n\nwill create a asymmetric Gaussian with position angle π/4 shifted to the position (1.0, 2.0) with a flux of 2 Jy. This is similar to Flux's chain.\n\n\n\n\n\nmodify(img::IntensityMap, transforms...)\n\nThis modifies the img by applying the transforms... returning a transformed IntensityMap\n\nnote: Note\n\n\nUnlike when modify is applied to a <:AbstractModel this returns an already modified image.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.basemodel","page":"API","title":"VLBISkyModels.basemodel","text":"basemodel(model::ModifiedModel)\n\nReturns the ModifiedModel with the last transformation stripped.\n\nExample\n\njulia> basemodel(stretched(Disk(), 1.0, 2.0)) == Disk()\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.unmodified","page":"API","title":"VLBISkyModels.unmodified","text":"unmodified(model::ModifiedModel)\n\nReturns the un-modified model\n\nExample\n\njulia> m = stretched(rotated(Gaussian(), π/4), 2.0, 1.0)\njulia> umodified(m) == Gaussian()\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.renormed","page":"API","title":"VLBISkyModels.renormed","text":"renormed(model, f)\n\n\nRenormalizes the model m to have total flux f*flux(m). This can also be done directly by calling Base.:* i.e.,\n\njulia> renormed(m, f) == f*M\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.rotated","page":"API","title":"VLBISkyModels.rotated","text":"rotated(model, ξ)\n\n\nRotates the model by an amount ξ in radians in the clockwise direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.posangle","page":"API","title":"VLBISkyModels.posangle","text":"posangle(model)\n\n\nReturns the rotation angle of the rotated model\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.shifted","page":"API","title":"VLBISkyModels.shifted","text":"shifted(model, Δx, Δy)\n\n\nShifts the model m in the image domain by an amount Δx,Δy in the x and y directions respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.stretched","page":"API","title":"VLBISkyModels.stretched","text":"stretched(model, α, β)\n\n\nStretches the model m according to the formula     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.ModifiedModel","page":"API","title":"VLBISkyModels.ModifiedModel","text":"struct ModifiedModel{M<:ComradeBase.AbstractModel, T<:Tuple} <: ComradeBase.AbstractModel\n\nContainer type for models that have been transformed in some way. For a list of potential modifiers or transforms see subtypes(ModelModifiers).\n\nFields\n\nmodel: base model\ntransform: model transforms\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ModelModifier","page":"API","title":"VLBISkyModels.ModelModifier","text":"abstract type ModelModifier{T}\n\nGeneral type for a model modifier. These transform any model using simple Fourier transform properties. To modify a model you can use the ModifiedModel constructor or the modify function.\n\njulia> visanalytic(stretched(Disk(), 2.0, 2.0)) == visanalytic(Disk())\ntrue\n\nTo implement a model transform you need to specify the following methods:\n\ntransform_uv\ntransform_image\nscale_uv\nscale_image\nradialextent\n\nSee thee docstrings of those methods for guidance on implementation details.\n\nAdditionally these methods assume the modifiers are of the form\n\nI(x,y) -> fᵢ(x,y)I(gᵢ(x,y)) V(u,v) -> fᵥ(u,v)V(gᵥ(u,v))\n\nwhere g are the transformimage/uv functions and f are the scaleimage/uv function.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Stretch","page":"API","title":"VLBISkyModels.Stretch","text":"Stretch(α, β)\nStretch(r)\n\nStretched the model in the x and y directions, i.e. the new intensity is     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.\n\nExample\n\njulia> modify(Gaussian(), Stretch(2.0)) == stretched(Gaussian(), 2.0, 1.0)\ntrue\n\nIf only a single argument is given it assumes the same stretch is applied in both direction.\n\njulia> Stretch(2.0) == Stretch(2.0, 2.0)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Shift","page":"API","title":"VLBISkyModels.Shift","text":"struct Shift{T} <: VLBISkyModels.ModelModifier{T}\n\nShifts the model by Δx units in the x-direction and Δy units in the y-direction.\n\nExample\n\njulia> modify(Gaussian(), Shift(2.0, 1.0)) == shifted(Gaussian(), 2.0, 1.0)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Rotate","page":"API","title":"VLBISkyModels.Rotate","text":"Rotate(ξ)\n\nType for the rotated model. This is more fine grained constrol of rotated model.\n\nExample\n\njulia> modify(Gaussian(), Rotate(2.0)) == rotated(Gaussian(), 2.0)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Renormalize","page":"API","title":"VLBISkyModels.Renormalize","text":"struct Renormalize{T} <: VLBISkyModels.ModelModifier{T}\n\nRenormalizes the flux of the model to the new value scale*flux(model). We have also overloaded the Base.:* operator as syntactic sugar although I may get rid of this.\n\nExample\n\njulia> modify(Gaussian(), Renormalize(2.0)) == 2.0*Gaussian()\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#Model-Evaluation","page":"API","title":"Model Evaluation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"For more docstrings on how to evaluate models see Base API.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Visualization","page":"API","title":"Visualization","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.imageviz\nVLBISkyModels.polimage","category":"page"},{"location":"api/#VLBISkyModels.imageviz","page":"API","title":"VLBISkyModels.imageviz","text":"imageviz(img::IntensityMap; scale_length = fieldofview(img.X/4), kwargs...)\n\nA default image visualization for a IntensityMap.\n\nIf eltype(img) <: Real i.e. an image of a single stokes parameter this will plot the image with a colorbar in units of Jy/μas². The plot will accept any kwargs that are a supported by the Makie.Image type an can be queried by typing ?image in the REPL\n\nIf eltype(img) <: StokesParams i.e. full polarized image this will use polimage. The plot will accept any kwargs that are a supported by the PolImage type an can be queried by typing ?polimage in the REPL.\n\ntip: Tip\nTo customize the image, i.e. specify a specific axis we recommend to use image and polimage directly.\n\nwarn: Warn\nTo load this function definition you need to import CairoMakie first\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.polimage","page":"API","title":"VLBISkyModels.polimage","text":"polimage(img::IntensityMap{<:StokesParams};\n            colormap = :bone,\n            colorrange = Makie.automatic,\n            pcolorrange=Makie.automatic,\n            pcolormap=Reverse(:jet1),\n            nvec = 30,\n            min_frac = 0.1,\n            min_pol_frac=0.2,\n            length_norm=1.0,\n            plot_total=true)\n\nPlot a polarized intensity map using the image img.\n\nThe plot follows the conventions from EHTC M87 Paper VII.\n\nThe stokes I image will be plotted with the attributes\n\ncolormap\ncolorrange\nalpha\ncolorscale\n\nThe polarized image will consist of a set. The attribute plot_total changes what polarized quantities are considered.\n\nIf plot_total = true\n\nThe total polarization will be considered and the markers will be given by ellipses.\nThe orientation of the ellipse is equal to the EVPA.\nThe area of the ellipse is proportional to |V|².\nThe semi-major axis is related to the total polarized intensity times the length_norm.\nThe color of the ellipse is given by the fractional total polarization times the\n\nsign of Stokes V.\n\nIf plot_total = false\n\nOnly the linear polarization is considered and the markers will be ticks.\nThe orientation of the ticks is equal to the EVPA.\nThe length of the ticks is equal to the total linear polarized intensity, i.e. √(Q² + U²) times the length_norm.\nThe color of the tick is given by the fractional linear polarization.\n\nAttributes\n\ncolormap: The colormap of the stokes I image. The default is :bone.\ncolorrange: The color range of the stokes I image. The default is (0, maximum(stokes(img, :I)))\npcolorrange: The color range for the polarized image\npcolormap: The colormap used for fractional total/linear polarization markers.\nnvec: The number of polarization vectors to plot\nmin_frac: Any markers with I < min_frac*maximum(I)) will not be plotted\nmin_pol_frac: Any markers with P < min_frac*maximum(P)) where P is the total/linear polarization flux             will not be plotted.\nlength_norm: Specifies the normalization used for the ticks. The default is that the pixel                 with the largest polarization intensity will have a tick length = 10x the                 pixel separation. For an image with a maximum polarized intensity of 10Jy/μas²                 and pixel spacing of 1μas the marker length will be equal to 10μas.\nplot_total: If true plot the total polarization. If false only plot the linear polarization.\n\nwarning: Warning\nThe polarized plotting is intrinsically defined using astronomer/EHT polarization conventions This means that in order to have the polarization ticks plotted in a way that makes sense you need to have xreversed=true when defining your axis.\n\n\n\n\n\n","category":"function"},{"location":"api/#Misc.","page":"API","title":"Misc.","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.center_image\nVLBISkyModels.convolve\nVLBISkyModels.convolve!\nVLBISkyModels.PoincareSphere2Map\nVLBISkyModels.regrid\nVLBISkyModels.rad2μas\nVLBISkyModels.μas2rad","category":"page"},{"location":"api/#VLBISkyModels.center_image","page":"API","title":"VLBISkyModels.center_image","text":"center_image(img::SpatialIntensityMap)\n\ncenters the img such that the centroid of the image is approximately at the origin.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.convolve","page":"API","title":"VLBISkyModels.convolve","text":"convolve(img::IntensityMap, m::AbstractModel)\n\nConvolves an img with a given analytic model m. This is useful for blurring the image with some model. For instance to convolve a image with a Gaussian you would do\n\nconvolve(img, Gaussian())\n\nFor the inplace version of the function see convolve!\n\nNotes\n\nThis method does not automatically pad your image. If there is substantial flux at the boundaries you will start to see artifacts.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.convolve!","page":"API","title":"VLBISkyModels.convolve!","text":"convolve!(img::IntensityMap, m::AbstractModel)\n\nConvolves an img with a given analytic model m. This is useful for blurring the image with some model. For instance to convolve a image with a Gaussian you would do\n\nconvolve!(img, Gaussian())\n\nNotes\n\nThis method does not automatically pad your image. If there is substantial flux at the boundaries you will start to see artifacts.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.PoincareSphere2Map","page":"API","title":"VLBISkyModels.PoincareSphere2Map","text":"PoincareSphere2Map(I, p, X, grid)\nPoincareSphere2Map(I::IntensityMap, p, X)\n\nConstructs an polarized intensity map model using the Poincare parameterization. The arguments are:\n\nI is a grid of fluxes for each pixel.\np is a grid of numbers between 0, 1 and the represent the total fractional polarization\nX is a grid, where each element is 3 numbers that represents the point on the Poincare sphere that is, X[1,1] is a NTuple{3} such that ||X[1,1]|| == 1.\ngrid is the dimensional grid that gives the pixels locations of the intensity map.\n\nnote: Note\nIf I is an IntensityMap then grid is not required since the same grid that was use for I will be used to construct the polarized intensity map\n\nwarning: Warning\nThe return type for this function is a polarized image object, however what we return is not considered to be part of the stable API so it may change suddenly.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.regrid","page":"API","title":"VLBISkyModels.regrid","text":"regrid(img, fovx, fovy, nx, ny)\nregrid(img, fovx, fovy, nx, ny, x0)\nregrid(img, fovx, fovy, nx, ny, x0, y0)\n\n\nRegrids the spatial parts of an image img on the new domain g\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.rad2μas","page":"API","title":"VLBISkyModels.rad2μas","text":"rad2μas(x)\n\nConverts a number from radians to micro-arcseconds (μas)\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.μas2rad","page":"API","title":"VLBISkyModels.μas2rad","text":"μas2rad(x)\n\nConverts a number from micro-arcseconds (μas) to rad\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-(Not-Public-API)","page":"API","title":"Internal (Not Public API)","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.AbstractCache\nVLBISkyModels.scale_uv\nVLBISkyModels.scale_image\nVLBISkyModels.transform_uv\nVLBISkyModels.transform_image\nVLBISkyModels.ThreadedModel\nVLBISkyModels.unpack","category":"page"},{"location":"api/#VLBISkyModels.AbstractCache","page":"API","title":"VLBISkyModels.AbstractCache","text":"abstract type AbstractCache\n\nThis defines an abstract cache that can be used to hold or precompute some computations.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.scale_uv","page":"API","title":"VLBISkyModels.scale_uv","text":"scale_image(model::AbstractModifier, u, u)\n\nReturns a number on how to scale the image visibility at u v for an modified model\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.scale_image","page":"API","title":"VLBISkyModels.scale_image","text":"scale_image(model::AbstractModifier, x, y)\n\nReturns a number of how to to scale the image intensity at x y for an modified model\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.transform_uv","page":"API","title":"VLBISkyModels.transform_uv","text":"transform_uv(model::AbstractModifier, u, u)\n\nReturns a transformed u and v according to the model modifier\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.transform_image","page":"API","title":"VLBISkyModels.transform_image","text":"transform_image(model::AbstractModifier, x, y)\n\nReturns a transformed x and y according to the model modifier\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.ThreadedModel","page":"API","title":"VLBISkyModels.ThreadedModel","text":"ThreadedModel\n\nExperimental model wrapper than enables multi-threading when evaluating intensitymap\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.unpack","page":"API","title":"VLBISkyModels.unpack","text":"unpack(m::AbstractModel)\n\nUnpacks all elements of a struct into a named tuple. Note that this may include elements that aren't direcltly model parameters.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Model-Interface","page":"Model Interface","title":"Model Interface","text":"","category":"section"},{"location":"interface/#Primitive-Geometric-Models","page":"Model Interface","title":"Primitive Geometric Models","text":"","category":"section"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"VLBISkyModels aims to be more modular and extensible than previous VLBI modeling packages. Namely, simple models are composed to construct complicated source morphologies instead of making many different models. This is accomplished with a type and trait-based hierarchy.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Additionally, ComradeBase is a low-dependency version of this package that defines this type and trait hierarchy that users can more easily incorporate into their packages.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"To see how this works, we will go through a simplified implementation of the Gaussian model in VLBISkyModels. The Gaussian model is a simple, compact emission structure model that can constrain the typical characteristic size of an image feature from VLBI data. To construct a Gaussian model, we will first define a struct:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"struct MyGaussian <: VLBISkyModels.AbstractModel end","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Notice that we don't provide any more information about the model, e.g., size, shape, flux, etc. This is because we will use VLBISkyModels's extensive set of modifiers to change the structure of the model. Now a Gaussian is the simplest model structure we can consider. We can consider this Gaussian to be a primitive model. That means a Gaussian is not a combination or modification of an existing model. To tell VLBISkyModels that this is the case, we define the following method:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"# Tell Comrade Gaussian is a primitive model\nComradeBase.isprimitive(::Type{<:MyGaussian}) = IsPrimitive()","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Note that if the Gaussian wasn't a primitive model, we could've used NotPrimitive() instead. Now a Gaussian has an analytic expression in the image and Fourier domain. We can tell VLBISkyModels this by setting:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"# Fourier and image domains are analytic\nVLBISkyModels.visanalytic(::Type{<:MyGaussian}) = IsAnalytic()\nVLBISkyModels.imanalytic(::Type{<:MyGaussian}) = IsAnalytic()","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Finally, we can specify if the model is intrinsically polarized by using the IsPolarized and NotPolarized() trait","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"VLBISkyModels.ispolarized(::Type{<:MyGaussian}) = NotPolarized()","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"note: Note\nThe actual implementation defines the Gaussian to be a subtype of VLBISkyModels.GeometricModel, which automatically defines these methods. However, for models that aren't a subtype of GeometricModel, we assume the image domain IsAnalytic() and the Fourier domain is NotAnalytic().","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Since both the image and visibility domain representation of the Gaussian are analytic, we need to define an intensity_point and visibility_point method. For a Gaussian, these are given by","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"function ComradeBase.intensity_point(::MyGaussian, p)\n    (;X, Y) = p\n    return exp(-(X^2+Y^2)/2)/2π\nend\n\nfunction ComradeBase.visibility_point(::MyGaussian, u, v, time, freq) where {T}\n    return exp(-2π^2*(u^2 + v^2)) + 0im\nend","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Additionally, most models in VLBISkyModels has two additional functions one can implement if possible:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"flux(m::MyGaussian): This defines the flux of a model. If this isn't defined, the model won't have a flux until an image is created. For a Gaussian, the definition is flux(::MyGaussian) = 1.0.\nradialextent(::MyGaussian): This defines the model's default radial extent. For a Gaussian, we will consider the radial extent to be 5σ, so radialextent(::MyGaussian) = 5.0.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"This completely defines the model interface for VLBISkyModels. With this, you can call the usual user API to evaluate, fit, and plot the model. Additionally, we can start talking about adding multiple Gaussians and modifying them. For instance, suppose you want an elliptical Gaussian with a flux of 2 Jy. This can be created by VLBISkyModels as follows:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"using Plots\ngauss = MyGaussian()\nellgauss = 2.0*rotated(stretched(gauss, 1.0, 0.5), π/4)\nfig = plot(gauss, layout=(1,2), size=(800,300))\nplot!(fig[2], ellgauss, size=(800,350))","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"(Image: Image)","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"using Plots\nu = rand(100)*0.5; v=rand(100)*0.5\nvg  = visibilities(gauss, u, v)\nveg = visibilities(ellgauss, u, v)\n\nPlots.scatter(hypot.(u, v), abs.(vg), label=\"Gaussian\")\nPlots.scatter!(hypot.(u, v), abs.(veg), label=\"Elliptical Gaussian\")","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"(Image: Image)","category":"page"},{"location":"interface/#Models-without-an-Analytic-Fourier-Transform","page":"Model Interface","title":"Models without an Analytic Fourier Transform","text":"","category":"section"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Now suppose your model does not have an analytic Fourier transform. In this case, the procedure is very similar to the above, except you define visanalytic(::Type{<:MyModel}) = NotAnalytic(). However, everything else is the same. To compute visibilities, you just then create a ModelImage type using the modelimage function. To see how this see Modeling with non-analytic Fourier transforms.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"EditURL = \"../../../examples/nonanalytic.jl\"","category":"page"},{"location":"examples/nonanalytic/#Modeling-with-non-analytic-Fourier-transforms","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"","category":"section"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"using VLBISkyModels\n\nusing Pkg #hide\nPkg.activate(joinpath(dirname(pathof(VLBISkyModels)), \"..\", \"examples\")) #hide\n\nusing CairoMakie","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"While most of the models implemented in VLBISkyModels have an analytic Fourier transform this is not required. In this notebook we will describe how a user can do Bayesian model fitting with a non-analytic model.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"The ExtendedRing model is an example of a non-analytic model. The image structure is given by","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"I(r) = fracbeta^alpha2pi Gamma(alpha) r^-alpha-2e^-betar","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This can be created as follows","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"m = ExtendedRing(8.0)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"The argument is \\alpha in the above equation. beta is given by (1+alpha).","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This is an example of a ring model that has a substantially different flux profile. Let's plot the image first giving it some unity by applying modify","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"muas = modify(m, Stretch(μas2rad(20.0)))\nimg = intensitymap(muas, μas2rad(100.0),  μas2rad(100.0), 256, 256)\nimageviz(img)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This function does not have a simple analytic Fourier transform, e.g.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"VLBISkyModels.visanalytic(ExtendedRing)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"Therefore, to find the Fourier transform of the image we need to revert to numerical methods. For this notebook we will use the fast Fourier transform or FFT. Specifically we will use FFTW. To compute a numerical Fourier transform we first need to specify the image.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"img = IntensityMap(zeros(256, 256), 10.0, 10.0)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This will serve as our cache to store the image going forward. The next step is to create a model wrapper that holds the model and the image. VLBISkyModels provides the modelimage function to do exactly that","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"mimage = modelimage(m, img, FFTAlg())","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"the alg keyword argument then specifies that we want to use an FFT to compute the Fourier transform. When modelimage is called, the FFT is performed and then we use a bicubic interpolator on the resulting visibilities to construct a continuous representation of the Fourier transform. Once we have this everything else is the same. Namely we can calculatge the VLBI data products in the usual manner i.e.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"u = randn(1000)/2\nv = randn(1000)/2","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"Now we can plot our sampled visibilities","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"vis = visibilities(mimage, (U=u, V=v))\nscatter(hypot.(u, v), real.(vis), label=\"Real\")\nscatter!(hypot.(u, v), imag.(vis), label=\"Imag\")\naxislegend()\ncurrent_figure()","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"We can also directly get the amplitudes using:","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"amp = amplitudes(mimage, (U=u, V=v))\nscatter(hypot.(u, v), amp, label=\"Amplitude\")","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<!– ```@meta CurrentModule = VLBISkyModels","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n# VLBISkyModels\n\n`VLBISkyModels` provides an interface and library for of models that can be used to describe the on-sky emission seen by VLBI interferometers. This used to live in the Bayesian VLBI modeling package [Comrade.jl](https://github.com/ptiede/Comrade.jl) but has been recently separated for modularity within the Julia VLBI community. To see how to use VLBISkyModels within `Comrade` see the their [docs](https://ptiede.github.io/Comrade.jl/stable/).\n\n## Contributing\n\nThis repository has tries to follow [ColPrac](https://github.com/SciML/ColPrac). If you would like to contribute please feel free to open a issue or pull-request.\n\n## Requirements\n\nThe minimum Julia version we require is 1.7. In the future we may increase this as Julia advances.\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@contents Pages = [     \"index.md\",     \"interface.md\",     \"api.md\" ] ```","category":"page"}]
}
