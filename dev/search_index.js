var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Contents","page":"API","title":"Contents","text":"","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/#Model-Definitions","page":"API","title":"Model Definitions","text":"","category":"section"},{"location":"api/#Combinators","page":"API","title":"Combinators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Base.:+(::VLBISkyModels.AbstractModel, ::VLBISkyModels.AbstractModel)\nVLBISkyModels.added\nVLBISkyModels.convolved\nVLBISkyModels.components\nVLBISkyModels.smoothed\nVLBISkyModels.CompositeModel\nVLBISkyModels.AddModel\nVLBISkyModels.ConvolvedModel","category":"page"},{"location":"api/#Base.:+-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractModel}","page":"API","title":"Base.:+","text":"Base.:+(m1::AbstractModel, m2::AbstractModel)\n\nCombine two models to create a composite AddModel. This adds two models pointwise, i.e.\n\njulia> m1 = Gaussian()\njulia> m2 = Disk()\njulia> visibility(m1+m2, 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#VLBISkyModels.added","page":"API","title":"VLBISkyModels.added","text":"added(m1::AbstractModel, m2::AbstractModel)\n\nCombine two models to create a composite AddModel. This adds two models pointwise, i.e.\n\njulia> m1 = Gaussian()\njulia> m2 = Disk()\njulia> visibility(added(m1,m2), 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.convolved","page":"API","title":"VLBISkyModels.convolved","text":"convolved(m1::AbstractModel, m2::AbstractModel)\n\nConvolve two models to create a composite ConvolvedModel.\n\njulia> m1 = Ring()\njulia> m2 = Disk()\njulia> convolved(m1, m2)\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.components","page":"API","title":"VLBISkyModels.components","text":"components(m::AbstractModel)\n\nReturns the model components for a composite model. This will return a Tuple with all the models you have constructed.\n\nExample\n\njulia> m = Gaussian() + Disk()\njulia> components(m)\n(Gaussian{Float64}(), Disk{Float64}())\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.smoothed","page":"API","title":"VLBISkyModels.smoothed","text":"smoothed(m::AbstractModel, σ::Number)\n\nSmooths a model m with a Gaussian kernel with standard deviation σ.\n\nNotes\n\nThis uses convolved to created the model, i.e.\n\njulia> m1 = Disk()\njulia> m2 = Gaussian()\njulia> convolved(m1, m2) == smoothed(m1, 1.0)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.CompositeModel","page":"API","title":"VLBISkyModels.CompositeModel","text":"abstract type CompositeModel{M1, M2} <: ComradeBase.AbstractModel\n\nAbstract type that denotes a composite model. Where we have combined two models together.\n\nImplementation\n\nAny implementation of a composite type must define the following methods:\n\nvisibility_point\nuv_combinator\nimanalytic\nvisanalytic\nComradeBase.intensity_point if model intensity is IsAnalytic\nintensitymap_numeric! if model intensity is NotAnalytic\nintensitymap_numeric if model intensity is NotAnalytic\nflux\nradialextent\n\nIn addition there are additional optional methods a person can define if needed:\n\nintensitymap_analytic! if model intensity is IsAnalytic  (optional)\nintensitymap_analytic if model intensity is IsAnalytic (optional)\nvisibilities_analytic if visanalytic is IsAnalytic (optional)\nvisibilities_numeric  if visanalytic is Not Analytic (optional)\nvisibilities_analytic! if visanalytic is IsAnalytic (optional)\nvisibilities_numeric!  if visanalytic is Not Analytic (optional)\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.AddModel","page":"API","title":"VLBISkyModels.AddModel","text":"struct AddModel{T1, T2} <: VLBISkyModels.CompositeModel{T1, T2}\n\nPointwise addition of two models in the image and visibility domain. An end user should instead call added or Base.+ when constructing a model\n\nExample\n\njulia> m1 = Disk() + Gaussian()\njulia> m2 = added(Disk(), Gaussian()) + Ring()\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ConvolvedModel","page":"API","title":"VLBISkyModels.ConvolvedModel","text":"struct ConvolvedModel{M1, M2} <: VLBISkyModels.CompositeModel{M1, M2}\n\nPointwise addition of two models in the image and visibility domain. An end user should instead call convolved. Also see smoothed(m, σ) for a simplified function that convolves a model m with a Gaussian with standard deviation σ.\n\n\n\n\n\n","category":"type"},{"location":"api/#Geometric-and-Image-Models","page":"API","title":"Geometric and Image Models","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.GeometricModel\nVLBISkyModels.ConcordanceCrescent\nVLBISkyModels.Crescent\nVLBISkyModels.Disk\nVLBISkyModels.SlashedDisk\nVLBISkyModels.ExtendedRing\nVLBISkyModels.Gaussian\nVLBISkyModels.MRing\nVLBISkyModels.Ring\nVLBISkyModels.ParabolicSegment\nVLBISkyModels.ContinuousImage\nVLBISkyModels.ZeroModel\nVLBISkyModels.MultiComponentModel\nVLBISkyModels.PolarizedModel","category":"page"},{"location":"api/#VLBISkyModels.GeometricModel","page":"API","title":"VLBISkyModels.GeometricModel","text":"abstract type GeometricModel{T} <: ComradeBase.AbstractModel\n\nA type that defines it is a geometric model. These are usually primitive models, and are usually analytic in Fourier and the image domain. As a result a user only needs to implement the following methods\n\nvisibility_point\nintensity_point\nradialextent\n\nNote that if the geometric model isn't analytic then the usual methods listed in ComradeBase.AbstractModel for non-analytic models need to be implemented.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ConcordanceCrescent","page":"API","title":"VLBISkyModels.ConcordanceCrescent","text":"struct ConcordanceCrescent{T} <: VLBISkyModels.GeometricModel{T}\n\nCreates the ConcordanceCrescent model, i.e. a flat-top crescent with a displacment and a slash and shadow depth. Note this creates a crescent with unit flux. If you want a different flux please use the renomed modifier.\n\nFields\n\nrouter: Outer radius of the crescent\n\nrinner: Inner radius of the crescent (i.e. inside this radius there is a hole)\n\nshift: Displacment of the inner disk radius\n\nslash: Strength of the linear slash. Note that s∈[0.0,1.0] to ensure positivity in the image.\n\nNotes\n\nUnlike the Gaussian and Disk models this does not create the unit version. In fact, this model could have been created using the Disk and primitives by using VLBISkyModels's model composition functionality.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Crescent","page":"API","title":"VLBISkyModels.Crescent","text":"Creates a Kamruddin and Dexter crescent model. This works by composing two disk models together.\n\nArguments\n\nrouter: The radius of the outer disk\nrinner: The radius of the inner disk\nshift: How much the inner disk radius is shifted (positive is to the right)\nfloor: The floor of the inner disk 0 means the inner intensity is zero and 1 means it is a large disk.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.Disk","page":"API","title":"VLBISkyModels.Disk","text":"Disk{T}() where {T}\n\nTophat disk geometrical model, i.e. the intensity profile\n\n    I(xy) = begincases pi^-1  x^2+y^2  1  0  x^2+y^2 geq 0 endcases\n\ni.e. a unit radius and unit flux disk.\n\nBy default if T isn't given, Disk defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.SlashedDisk","page":"API","title":"VLBISkyModels.SlashedDisk","text":"SlashedDisk{T}(slash::T) where {T}\n\nTophat disk geometrical model, i.e. the intensity profile\n\n    I(xy) = begincases pi^-1  x^2+y^2  1  0  x^2+y^2 geq 0 endcases\n\ni.e. a unit radius and unit flux disk.\n\nBy default if T isn't given, Disk defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ExtendedRing","page":"API","title":"VLBISkyModels.ExtendedRing","text":"struct ExtendedRing{T} <: VLBISkyModels.GeometricModel{T}\n\nA symmetric extended ring whose radial profile follows an inverse gamma distributions.\n\nThe formula in the image domain is given by\n\nI(r,θ) = βᵅrᵅ⁻²exp(-β/r)/2πΓ(α)\n\nwhere α = shape and β = shape+1\n\nNote\n\nWe mainly use this as an example of a non-analytic Fourier transform (although it has a complicated expression)\n\nFields\n\nshape: shape of the radial distribution\n\nNote that if T isn't specified at construction then it defaults to Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Gaussian","page":"API","title":"VLBISkyModels.Gaussian","text":"struct Gaussian{T} <: VLBISkyModels.GeometricModel{T}\n\nGaussian with unit standard deviation and flux.\n\nBy default if T isn't given, Gaussian defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.MRing","page":"API","title":"VLBISkyModels.MRing","text":"struct MRing{T, V<:Union{AbstractArray{T, 1}, Tuple{Vararg{T, N}} where {N, T}}} <: VLBISkyModels.GeometricModel{T}\n\nm-ring geometric model. This is a infinitely thin unit flux delta ring whose angular structure is given by a Fourier expansion. That is,\n\nI(r,θ) = (2π)⁻¹δ(r-1)∑ₙ(αₙcos(nθ) - βₙsin(nθ))\n\nThe N in the type defines the order of the Fourier expansion.\n\nFields\n\nα: Real Fourier mode coefficients\n\nβ: Imaginary Fourier mode coefficients\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Ring","page":"API","title":"VLBISkyModels.Ring","text":"struct Ring{T} <: VLBISkyModels.GeometricModel{T}\n\nA infinitely thin ring model, whose expression in the image domain is     I(r,θ) = δ(r - 1)/2π i.e. a unit radius and flux delta ring.\n\nBy default if T isn't given, Gaussian defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ParabolicSegment","page":"API","title":"VLBISkyModels.ParabolicSegment","text":"struct ParabolicSegment{T} <: VLBISkyModels.GeometricModel{T}\n\nA infinitely thin parabolic segment in the image domain. The segment is centered at zero, with roots ±1 and a yintercept of 1.\n\nNote that if T isn't specified at construction then it defaults to Float64.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ContinuousImage","page":"API","title":"VLBISkyModels.ContinuousImage","text":"ContinuousImage{A<:IntensityMap, P} <: AbstractModel\nContinuousImage(img::Intensitymap, kernel)\n\nThe basic continuous image model for VLBISkyModels. This expects a IntensityMap style object as its imag as well as a image kernel or pulse that allows you to evaluate the image at any image and visibility location. The image model is\n\nI(x,y) = ∑ᵢ Iᵢⱼ κ(x-xᵢ, y-yᵢ)\n\nwhere Iᵢⱼ are the flux densities of the image img and κ is the intensity function for the kernel.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ZeroModel","page":"API","title":"VLBISkyModels.ZeroModel","text":"struct ZeroModel{T} <: ComradeBase.AbstractModel\n\nDefines a model that is empty that is it return zero for everything.\n\nNotes\n\nThis returns 0 by using FillArrays so everything should be non-allocating\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.MultiComponentModel","page":"API","title":"VLBISkyModels.MultiComponentModel","text":"MultiComponentModel(beam::AbstractModel, fluxes::AbstractVector, x::AbstractVector, y::AbstractVector)\n\nBuild a model with a base model type beam where fluxes, x, y corresond to the flux, and positions of the components. This can be used to easily construct clean like models.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.PolarizedModel","page":"API","title":"VLBISkyModels.PolarizedModel","text":"struct PolarizedModel{TI, TQ, TU, TV} <: ComradeBase.AbstractPolarizedModel\n\nWrapped model for a polarized model. This uses the stokes representation of the image.\n\nFields\n\nI: Stokes I model\n\nQ: Stokes Q Model\n\nU: Stokes U Model\n\nV: Stokes V Model\n\n\n\n\n\n","category":"type"},{"location":"api/#Image-Pulses","page":"API","title":"Image Pulses","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.Pulse\nVLBISkyModels.DeltaPulse\nVLBISkyModels.BSplinePulse\nVLBISkyModels.RaisedCosinePulse\nVLBISkyModels.BicubicPulse\nVLBISkyModels.Butterworth","category":"page"},{"location":"api/#VLBISkyModels.Pulse","page":"API","title":"VLBISkyModels.Pulse","text":"Pulse\n\nPixel response function for a radio image model. This makes a discrete sampling continuous by picking a certain smoothing kernel for the image.\n\nNotes\n\nTo see the implemented Pulses please use the subtypes function i.e. subtypes(Pulse)\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.DeltaPulse","page":"API","title":"VLBISkyModels.DeltaPulse","text":"struct DeltaPulse{T} <: VLBISkyModels.Pulse\n\nA dirac comb pulse function. This means the image is just the dicrete Fourier transform\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.BSplinePulse","page":"API","title":"VLBISkyModels.BSplinePulse","text":"$(TYPEDEF)\n\nUses the basis spline (BSpline) kernel of order N. These are the kernel that come from recursively convolving the tophat kernel\n\n    B_0(x) = begincases 1  x  1  0  otherwise endcases\n\nN times.\n\nNotes\n\nBSpline kernels have a number of nice properties:\n\nSimple frequency response sinc(u2)^N\npreserve total intensity\n\nFor N>1 these kernels aren't actually interpolation kernels however, this doesn't matter for us.\n\nCurrently only the 0,1,3 order kernels are implemented.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.RaisedCosinePulse","page":"API","title":"VLBISkyModels.RaisedCosinePulse","text":"struct RaisedCosinePulse{T} <: VLBISkyModels.Pulse\n\nRaisedCosinePulse()\nRaisedCosinePulse(rolloff)\n\nRaised cosine pulse function. This tends to be a very flat response, where the roll off controls the speed of decay. By default we set rolloff = 0.5.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.BicubicPulse","page":"API","title":"VLBISkyModels.BicubicPulse","text":"struct BicubicPulse{T} <: VLBISkyModels.Pulse\n\nBicubicPulse(b = 0.5)\n\nThe bicubic pulse for imaging. This pulse tends to have a flat spectrum but for most values of b can produce negative intensities in an image. This is the pulse used in Broderick et al. 2020.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Butterworth","page":"API","title":"VLBISkyModels.Butterworth","text":"Butterworth{N}()\nButterworth{N, T}()\n\nConstruct a model that corresponds to the Butterworth filter of order N. The type of the output is given by T and if not given defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#Model-Image-(non-analytic-FFT)","page":"API","title":"Model Image (non analytic FFT)","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.create_cache\nVLBISkyModels.update_cache\nVLBISkyModels.modelimage\nVLBISkyModels.uviterator\nVLBISkyModels.fouriermap\nVLBISkyModels.ModelImage\nVLBISkyModels.DFTAlg\nVLBISkyModels.FFTAlg\nVLBISkyModels.FFTCache\nVLBISkyModels.NFFTAlg\nVLBISkyModels.NUFTCache\nVLBISkyModels.ObservedNUFT","category":"page"},{"location":"api/#VLBISkyModels.create_cache","page":"API","title":"VLBISkyModels.create_cache","text":"create_cache(alg::AbstractFourierTransform, img::AbstractIntensityMap)\n\nCreates a Fourier transform cache for a img using algorithm alg. For non-analytic visibility models this can significantly speed up computations.\n\nExamples\n\njulia> u,v = rand(100), rand(100)\njulia> cache = create_cache(DFTAlg(u, v), IntensityMap(randn(50,50), 10.0, 10.0))\njulia> cache = create_cache(NFFTAlg(u, v), IntensityMap(randn(50,50), 10.0, 10.0))\njulia> cache = create_cache(FFTAlg(), IntensityMap(randn(50,50), 10.0, 10.0))\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.update_cache","page":"API","title":"VLBISkyModels.update_cache","text":"update_cache(cache, img)\n\nUpdate the Fourier transform cache. This will reuse an FFT/NFFT plan saving some computational time.\n\nNote\n\nThis is an intenal method than an end user shouldn't have to usually call.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.modelimage","page":"API","title":"VLBISkyModels.modelimage","text":"modelimage(model::AbstractModel, image::AbstractIntensityMap, alg=FFTAlg())\n\nConstruct a ModelImage from a model, image and the optionally specified visibility algorithm alg\n\nNotes\n\nFor analytic models this is a no-op and returns the model. For non-analytic models this creates a ModelImage object which uses alg to compute the non-analytic Fourier transform.\n\n\n\n\n\nmodelimage(model, cache::AbstractCach))\n\nConstruct a ModelImage from the model and using a precompute Fourier transform cache. You can optionally specify th which will compute the internal image buffer using the`.\n\nExample\n\njulia> m = ExtendedRing(10.0)\njulia> cache = create_cache(DFTAlg(), IntensityMap(zeros(128, 128), 50.0, 50.0)) # used threads to make the image\njulia> mimg = modelimage(m, cache, true)\n\nNotes\n\nFor analytic models this is a no-op and returns the model.\n\n\n\n\n\nmodelimage(m;\n           fovx=2*radialextent(m),\n           fovy=2*radialextent(m),\n           nx=512,\n           ny=512,\n           alg=FFTAlg(),\n           pulse=ComradeBase.DeltaPulse(),\n            )\n\nConstruct a ModelImage where just the model m is specified.\n\nIf fovx or fovy aren't given modelimage will guess a reasonable field of view based on the radialextent function. nx and ny are the number of pixels in the x and y direction. The pulse is the pulse used for the image and alg\n\nNotes\n\nFor analytic models this is a no-op and returns the model.\n\n\n\n\n\nmodelimage(img::ContinuousImage, alg=NFFTAlg())\n\nCreate a model image directly using an image, i.e. treating it as the model. You can optionally specify the Fourier transform algorithm using alg\n\n\n\n\n\nmodelimage(img::ContinuousImage, cache::AbstractCache)\n\nCreate a model image directly using an image, i.e. treating it as the model. Additionally reuse a previously compute image cache. This can be used when directly modeling an image of a fixed size and number of pixels.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.uviterator","page":"API","title":"VLBISkyModels.uviterator","text":"uviterator(nx, dx, ny dy)\n\nConstruct the u,v iterators for the Fourier transform of the image with pixel sizes dx, dy and number of pixels nx, ny\n\nIf you are extending Fourier transform stuff please use these functions to ensure that the centroid is being properly computed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.fouriermap","page":"API","title":"VLBISkyModels.fouriermap","text":"fouriermap(m, x)\n\nCreate a Fourier or visibility map of a model m where the image is specified in the image domain by the pixel locations x and y\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.ModelImage","page":"API","title":"VLBISkyModels.ModelImage","text":"struct ModelImage{M, I, C} <: VLBISkyModels.AbstractModelImage{M}\n\nContainer for non-analytic model that contains a image cache which will hold the image, a Fourier transform cache, which usually an instance of a <: FourierCache.\n\nNote\n\nThis is an internal implementation detail that shouldn't usually be called directly. Instead the user should use the exported function modelimage, for example\n\nusing Comrade\nm = ExtendedRing(20.0, 5.0)\n\n# This creates an version where the image is dynamically specified according to the\n# radial extent of the image\nmimg = modelimage(m) # you can also optionally pass the number of pixels nx and ny\n\n# Or you can create an IntensityMap\nimg = intensitymap(m, 100.0, 100.0, 512, 512)\nmimg = modelimage(m, img)\n\n# Or precompute a cache\ncache = create_cache(FFTAlg(), img)\nmimg = modelimage(m, cache)\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.DFTAlg","page":"API","title":"VLBISkyModels.DFTAlg","text":"DFTAlg\n\nUses a discrete fourier transform. This is not very efficient for larger images. In those cases  NFFTAlg or FFTAlg are more reasonable. For small images this is a reasonable choice especially since it's easy to define derivatives.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.FFTAlg","page":"API","title":"VLBISkyModels.FFTAlg","text":"struct FFTAlg <: VLBISkyModels.FourierTransform\n\nUse an FFT to compute the approximate numerical visibilities of a model. For a DTFT see DFTAlg or for an NFFT NFFTAlg\n\nFields\n\npadfac: The amount to pad the image by. Note we actually round up to the nearest factor of 2, but this will be improved in the future to use small primes\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.FFTCache","page":"API","title":"VLBISkyModels.FFTCache","text":"struct FFTCache{A<:FFTAlg, P, I, Pu, S} <: VLBISkyModels.AbstractCache\n\nThe cache used when the FFT algorithm is used to compute visibilties. This is an internal type and is not part of the public API\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.NFFTAlg","page":"API","title":"VLBISkyModels.NFFTAlg","text":"NFFTAlg\n\nUses a non-uniform FFT to compute the visibilities. You can optionally pass uv which are the uv positions you will compute the NFFT at. This can allow for the NFFT plan to be cached improving performance\n\nFields\n\npadfac: Amount to pad the image\n\nm: Kernel size parameters. This controls the accuracy of NFFT you do not usually need to change this\n\nσ: Over sampling factor. This controls the accuracy of NFFT you do not usually need to change this.\n\nwindow: Window function for the NFFT. You do not usually need to change this\n\nprecompute: NFFT interpolation algorithm.\n\nblocking: Flag block partioning should be used to speed up computation\n\nsortNodes: Flag if the node should be sorted in a lexicographic way\n\nstoreDeconvolutionIdx: Flag if the deconvolve indices should be stored, Currently required for GPU\n\nfftflags: Flag passed to inner AbstractFFT. The fastest FFTW is FFTW.MEASURE but takes the longest to precompute\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.NUFTCache","page":"API","title":"VLBISkyModels.NUFTCache","text":"struct NUFTCache{A, P, M, PI, I} <: VLBISkyModels.AbstractCache\n\nInternal type used to store the cache for a non-uniform Fourier transform (NUFT).\n\nThe user should instead create this using the create_cache function.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ObservedNUFT","page":"API","title":"VLBISkyModels.ObservedNUFT","text":"struct ObservedNUFT{A<:VLBISkyModels.NUFT, T} <: VLBISkyModels.NUFT\n\nContainer type for a non-uniform Fourier transform (NUFT). This stores the uv-positions that the model will be sampled at in the Fourier domain, allowing certain transformtion factors (e.g., NUFT matrix) to be cached.\n\nThis is an internal type, an end user should instead create this using NFFTAlg or DFTAlg.\n\n\n\n\n\n","category":"type"},{"location":"api/#Modifiers","page":"API","title":"Modifiers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.modify\nVLBISkyModels.basemodel\nVLBISkyModels.unmodified\nVLBISkyModels.renormed\nVLBISkyModels.rotated\nVLBISkyModels.posangle\nVLBISkyModels.shifted\nVLBISkyModels.stretched\nVLBISkyModels.ModifiedModel\nVLBISkyModels.ModelModifier\nVLBISkyModels.Stretch\nVLBISkyModels.Shift\nVLBISkyModels.Rotate\nVLBISkyModels.Renormalize","category":"page"},{"location":"api/#VLBISkyModels.modify","page":"API","title":"VLBISkyModels.modify","text":"modify(m::AbstractModel, transforms...)\n\nModify a given model using the set of transforms. This is the most general function that allows you to apply a sequence of model transformation for example\n\nmodify(Gaussian(), Stretch(2.0, 1.0), Rotate(π/4), Shift(1.0, 2.0), Renorm(2.0))\n\nwill create a asymmetric Gaussian with position angle π/4 shifted to the position (1.0, 2.0) with a flux of 2 Jy. This is similar to Flux's chain.\n\n\n\n\n\nmodify(img::IntensityMap, transforms...)\n\nThis modifies the img by applying the transforms... returning a transformed IntensityMap\n\nnote: Note\n\n\nUnlike when modify is applied to a <:AbstractModel this returns an already modified image.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.basemodel","page":"API","title":"VLBISkyModels.basemodel","text":"basemodel(model::ModifiedModel)\n\nReturns the ModifiedModel with the last transformation stripped.\n\nExample\n\njulia> basemodel(stretched(Disk(), 1.0, 2.0)) == Disk()\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.unmodified","page":"API","title":"VLBISkyModels.unmodified","text":"unmodified(model::ModifiedModel)\n\nReturns the un-modified model\n\nExample\n\njulia> m = stretched(rotated(Gaussian(), π/4), 2.0, 1.0)\njulia> umodified(m) == Gaussian()\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.renormed","page":"API","title":"VLBISkyModels.renormed","text":"renormed(model, f)\n\n\nRenormalizes the model m to have total flux f*flux(m). This can also be done directly by calling Base.:* i.e.,\n\njulia> renormed(m, f) == f*M\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.rotated","page":"API","title":"VLBISkyModels.rotated","text":"rotated(model, ξ)\n\n\nRotates the model by an amount ξ in radians in the clockwise direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.posangle","page":"API","title":"VLBISkyModels.posangle","text":"posangle(model)\n\n\nReturns the rotation angle of the rotated model\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.shifted","page":"API","title":"VLBISkyModels.shifted","text":"shifted(model, Δx, Δy)\n\n\nShifts the model m in the image domain by an amount Δx,Δy in the x and y directions respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.stretched","page":"API","title":"VLBISkyModels.stretched","text":"stretched(model, α, β)\n\n\nStretches the model m according to the formula     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.ModifiedModel","page":"API","title":"VLBISkyModels.ModifiedModel","text":"struct ModifiedModel{M<:ComradeBase.AbstractModel, T<:Tuple} <: ComradeBase.AbstractModel\n\nContainer type for models that have been transformed in some way. For a list of potential modifiers or transforms see subtypes(ModelModifiers).\n\nFields\n\nmodel: base model\ntransform: model transforms\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.ModelModifier","page":"API","title":"VLBISkyModels.ModelModifier","text":"abstract type ModelModifier{T}\n\nGeneral type for a model modifier. These transform any model using simple Fourier transform properties. To modify a model you can use the ModifiedModel constructor or the modify function.\n\njulia> visanalytic(stretched(Disk(), 2.0, 2.0)) == visanalytic(Disk())\ntrue\n\nTo implement a model transform you need to specify the following methods:\n\ntransform_uv\ntransform_image\nscale_uv\nscale_image\nradialextent\n\nSee thee docstrings of those methods for guidance on implementation details.\n\nAdditionally these methods assume the modifiers are of the form\n\nI(x,y) -> fᵢ(x,y)I(gᵢ(x,y)) V(u,v) -> fᵥ(u,v)V(gᵥ(u,v))\n\nwhere g are the transformimage/uv functions and f are the scaleimage/uv function.\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Stretch","page":"API","title":"VLBISkyModels.Stretch","text":"Stretch(α, β)\nStretch(r)\n\nStretched the model in the x and y directions, i.e. the new intensity is     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.\n\nExample\n\njulia> modify(Gaussian(), Stretch(2.0)) == stretched(Gaussian(), 2.0, 1.0)\ntrue\n\nIf only a single argument is given it assumes the same stretch is applied in both direction.\n\njulia> Stretch(2.0) == Stretch(2.0, 2.0)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Shift","page":"API","title":"VLBISkyModels.Shift","text":"struct Shift{T} <: VLBISkyModels.ModelModifier{T}\n\nShifts the model by Δx units in the x-direction and Δy units in the y-direction.\n\nExample\n\njulia> modify(Gaussian(), Shift(2.0, 1.0)) == shifted(Gaussian(), 2.0, 1.0)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Rotate","page":"API","title":"VLBISkyModels.Rotate","text":"Rotate(ξ)\n\nType for the rotated model. This is more fine grained constrol of rotated model.\n\nExample\n\njulia> modify(Gaussian(), Rotate(2.0)) == rotated(Gaussian(), 2.0)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#VLBISkyModels.Renormalize","page":"API","title":"VLBISkyModels.Renormalize","text":"struct Renormalize{T} <: VLBISkyModels.ModelModifier{T}\n\nRenormalizes the flux of the model to the new value scale*flux(model). We have also overloaded the Base.:* operator as syntactic sugar although I may get rid of this.\n\nExample\n\njulia> modify(Gaussian(), Renormalize(2.0)) == 2.0*Gaussian()\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#Model-Evaluation","page":"API","title":"Model Evaluation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"For more docstrings on how to evaluate models see ComradeBase.","category":"page"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.amplitude\nVLBISkyModels.amplitudes\nVLBISkyModels.bispectra\nVLBISkyModels.bispectrum\nVLBISkyModels.closure_phase\nVLBISkyModels.closure_phases\nVLBISkyModels.logclosure_amplitude\nVLBISkyModels.logclosure_amplitudes\nVLBISkyModels.visibility","category":"page"},{"location":"api/#VLBISkyModels.amplitude","page":"API","title":"VLBISkyModels.amplitude","text":"amplitude(model, p)\n\nComputes the visibility amplitude of model m at the coordinate p. The coordinate p is expected to have the properties U, V, and sometimes Ti and Fr.\n\nIf you want to compute the amplitudes at a large number of positions consider using the amplitudes function.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.amplitudes","page":"API","title":"VLBISkyModels.amplitudes","text":"amplitudes(m::AbstractModel, u::AbstractArray, v::AbstractArray)\n\nComputes the visibility amplitudes of the model m at the coordinates p. The coordinates p are expected to have the properties U, V, and sometimes Ti and Fr.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.bispectra","page":"API","title":"VLBISkyModels.bispectra","text":"bispectra(m, p1, p2, p3)\n\nComputes the closure phases of the model m at the triangles p1, p2, p3, where pi are coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.bispectrum","page":"API","title":"VLBISkyModels.bispectrum","text":"bispectrum(model, p1, p2, p3)\n\nComputes the complex bispectrum of model m at the uv-triangle p1 -> p2 -> p3\n\nIf you want to compute the bispectrum over a number of triangles consider using the bispectra function.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.closure_phase","page":"API","title":"VLBISkyModels.closure_phase","text":"closure_phase(model, p1, p2, p3, p4)\n\nComputes the closure phase of model m at the uv-triangle u1,v1 -> u2,v2 -> u3,v3\n\nIf you want to compute closure phases over a number of triangles consider using the closure_phases function.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.closure_phases","page":"API","title":"VLBISkyModels.closure_phases","text":"closure_phases(m,\n               p1::AbstractArray\n               p2::AbstractArray\n               p3::AbstractArray\n               )\n\nComputes the closure phases of the model m at the triangles p1, p2, p3, where pi are coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.logclosure_amplitude","page":"API","title":"VLBISkyModels.logclosure_amplitude","text":"logclosure_amplitude(model, p1, p2, p3, p4)\n\nComputes the log-closure amplitude of model m at the uv-quadrangle u1,v1 -> u2,v2 -> u3,v3 -> u4,v4 using the formula\n\nC = logleftfracV(u1v1)V(u2v2)V(u3v3)V(u4v4)right\n\nIf you want to compute log closure amplitudes over a number of triangles consider using the logclosure_amplitudes function.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.logclosure_amplitudes","page":"API","title":"VLBISkyModels.logclosure_amplitudes","text":"logclosure_amplitudes(m::AbstractModel,\n                      p1,\n                      p2,\n                      p3,\n                      p4\n                     )\n\nComputes the log closure amplitudes of the model m at the quadrangles p1, p2, p3, p4.\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.visibility","page":"API","title":"VLBISkyModels.visibility","text":"visibility(mimg, p)\n\nComputes the complex visibility of model m at coordinates p. p corresponds to the coordinates of the model. These need to have the properties U, V and sometimes Ti for time and Fr for frequency.\n\nNotes\n\nIf you want to compute the visibilities at a large number of positions consider using the visibilities.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-(Not-Public-API)","page":"API","title":"Internal (Not Public API)","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VLBISkyModels.scale_uv\nVLBISkyModels.scale_image\nVLBISkyModels.transform_uv\nVLBISkyModels.transform_image\nVLBISkyModels.ThreadedModel","category":"page"},{"location":"api/#VLBISkyModels.scale_uv","page":"API","title":"VLBISkyModels.scale_uv","text":"scale_image(model::AbstractModifier, u, u)\n\nReturns a number on how to scale the image visibility at u v for an modified model\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.scale_image","page":"API","title":"VLBISkyModels.scale_image","text":"scale_image(model::AbstractModifier, x, y)\n\nReturns a number of how to to scale the image intensity at x y for an modified model\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.transform_uv","page":"API","title":"VLBISkyModels.transform_uv","text":"transform_uv(model::AbstractModifier, u, u)\n\nReturns a transformed u and v according to the model modifier\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.transform_image","page":"API","title":"VLBISkyModels.transform_image","text":"transform_image(model::AbstractModifier, x, y)\n\nReturns a transformed x and y according to the model modifier\n\n\n\n\n\n","category":"function"},{"location":"api/#VLBISkyModels.ThreadedModel","page":"API","title":"VLBISkyModels.ThreadedModel","text":"ThreadedModel\n\nExperimental model wrapper than enables multi-threading when evaluating intensitymap\n\n\n\n\n\n","category":"type"},{"location":"interface/#Model-Interface","page":"Model Interface","title":"Model Interface","text":"","category":"section"},{"location":"interface/#Primitive-Geometric-Models","page":"Model Interface","title":"Primitive Geometric Models","text":"","category":"section"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"VLBISkyModels aims to be more modular and extensible than previous VLBI modeling packages. Namely, simple models are composed to construct complicated source morphologies instead of making many different models. This is accomplished with a type and trait-based hierarchy.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Additionally, ComradeBase is a low-dependency version of this package that defines this type and trait hierarchy that users can more easily incorporate into their packages.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"To see how this works, we will go through a simplified implementation of the Gaussian model in VLBISkyModels. The Gaussian model is a simple, compact emission structure model that can constrain the typical characteristic size of an image feature from VLBI data. To construct a Gaussian model, we will first define a struct:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"struct MyGaussian <: VLBISkyModels.AbstractModel end","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Notice that we don't provide any more information about the model, e.g., size, shape, flux, etc. This is because we will use VLBISkyModels's extensive set of modifiers to change the structure of the model. Now a Gaussian is the simplest model structure we can consider. We can consider this Gaussian to be a primitive model. That means a Gaussian is not a combination or modification of an existing model. To tell VLBISkyModels that this is the case, we define the following method:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"# Tell Comrade Gaussian is a primitive model\nComradeBase.isprimitive(::Type{<:MyGaussian}) = IsPrimitive()","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Note that if the Gaussian wasn't a primitive model, we could've used NotPrimitive() instead. Now a Gaussian has an analytic expression in the image and Fourier domain. We can tell VLBISkyModels this by setting:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"# Fourier and image domains are analytic\nVLBISkyModels.visanalytic(::Type{<:MyGaussian}) = IsAnalytic()\nVLBISkyModels.imanalytic(::Type{<:MyGaussian}) = IsAnalytic()","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Finally, we can specify if the model is intrinsically polarized by using the IsPolarized and NotPolarized() trait","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"VLBISkyModels.ispolarized(::Type{<:MyGaussian}) = NotPolarized()","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"note: Note\nThe actual implementation defines the Gaussian to be a subtype of VLBISkyModels.GeometricModel, which automatically defines these methods. However, for models that aren't a subtype of GeometricModel, we assume the image domain IsAnalytic() and the Fourier domain is NotAnalytic().","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Since both the image and visibility domain representation of the Gaussian are analytic, we need to define an intensity_point and visibility_point method. For a Gaussian, these are given by","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"function ComradeBase.intensity_point(::MyGaussian, p)\n    (;X, Y) = p\n    return exp(-(X^2+Y^2)/2)/2π\nend\n\nfunction ComradeBase.visibility_point(::MyGaussian, u, v, time, freq) where {T}\n    return exp(-2π^2*(u^2 + v^2)) + 0im\nend","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Additionally, most models in VLBISkyModels has two additional functions one can implement if possible:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"flux(m::MyGaussian): This defines the flux of a model. If this isn't defined, the model won't have a flux until an image is created. For a Gaussian, the definition is flux(::MyGaussian) = 1.0.\nradialextent(::MyGaussian): This defines the model's default radial extent. For a Gaussian, we will consider the radial extent to be 5σ, so radialextent(::MyGaussian) = 5.0.","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"This completely defines the model interface for VLBISkyModels. With this, you can call the usual user API to evaluate, fit, and plot the model. Additionally, we can start talking about adding multiple Gaussians and modifying them. For instance, suppose you want an elliptical Gaussian with a flux of 2 Jy. This can be created by VLBISkyModels as follows:","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"gauss = MyGaussian()\nellgauss = 2.0*rotated(stretched(gauss, 1.0, 0.5), π/4)\nfig = plot(gauss, layout=(1,2), size=(800,300))\nplot!(fig[2], ellgauss, size=(800,350))","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"(Image: Image)","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"u = rand(100)*0.5; v=rand(100)*0.5\nvg  = visibilities(gauss, u, v)\nveg = visibilities(ellgauss, u, v)\n\nscatter(hypot.(u, v), abs.(vg), label=\"Gaussian\")\nscatter!(hypot.(u, v), abs.(veg), label=\"Elliptical Gaussian\")","category":"page"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"(Image: Image)","category":"page"},{"location":"interface/#Models-without-an-Analytic-Fourier-Transform","page":"Model Interface","title":"Models without an Analytic Fourier Transform","text":"","category":"section"},{"location":"interface/","page":"Model Interface","title":"Model Interface","text":"Now suppose your model does not have an analytic Fourier transform. In this case, the procedure is very similar to the above, except you define visanalytic(::Type{<:MyModel}) = NotAnalytic(). However, everything else is the same. To compute visibilities, you just then create a ModelImage type using the modelimage function. To see how this see Modeling with non-analytic Fourier transforms.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"EditURL = \"https://github.com/EHTJulia/VLBISkyModels.jl/blob/main/examples/nonanalytic.jl\"","category":"page"},{"location":"examples/nonanalytic/#Modeling-with-non-analytic-Fourier-transforms","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"","category":"section"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"using VLBISkyModels\n\nusing Pkg #hide\nPkg.activate(joinpath(dirname(pathof(VLBISkyModels)), \"..\", \"examples\")) #hide\n\nusing Plots","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"While most of the models implemented in VLBISkyModels have an analytic Fourier transform this is not required. In this notebook we will describe how a user can do Bayesian model fitting with a non-analytic model.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"The ExtendedRing model is an example of a non-analytic model. The image structure is given by","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"I(r) = fracbeta^alpha2pi Gamma(alpha) r^-alpha-2e^-betar","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This can be created as follows","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"m = ExtendedRing(8.0)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"The argument is \\alpha in the above equation. beta is given by (1+alpha).","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This is an example of a ring model that has a substantially different flux profile.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"plot(m, xlims=(-5.0, 5.0), ylims=(-5.0, 5.0), uvscale=identity)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This function does not have a simple analytic Fourier transform, e.g.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"VLBISkyModels.visanalytic(ExtendedRing)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"Therefore, to find the Fourier transform of the image we need to revert to numerical methods. For this notebook we will use the fast Fourier transform or FFT. Specifically we will use FFTW. To compute a numerical Fourier transform we first need to specify the image.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"image = IntensityMap(zeros(256, 256), 10.0, 10.0)","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This will serve as our cache to store the image going forward. The next step is to create a model wrapper that holds the model and the image. VLBISkyModels provides the modelimage function to do exactly that","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"mimage = modelimage(m, image, FFTAlg())","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"the alg keyword argument then specifies that we want to use an FFT to compute the Fourier transform. When modelimage is called, the FFT is performed and then we use a bicubic interpolator on the resulting visibilities to construct a continuous representation of the Fourier transform. Once we have this everything else is the same. Namely we can calculatge the VLBI data products in the usual manner i.e.","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"u = randn(1000)/2\nv = randn(1000)/2","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"Now we can plot our sampled visibilities","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"vis = visibilities(mimage, (U=u, V=v))\nscatter(hypot.(u, v), real.(vis), label=\"Real\")\nscatter!(hypot.(u, v), imag.(vis), label=\"Imag\")","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"We can also directly get the amplitudes using:","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"amp = amplitudes(mimage, (U=u, V=v))\nscatter(hypot.(u, v), amp, label=\"Amplitude\")","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"","category":"page"},{"location":"examples/nonanalytic/","page":"Modeling with non-analytic Fourier transforms","title":"Modeling with non-analytic Fourier transforms","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = VLBISkyModels","category":"page"},{"location":"#VLBISkyModels","page":"Home","title":"VLBISkyModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"VLBISkyModels provides an interface and library for of models that can be used to describe the on-sky emission seen by VLBI interferometers. This used to live in the Bayesian VLBI modeling package Comrade.jl but has been recently separated for modularity within the Julia VLBI community. To see how to use VLBISkyModels within Comrade see the their docs.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This repository has tries to follow ColPrac. If you would like to contribute please feel free to open a issue or pull-request.","category":"page"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The minimum Julia version we require is 1.7. In the future we may increase this as Julia advances.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"interface.md\",\n    \"api.md\"\n]","category":"page"}]
}
