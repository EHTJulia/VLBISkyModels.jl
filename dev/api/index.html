<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · VLBISkyModels.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">VLBISkyModels.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../interface/">Model Interface</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Model-Definitions"><span>Model Definitions</span></a></li><li><a class="tocitem" href="#Internal-(Not-Public-API)"><span>Internal (Not Public API)</span></a></li></ul></li><li><a class="tocitem" href="../examples/nonanalytic/">Modeling with non-analytic Fourier transforms</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/main/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><h2 id="Model-Definitions"><a class="docs-heading-anchor" href="#Model-Definitions">Model Definitions</a><a id="Model-Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Definitions" title="Permalink"></a></h2><h3 id="Combinators"><a class="docs-heading-anchor" href="#Combinators">Combinators</a><a id="Combinators-1"></a><a class="docs-heading-anchor-permalink" href="#Combinators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractModel}" href="#Base.:+-Tuple{ComradeBase.AbstractModel, ComradeBase.AbstractModel}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:+(m1::AbstractModel, m2::AbstractModel)</code></pre><p>Combine two models to create a composite <a href="#VLBISkyModels.AddModel"><code>AddModel</code></a>. This adds two models pointwise, i.e.</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Gaussian()
julia&gt; m2 = Disk()
julia&gt; visibility(m1+m2, 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/combinators.jl#L110-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.added" href="#VLBISkyModels.added"><code>VLBISkyModels.added</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">added(m1::AbstractModel, m2::AbstractModel)</code></pre><p>Combine two models to create a composite <a href="#VLBISkyModels.AddModel"><code>AddModel</code></a>. This adds two models pointwise, i.e.</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Gaussian()
julia&gt; m2 = Disk()
julia&gt; visibility(added(m1,m2), 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/combinators.jl#L95-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.convolved" href="#VLBISkyModels.convolved"><code>VLBISkyModels.convolved</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convolved(m1::AbstractModel, m2::AbstractModel)</code></pre><p>Convolve two models to create a composite <a href="#VLBISkyModels.ConvolvedModel"><code>ConvolvedModel</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Ring()
julia&gt; m2 = Disk()
julia&gt; convolved(m1, m2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/combinators.jl#L255-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.components" href="#VLBISkyModels.components"><code>VLBISkyModels.components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">components(m::AbstractModel)</code></pre><p>Returns the model components for a composite model. This will return a Tuple with all the models you have constructed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = Gaussian() + Disk()
julia&gt; components(m)
(Gaussian{Float64}(), Disk{Float64}())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/combinators.jl#L143-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.smoothed" href="#VLBISkyModels.smoothed"><code>VLBISkyModels.smoothed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">smoothed(m::AbstractModel, σ::Number)</code></pre><p>Smooths a model <code>m</code> with a Gaussian kernel with standard deviation <code>σ</code>.</p><p><strong>Notes</strong></p><p>This uses <a href="#VLBISkyModels.convolved"><code>convolved</code></a> to created the model, i.e.</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Disk()
julia&gt; m2 = Gaussian()
julia&gt; convolved(m1, m2) == smoothed(m1, 1.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/combinators.jl#L268-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.CompositeModel" href="#VLBISkyModels.CompositeModel"><code>VLBISkyModels.CompositeModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type CompositeModel{M1, M2} &lt;: ComradeBase.AbstractModel</code></pre><p>Abstract type that denotes a composite model. Where we have combined two models together.</p><p><strong>Implementation</strong></p><p>Any implementation of a composite type must define the following methods:</p><ul><li>visibility_point</li><li>uv_combinator</li><li>imanalytic</li><li>visanalytic</li><li>ComradeBase.intensity_point if model intensity is <code>IsAnalytic</code></li><li>intensitymap_numeric! if model intensity is <code>NotAnalytic</code></li><li>intensitymap_numeric if model intensity is <code>NotAnalytic</code></li><li>flux</li><li>radialextent</li></ul><p>In addition there are additional optional methods a person can define if needed:</p><ul><li>intensitymap_analytic! if model intensity is <code>IsAnalytic</code>  (optional)</li><li>intensitymap_analytic if model intensity is <code>IsAnalytic</code> (optional)</li><li>visibilities_analytic if visanalytic is <code>IsAnalytic</code> (optional)</li><li>visibilities_numeric  if visanalytic is <code>Not Analytic</code> (optional)</li><li>visibilities_analytic! if visanalytic is <code>IsAnalytic</code> (optional)</li><li>visibilities_numeric!  if visanalytic is <code>Not Analytic</code> (optional)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/combinators.jl#L3-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.AddModel" href="#VLBISkyModels.AddModel"><code>VLBISkyModels.AddModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AddModel{T1, T2} &lt;: VLBISkyModels.CompositeModel{T1, T2}</code></pre><p>Pointwise addition of two models in the image and visibility domain. An end user should instead call <a href="#VLBISkyModels.added"><code>added</code></a> or <code>Base.+</code> when constructing a model</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Disk() + Gaussian()
julia&gt; m2 = added(Disk(), Gaussian()) + Ring()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/combinators.jl#L76-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.ConvolvedModel" href="#VLBISkyModels.ConvolvedModel"><code>VLBISkyModels.ConvolvedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConvolvedModel{M1, M2} &lt;: VLBISkyModels.CompositeModel{M1, M2}</code></pre><p>Pointwise addition of two models in the image and visibility domain. An end user should instead call <a href="#VLBISkyModels.convolved"><code>convolved</code></a>. Also see <a href="#VLBISkyModels.smoothed"><code>smoothed(m, σ)</code></a> for a simplified function that convolves a model <code>m</code> with a Gaussian with standard deviation <code>σ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/combinators.jl#L242-L249">source</a></section></article><h3 id="Geometric-and-Image-Models"><a class="docs-heading-anchor" href="#Geometric-and-Image-Models">Geometric and Image Models</a><a id="Geometric-and-Image-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-and-Image-Models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.GeometricModel" href="#VLBISkyModels.GeometricModel"><code>VLBISkyModels.GeometricModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GeometricModel{T} &lt;: ComradeBase.AbstractModel</code></pre><p>A type that defines it is a geometric model. These are usually primitive models, and are usually analytic in Fourier and the image domain. As a result a user only needs to implement the following methods</p><ul><li><code>visibility_point</code></li><li><code>intensity_point</code></li><li><code>radialextent</code></li></ul><p>Note that if the geometric model isn&#39;t <strong>analytic</strong> then the usual methods listed in <a href="@ref"><code>ComradeBase.AbstractModel</code></a> for non-analytic models need to be implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/geometric_models.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.ConcordanceCrescent" href="#VLBISkyModels.ConcordanceCrescent"><code>VLBISkyModels.ConcordanceCrescent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConcordanceCrescent{T} &lt;: VLBISkyModels.GeometricModel{T}</code></pre><p>Creates the ConcordanceCrescent model, i.e. a flat-top crescent with a displacment and a slash and shadow depth. Note this creates a crescent with unit flux. If you want a different flux please use the <code>renomed</code> modifier.</p><p><strong>Fields</strong></p><ul><li><code>router</code>: Outer radius of the crescent</li></ul><ul><li><code>rinner</code>: Inner radius of the crescent (i.e. inside this radius there is a hole)</li></ul><ul><li><code>shift</code>: Displacment of the inner disk radius</li></ul><ul><li><code>slash</code>: Strength of the linear slash. Note that s∈[0.0,1.0] to ensure positivity in the image.</li></ul><p><strong>Notes</strong></p><p>Unlike the Gaussian and Disk models this does not create the unit version. In fact, this model could have been created using the <code>Disk</code> and primitives by using VLBISkyModels&#39;s model composition functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/geometric_models.jl#L361-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.Crescent" href="#VLBISkyModels.Crescent"><code>VLBISkyModels.Crescent</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Creates a <a href="https://academic.oup.com/mnras/article/434/1/765/1005984">Kamruddin and Dexter</a> crescent model. This works by composing two disk models together.</p><p><strong>Arguments</strong></p><ul><li><code>router</code>: The radius of the outer disk</li><li><code>rinner</code>: The radius of the inner disk</li><li><code>shift</code>: How much the inner disk radius is shifted (positive is to the right)</li><li><code>floor</code>: The floor of the inner disk 0 means the inner intensity is zero and 1 means it is a large disk.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/geometric_models.jl#L344-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.Disk" href="#VLBISkyModels.Disk"><code>VLBISkyModels.Disk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Disk{T}() where {T}</code></pre><p>Tophat disk geometrical model, i.e. the intensity profile</p><p class="math-container">\[    I(x,y) = \begin{cases} \pi^{-1} &amp; x^2+y^2 &lt; 1 \\ 0 &amp; x^2+y^2 \geq 0 \end{cases}\]</p><p>i.e. a unit radius and unit flux disk.</p><p>By default if T isn&#39;t given, <code>Disk</code> defaults to <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/geometric_models.jl#L65-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.SlashedDisk" href="#VLBISkyModels.SlashedDisk"><code>VLBISkyModels.SlashedDisk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SlashedDisk{T}(slash::T) where {T}</code></pre><p>Tophat disk geometrical model, i.e. the intensity profile</p><p class="math-container">\[    I(x,y) = \begin{cases} \pi^{-1} &amp; x^2+y^2 &lt; 1 \\ 0 &amp; x^2+y^2 \geq 0 \end{cases}\]</p><p>i.e. a unit radius and unit flux disk.</p><p>By default if T isn&#39;t given, <code>Disk</code> defaults to <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/geometric_models.jl#L93-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.ExtendedRing" href="#VLBISkyModels.ExtendedRing"><code>VLBISkyModels.ExtendedRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExtendedRing{T} &lt;: VLBISkyModels.GeometricModel{T}</code></pre><p>A symmetric extended ring whose radial profile follows an inverse gamma distributions.</p><p>The formula in the image domain is given by</p><pre><code class="nohighlight hljs">I(r,θ) = βᵅrᵅ⁻²exp(-β/r)/2πΓ(α)</code></pre><p>where <code>α = shape</code> and <code>β = shape+1</code></p><p><strong>Note</strong></p><p>We mainly use this as an example of a non-analytic Fourier transform (although it has a complicated expression)</p><p><strong>Fields</strong></p><ul><li><code>shape</code>: shape of the radial distribution</li></ul><p>Note that if <code>T</code> isn&#39;t specified at construction then it defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/geometric_models.jl#L441-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.Gaussian" href="#VLBISkyModels.Gaussian"><code>VLBISkyModels.Gaussian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Gaussian{T} &lt;: VLBISkyModels.GeometricModel{T}</code></pre><p>Gaussian with unit standard deviation and flux.</p><p>By default if T isn&#39;t given, <code>Gaussian</code> defaults to <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/geometric_models.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.MRing" href="#VLBISkyModels.MRing"><code>VLBISkyModels.MRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MRing{T, V&lt;:Union{AbstractArray{T, 1}, Tuple{Vararg{T, N}} where {N, T}}} &lt;: VLBISkyModels.GeometricModel{T}</code></pre><p>m-ring geometric model. This is a infinitely thin unit flux delta ring whose angular structure is given by a Fourier expansion. That is,</p><pre><code class="nohighlight hljs">I(r,θ) = (2π)⁻¹δ(r-1)∑ₙ(αₙcos(nθ) - βₙsin(nθ))</code></pre><p>The <code>N</code> in the type defines the order of the Fourier expansion.</p><p><strong>Fields</strong></p><ul><li><code>α</code>: Real Fourier mode coefficients</li></ul><ul><li><code>β</code>: Imaginary Fourier mode coefficients</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/geometric_models.jl#L198-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.Ring" href="#VLBISkyModels.Ring"><code>VLBISkyModels.Ring</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Ring{T} &lt;: VLBISkyModels.GeometricModel{T}</code></pre><p>A infinitely thin ring model, whose expression in the image domain is     I(r,θ) = δ(r - 1)/2π i.e. a unit radius and flux delta ring.</p><p>By default if <code>T</code> isn&#39;t given, <code>Gaussian</code> defaults to <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/geometric_models.jl#L138-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.ParabolicSegment" href="#VLBISkyModels.ParabolicSegment"><code>VLBISkyModels.ParabolicSegment</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ParabolicSegment{T} &lt;: VLBISkyModels.GeometricModel{T}</code></pre><p>A infinitely thin parabolic segment in the image domain. The segment is centered at zero, with roots ±1 and a yintercept of 1.</p><p>Note that if <code>T</code> isn&#39;t specified at construction then it defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/geometric_models.jl#L478-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.ContinuousImage" href="#VLBISkyModels.ContinuousImage"><code>VLBISkyModels.ContinuousImage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ContinuousImage{A&lt;:IntensityMap, P} &lt;: AbstractModel
ContinuousImage(img::Intensitymap, kernel)</code></pre><p>The basic continuous image model for VLBISkyModels. This expects a IntensityMap style object as its imag as well as a image kernel or pulse that allows you to evaluate the image at any image and visibility location. The image model is</p><pre><code class="nohighlight hljs">I(x,y) = ∑ᵢ Iᵢⱼ κ(x-xᵢ, y-yᵢ)</code></pre><p>where <code>Iᵢⱼ</code> are the flux densities of the image <code>img</code> and κ is the intensity function for the <code>kernel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/continuous_image.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.ZeroModel" href="#VLBISkyModels.ZeroModel"><code>VLBISkyModels.ZeroModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ZeroModel{T} &lt;: ComradeBase.AbstractModel</code></pre><p>Defines a model that is <code>empty</code> that is it return zero for everything.</p><p><strong>Notes</strong></p><p>This returns 0 by using <code>FillArrays</code> so everything should be non-allocating</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/misc.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.MultiComponentModel" href="#VLBISkyModels.MultiComponentModel"><code>VLBISkyModels.MultiComponentModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiComponentModel(beam::AbstractModel, fluxes::AbstractVector, x::AbstractVector, y::AbstractVector)</code></pre><p>Build a model with a base model type <code>beam</code> where fluxes, x, y corresond to the flux, and positions of the components. This can be used to easily construct clean like models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/clean.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.PolarizedModel" href="#VLBISkyModels.PolarizedModel"><code>VLBISkyModels.PolarizedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PolarizedModel{TI, TQ, TU, TV} &lt;: ComradeBase.AbstractPolarizedModel</code></pre><p>Wrapped model for a polarized model. This uses the stokes representation of the image.</p><p><strong>Fields</strong></p><ul><li><code>I</code>: Stokes I model</li></ul><ul><li><code>Q</code>: Stokes Q Model</li></ul><ul><li><code>U</code>: Stokes U Model</li></ul><ul><li><code>V</code>: Stokes V Model</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/polarized.jl#L5-L12">source</a></section></article><h3 id="Image-Pulses"><a class="docs-heading-anchor" href="#Image-Pulses">Image Pulses</a><a id="Image-Pulses-1"></a><a class="docs-heading-anchor-permalink" href="#Image-Pulses" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.Pulse" href="#VLBISkyModels.Pulse"><code>VLBISkyModels.Pulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pulse</code></pre><p>Pixel response function for a radio image model. This makes a discrete sampling continuous by picking a certain <em>smoothing</em> kernel for the image.</p><p><strong>Notes</strong></p><p>To see the implemented Pulses please use the subtypes function i.e. <code>subtypes(Pulse)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/pulse.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.DeltaPulse" href="#VLBISkyModels.DeltaPulse"><code>VLBISkyModels.DeltaPulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DeltaPulse{T} &lt;: VLBISkyModels.Pulse</code></pre><p>A dirac comb pulse function. This means the image is just the dicrete Fourier transform</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/pulse.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.BSplinePulse" href="#VLBISkyModels.BSplinePulse"><code>VLBISkyModels.BSplinePulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">$(TYPEDEF)</code></pre><p>Uses the basis spline (BSpline) kernel of order <code>N</code>. These are the kernel that come from recursively convolving the tophat kernel</p><p class="math-container">\[    B_0(x) = \begin{cases} 1 &amp; |x| &lt; 1 \\ 0 &amp; otherwise \end{cases}\]</p><p><code>N</code> times.</p><p><strong>Notes</strong></p><p>BSpline kernels have a number of nice properties:</p><ol><li>Simple frequency response <span>$\sinc(u/2)^N$</span></li><li>preserve total intensity</li></ol><p>For <code>N</code>&gt;1 these kernels aren&#39;t actually interpolation kernels however, this doesn&#39;t matter for us.</p><p>Currently only the 0,1,3 order kernels are implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/pulse.jl#L39-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.RaisedCosinePulse" href="#VLBISkyModels.RaisedCosinePulse"><code>VLBISkyModels.RaisedCosinePulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RaisedCosinePulse{T} &lt;: VLBISkyModels.Pulse</code></pre><pre><code class="nohighlight hljs">RaisedCosinePulse()
RaisedCosinePulse(rolloff)</code></pre><p>Raised cosine pulse function. This tends to be a very flat response, where the roll off controls the speed of decay. By default we set <code>rolloff = 0.5</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/pulse.jl#L118-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.BicubicPulse" href="#VLBISkyModels.BicubicPulse"><code>VLBISkyModels.BicubicPulse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BicubicPulse{T} &lt;: VLBISkyModels.Pulse</code></pre><pre><code class="nohighlight hljs">BicubicPulse(b = 0.5)</code></pre><p>The bicubic pulse for imaging. This pulse tends to have a flat spectrum but for most values of <code>b</code> can produce negative intensities in an image. This is the pulse used in <a href="https://iopscience.iop.org/article/10.3847/1538-4357/ab9c1f"><code>Broderick et al. 2020</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/pulse.jl#L81-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.Butterworth" href="#VLBISkyModels.Butterworth"><code>VLBISkyModels.Butterworth</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Butterworth{N}()
Butterworth{N, T}()</code></pre><p>Construct a model that corresponds to the Butterworth filter of order <code>N</code>. The type of the output is given by <code>T</code> and if not given defaults to <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/geometric_models.jl#L174-L180">source</a></section></article><h3 id="Model-Image-(non-analytic-FFT)"><a class="docs-heading-anchor" href="#Model-Image-(non-analytic-FFT)">Model Image (non analytic FFT)</a><a id="Model-Image-(non-analytic-FFT)-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Image-(non-analytic-FFT)" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.create_cache" href="#VLBISkyModels.create_cache"><code>VLBISkyModels.create_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_cache(alg::AbstractFourierTransform, img::AbstractIntensityMap)</code></pre><p>Creates a Fourier transform cache for a img using algorithm <code>alg</code>. For non-analytic visibility models this can significantly speed up computations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; u,v = rand(100), rand(100)
julia&gt; cache = create_cache(DFTAlg(u, v), IntensityMap(randn(50,50), 10.0, 10.0))
julia&gt; cache = create_cache(NFFTAlg(u, v), IntensityMap(randn(50,50), 10.0, 10.0))
julia&gt; cache = create_cache(FFTAlg(), IntensityMap(randn(50,50), 10.0, 10.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modelimage/cache.jl#L16-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.update_cache" href="#VLBISkyModels.update_cache"><code>VLBISkyModels.update_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_cache(cache, img)</code></pre><p>Update the Fourier transform cache. This will reuse an FFT/NFFT plan saving some computational time.</p><p><strong>Note</strong></p><p>This is an intenal method than an end user shouldn&#39;t have to usually call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modelimage/cache.jl#L33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.modelimage" href="#VLBISkyModels.modelimage"><code>VLBISkyModels.modelimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modelimage(model::AbstractModel, image::AbstractIntensityMap, alg=FFTAlg())</code></pre><p>Construct a <code>ModelImage</code> from a <code>model</code>, <code>image</code> and the optionally specified visibility algorithm <code>alg</code></p><p><strong>Notes</strong></p><p>For analytic models this is a no-op and returns the model. For non-analytic models this creates a <code>ModelImage</code> object which uses <code>alg</code> to compute the non-analytic Fourier transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modelimage/modelimage.jl#L74-L84">source</a></section><section><div><pre><code class="nohighlight hljs">modelimage(model, cache::AbstractCach))</code></pre><p>Construct a <code>ModelImage</code> from the <code>model</code> and using a precompute Fourier transform <code>cache</code>. You can optionally specify th which will compute the internal image buffer using the`.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = ExtendedRing(10.0)
julia&gt; cache = create_cache(DFTAlg(), IntensityMap(zeros(128, 128), 50.0, 50.0)) # used threads to make the image
julia&gt; mimg = modelimage(m, cache, true)</code></pre><p><strong>Notes</strong></p><p>For analytic models this is a no-op and returns the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modelimage/modelimage.jl#L118-L136">source</a></section><section><div><pre><code class="nohighlight hljs">modelimage(m;
           fovx=2*radialextent(m),
           fovy=2*radialextent(m),
           nx=512,
           ny=512,
           alg=FFTAlg(),
           pulse=ComradeBase.DeltaPulse(),
            )</code></pre><p>Construct a <code>ModelImage</code> where just the model <code>m</code> is specified.</p><p>If <code>fovx</code> or <code>fovy</code> aren&#39;t given <code>modelimage</code> will <em>guess</em> a reasonable field of view based on the <code>radialextent</code> function. <code>nx</code> and <code>ny</code> are the number of pixels in the x and y direction. The <code>pulse</code> is the pulse used for the image and <code>alg</code></p><p><strong>Notes</strong></p><p>For analytic models this is a no-op and returns the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modelimage/modelimage.jl#L150-L169">source</a></section><section><div><pre><code class="nohighlight hljs">modelimage(img::ContinuousImage, alg=NFFTAlg())</code></pre><p>Create a model image directly using an image, i.e. treating it as the model. You can optionally specify the Fourier transform algorithm using <code>alg</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/continuous_image.jl#L102-L107">source</a></section><section><div><pre><code class="nohighlight hljs">modelimage(img::ContinuousImage, cache::AbstractCache)</code></pre><p>Create a model image directly using an image, i.e. treating it as the model. Additionally reuse a previously compute image <code>cache</code>. This can be used when directly modeling an image of a fixed size and number of pixels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/continuous_image.jl#L113-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.uviterator" href="#VLBISkyModels.uviterator"><code>VLBISkyModels.uviterator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uviterator(nx, dx, ny dy)</code></pre><p>Construct the u,v iterators for the Fourier transform of the image with pixel sizes <code>dx, dy</code> and number of pixels <code>nx, ny</code></p><p>If you are extending Fourier transform stuff please use these functions to ensure that the centroid is being properly computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modelimage/fft_alg.jl#L196-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.fouriermap" href="#VLBISkyModels.fouriermap"><code>VLBISkyModels.fouriermap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fouriermap(m, x)</code></pre><p>Create a Fourier or visibility map of a model <code>m</code> where the image is specified in the image domain by the pixel locations <code>x</code> and <code>y</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modelimage/fft_alg.jl#L221-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.ModelImage" href="#VLBISkyModels.ModelImage"><code>VLBISkyModels.ModelImage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ModelImage{M, I, C} &lt;: VLBISkyModels.AbstractModelImage{M}</code></pre><p>Container for non-analytic model that contains a image cache which will hold the image, a Fourier transform cache, which usually an instance of a &lt;: FourierCache.</p><p><strong>Note</strong></p><p>This is an internal implementation detail that shouldn&#39;t usually be called directly. Instead the user should use the exported function <code>modelimage</code>, for example</p><pre><code class="language-julia hljs">using Comrade
m = ExtendedRing(20.0, 5.0)

# This creates an version where the image is dynamically specified according to the
# radial extent of the image
mimg = modelimage(m) # you can also optionally pass the number of pixels nx and ny

# Or you can create an IntensityMap
img = intensitymap(m, 100.0, 100.0, 512, 512)
mimg = modelimage(m, img)

# Or precompute a cache
cache = create_cache(FFTAlg(), img)
mimg = modelimage(m, cache)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modelimage/modelimage.jl#L3-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.DFTAlg" href="#VLBISkyModels.DFTAlg"><code>VLBISkyModels.DFTAlg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DFTAlg</code></pre><p>Uses a discrete fourier transform. This is not very efficient for larger images. In those cases  NFFTAlg or FFTAlg are more reasonable. For small images this is a reasonable choice especially since it&#39;s easy to define derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modelimage/nuft.jl#L156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.FFTAlg" href="#VLBISkyModels.FFTAlg"><code>VLBISkyModels.FFTAlg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FFTAlg &lt;: VLBISkyModels.FourierTransform</code></pre><p>Use an FFT to compute the approximate numerical visibilities of a model. For a DTFT see <a href="#VLBISkyModels.DFTAlg"><code>DFTAlg</code></a> or for an NFFT <a href="#VLBISkyModels.NFFTAlg"><code>NFFTAlg</code></a></p><p><strong>Fields</strong></p><ul><li><code>padfac</code>: The amount to pad the image by. Note we actually round up to the nearest factor of 2, but this will be improved in the future to use small primes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modelimage/cache.jl#L45-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.FFTCache" href="#VLBISkyModels.FFTCache"><code>VLBISkyModels.FFTCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FFTCache{A&lt;:FFTAlg, P, I, Pu, S} &lt;: VLBISkyModels.AbstractCache</code></pre><p>The cache used when the <code>FFT</code> algorithm is used to compute visibilties. This is an internal type and is not part of the public API</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modelimage/fft_alg.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.NFFTAlg" href="#VLBISkyModels.NFFTAlg"><code>VLBISkyModels.NFFTAlg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NFFTAlg</code></pre><p>Uses a non-uniform FFT to compute the visibilities. You can optionally pass uv which are the uv positions you will compute the NFFT at. This can allow for the NFFT plan to be cached improving performance</p><p><strong>Fields</strong></p><ul><li><code>padfac</code>: Amount to pad the image</li></ul><ul><li><code>m</code>: Kernel size parameters. This controls the accuracy of NFFT you do not usually need to change this</li></ul><ul><li><code>σ</code>: Over sampling factor. This controls the accuracy of NFFT you do not usually need to change this.</li></ul><ul><li><code>window</code>: Window function for the NFFT. You do not usually need to change this</li></ul><ul><li><code>precompute</code>: NFFT interpolation algorithm.</li></ul><ul><li><code>blocking</code>: Flag block partioning should be used to speed up computation</li></ul><ul><li><code>sortNodes</code>: Flag if the node should be sorted in a lexicographic way</li></ul><ul><li><code>storeDeconvolutionIdx</code>: Flag if the deconvolve indices should be stored, Currently required for GPU</li></ul><ul><li><code>fftflags</code>: Flag passed to inner AbstractFFT. The fastest FFTW is FFTW.MEASURE but takes the longest to precompute</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modelimage/nuft.jl#L104-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.NUFTCache" href="#VLBISkyModels.NUFTCache"><code>VLBISkyModels.NUFTCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NUFTCache{A, P, M, PI, I} &lt;: VLBISkyModels.AbstractCache</code></pre><p>Internal type used to store the cache for a non-uniform Fourier transform (NUFT).</p><p>The user should instead create this using the <a href="#VLBISkyModels.create_cache"><code>create_cache</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modelimage/cache.jl#L88-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.ObservedNUFT" href="#VLBISkyModels.ObservedNUFT"><code>VLBISkyModels.ObservedNUFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ObservedNUFT{A&lt;:VLBISkyModels.NUFT, T} &lt;: VLBISkyModels.NUFT</code></pre><p>Container type for a non-uniform Fourier transform (NUFT). This stores the uv-positions that the model will be sampled at in the Fourier domain, allowing certain transformtion factors (e.g., NUFT matrix) to be cached.</p><p>This is an internal type, an end user should instead create this using <a href="#VLBISkyModels.NFFTAlg"><code>NFFTAlg</code></a> or <a href="#VLBISkyModels.DFTAlg"><code>DFTAlg</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modelimage/cache.jl#L66-L75">source</a></section></article><h3 id="Modifiers"><a class="docs-heading-anchor" href="#Modifiers">Modifiers</a><a id="Modifiers-1"></a><a class="docs-heading-anchor-permalink" href="#Modifiers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.modify" href="#VLBISkyModels.modify"><code>VLBISkyModels.modify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modify(m::AbstractModel, transforms...)</code></pre><p>Modify a given <code>model</code> using the set of <code>transforms</code>. This is the most general function that allows you to apply a sequence of model transformation for example</p><pre><code class="language-julia-repl hljs">modify(Gaussian(), Stretch(2.0, 1.0), Rotate(π/4), Shift(1.0, 2.0), Renorm(2.0))</code></pre><p>will create a asymmetric Gaussian with position angle <code>π/4</code> shifted to the position (1.0, 2.0) with a flux of 2 Jy. This is similar to Flux&#39;s chain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L199-L210">source</a></section><section><div><pre><code class="nohighlight hljs">modify(img::IntensityMap, transforms...)</code></pre><p>This modifies the <code>img</code> by applying the <code>transforms...</code> returning a transformed <code>IntensityMap</code></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>Unlike when <code>modify</code> is applied to a <code>&lt;:AbstractModel</code> this returns an already modified image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/utility.jl#L46-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.basemodel" href="#VLBISkyModels.basemodel"><code>VLBISkyModels.basemodel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basemodel(model::ModifiedModel)</code></pre><p>Returns the ModifiedModel with the last transformation stripped.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; basemodel(stretched(Disk(), 1.0, 2.0)) == Disk()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L118-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.unmodified" href="#VLBISkyModels.unmodified"><code>VLBISkyModels.unmodified</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unmodified(model::ModifiedModel)</code></pre><p>Returns the un-modified model</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = stretched(rotated(Gaussian(), π/4), 2.0, 1.0)
julia&gt; umodified(m) == Gaussian()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L103-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.renormed" href="#VLBISkyModels.renormed"><code>VLBISkyModels.renormed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">renormed(model, f)
</code></pre><p>Renormalizes the model <code>m</code> to have total flux <code>f*flux(m)</code>. This can also be done directly by calling <code>Base.:*</code> i.e.,</p><pre><code class="language-julia-repl hljs">julia&gt; renormed(m, f) == f*M
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L453-L463">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.rotated" href="#VLBISkyModels.rotated"><code>VLBISkyModels.rotated</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotated(model, ξ)
</code></pre><p>Rotates the model by an amount <code>ξ</code> in radians in the clockwise direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L555-L559">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.posangle" href="#VLBISkyModels.posangle"><code>VLBISkyModels.posangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">posangle(model)
</code></pre><p>Returns the rotation angle of the rotated <code>model</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L562-L566">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.shifted" href="#VLBISkyModels.shifted"><code>VLBISkyModels.shifted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shifted(model, Δx, Δy)
</code></pre><p>Shifts the model <code>m</code> in the image domain by an amount <code>Δx,Δy</code> in the x and y directions respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L414-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.stretched" href="#VLBISkyModels.stretched"><code>VLBISkyModels.stretched</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stretched(model, α, β)
</code></pre><p>Stretches the model <code>m</code> according to the formula     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L515-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.ModifiedModel" href="#VLBISkyModels.ModifiedModel"><code>VLBISkyModels.ModifiedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ModifiedModel{M&lt;:ComradeBase.AbstractModel, T&lt;:Tuple} &lt;: ComradeBase.AbstractModel</code></pre><p>Container type for models that have been transformed in some way. For a list of potential modifiers or transforms see <code>subtypes(ModelModifiers)</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>model</code>: base model</p></li><li><p><code>transform</code>: model transforms</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L75-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.ModelModifier" href="#VLBISkyModels.ModelModifier"><code>VLBISkyModels.ModelModifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ModelModifier{T}</code></pre><p>General type for a model modifier. These transform any model using simple Fourier transform properties. To modify a model you can use the <a href="#VLBISkyModels.ModifiedModel"><code>ModifiedModel</code></a> constructor or the <a href="#VLBISkyModels.modify"><code>modify</code></a> function.</p><pre><code class="language-julia-repl hljs">julia&gt; visanalytic(stretched(Disk(), 2.0, 2.0)) == visanalytic(Disk())
true</code></pre><p>To implement a model transform you need to specify the following methods:</p><ul><li><a href="#VLBISkyModels.transform_uv"><code>transform_uv</code></a></li><li><a href="#VLBISkyModels.transform_image"><code>transform_image</code></a></li><li><a href="#VLBISkyModels.scale_uv"><code>scale_uv</code></a></li><li><a href="#VLBISkyModels.scale_image"><code>scale_image</code></a></li><li><a href="@ref"><code>radialextent</code></a></li></ul><p>See thee docstrings of those methods for guidance on implementation details.</p><p>Additionally these methods assume the modifiers are of the form</p><p>I(x,y) -&gt; fᵢ(x,y)I(gᵢ(x,y)) V(u,v) -&gt; fᵥ(u,v)V(gᵥ(u,v))</p><p>where <code>g</code> are the transform<em>image/uv functions and <code>f</code> are the scale</em>image/uv function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L4-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.Stretch" href="#VLBISkyModels.Stretch"><code>VLBISkyModels.Stretch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Stretch(α, β)
Stretch(r)</code></pre><p>Stretched the model in the x and y directions, i.e. the new intensity is     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; modify(Gaussian(), Stretch(2.0)) == stretched(Gaussian(), 2.0, 1.0)
true</code></pre><p>If only a single argument is given it assumes the same stretch is applied in both direction.</p><pre><code class="language-julia-repl hljs">julia&gt; Stretch(2.0) == Stretch(2.0, 2.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L485-L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.Shift" href="#VLBISkyModels.Shift"><code>VLBISkyModels.Shift</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Shift{T} &lt;: VLBISkyModels.ModelModifier{T}</code></pre><p>Shifts the model by <code>Δx</code> units in the x-direction and <code>Δy</code> units in the y-direction.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; modify(Gaussian(), Shift(2.0, 1.0)) == shifted(Gaussian(), 2.0, 1.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L392-L403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.Rotate" href="#VLBISkyModels.Rotate"><code>VLBISkyModels.Rotate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Rotate(ξ)</code></pre><p>Type for the rotated model. This is more fine grained constrol of rotated model.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; modify(Gaussian(), Rotate(2.0)) == rotated(Gaussian(), 2.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L533-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.Renormalize" href="#VLBISkyModels.Renormalize"><code>VLBISkyModels.Renormalize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Renormalize{T} &lt;: VLBISkyModels.ModelModifier{T}</code></pre><p>Renormalizes the flux of the model to the new value <code>scale*flux(model)</code>. We have also overloaded the Base.:* operator as syntactic sugar although I may get rid of this.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; modify(Gaussian(), Renormalize(2.0)) == 2.0*Gaussian()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L433-L446">source</a></section></article><h3 id="Model-Evaluation"><a class="docs-heading-anchor" href="#Model-Evaluation">Model Evaluation</a><a id="Model-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Evaluation" title="Permalink"></a></h3><p>For more docstrings on how to evaluate models see <a href="https://github.com/ptiede/ComradeBase.jl">ComradeBase</a>.</p><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.amplitude" href="#VLBISkyModels.amplitude"><code>VLBISkyModels.amplitude</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">amplitude(model, p)</code></pre><p>Computes the visibility amplitude of model <code>m</code> at the coordinate <code>p</code>. The coordinate <code>p</code> is expected to have the properties <code>U</code>, <code>V</code>, and sometimes <code>Ti</code> and <code>Fr</code>.</p><p>If you want to compute the amplitudes at a large number of positions consider using the <code>amplitudes</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/methods.jl#L19-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.amplitudes" href="#VLBISkyModels.amplitudes"><code>VLBISkyModels.amplitudes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">amplitudes(m::AbstractModel, u::AbstractArray, v::AbstractArray)</code></pre><p>Computes the visibility amplitudes of the model <code>m</code> at the coordinates <code>p</code>. The coordinates <code>p</code> are expected to have the properties <code>U</code>, <code>V</code>, and sometimes <code>Ti</code> and <code>Fr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/methods.jl#L140-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.bispectra" href="#VLBISkyModels.bispectra"><code>VLBISkyModels.bispectra</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bispectra(m, p1, p2, p3)</code></pre><p>Computes the closure phases of the model <code>m</code> at the triangles p1, p2, p3, where <code>pi</code> are coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/methods.jl#L171-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.bispectrum" href="#VLBISkyModels.bispectrum"><code>VLBISkyModels.bispectrum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bispectrum(model, p1, p2, p3)</code></pre><p>Computes the complex bispectrum of model <code>m</code> at the uv-triangle p1 -&gt; p2 -&gt; p3</p><p>If you want to compute the bispectrum over a number of triangles consider using the <code>bispectra</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/methods.jl#L33-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.closure_phase" href="#VLBISkyModels.closure_phase"><code>VLBISkyModels.closure_phase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closure_phase(model, p1, p2, p3, p4)</code></pre><p>Computes the closure phase of model <code>m</code> at the uv-triangle u1,v1 -&gt; u2,v2 -&gt; u3,v3</p><p>If you want to compute closure phases over a number of triangles consider using the <code>closure_phases</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/methods.jl#L46-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.closure_phases" href="#VLBISkyModels.closure_phases"><code>VLBISkyModels.closure_phases</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closure_phases(m,
               p1::AbstractArray
               p2::AbstractArray
               p3::AbstractArray
               )</code></pre><p>Computes the closure phases of the model <code>m</code> at the triangles p1, p2, p3, where <code>pi</code> are coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/methods.jl#L214-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.logclosure_amplitude" href="#VLBISkyModels.logclosure_amplitude"><code>VLBISkyModels.logclosure_amplitude</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logclosure_amplitude(model, p1, p2, p3, p4)</code></pre><p>Computes the log-closure amplitude of model <code>m</code> at the uv-quadrangle u1,v1 -&gt; u2,v2 -&gt; u3,v3 -&gt; u4,v4 using the formula</p><p class="math-container">\[C = \log\left|\frac{V(u1,v1)V(u2,v2)}{V(u3,v3)V(u4,v4)}\right|\]</p><p>If you want to compute log closure amplitudes over a number of triangles consider using the <code>logclosure_amplitudes</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/methods.jl#L59-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.logclosure_amplitudes" href="#VLBISkyModels.logclosure_amplitudes"><code>VLBISkyModels.logclosure_amplitudes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logclosure_amplitudes(m::AbstractModel,
                      p1,
                      p2,
                      p3,
                      p4
                     )</code></pre><p>Computes the log closure amplitudes of the model <code>m</code> at the quadrangles p1, p2, p3, p4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/methods.jl#L249-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.visibility" href="#VLBISkyModels.visibility"><code>VLBISkyModels.visibility</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visibility(mimg, p)</code></pre><p>Computes the complex visibility of model <code>m</code> at coordinates <code>p</code>. <code>p</code> corresponds to the coordinates of the model. These need to have the properties <code>U</code>, <code>V</code> and sometimes <code>Ti</code> for time and <code>Fr</code> for frequency.</p><p><strong>Notes</strong></p><p>If you want to compute the visibilities at a large number of positions consider using the <a href="@ref visibilities"><code>visibilities</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/methods.jl#L1-L11">source</a></section></article><h2 id="Internal-(Not-Public-API)"><a class="docs-heading-anchor" href="#Internal-(Not-Public-API)">Internal (Not Public API)</a><a id="Internal-(Not-Public-API)-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-(Not-Public-API)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.scale_uv" href="#VLBISkyModels.scale_uv"><code>VLBISkyModels.scale_uv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scale_image(model::AbstractModifier, u, u)</code></pre><p>Returns a number on how to scale the image visibility at <code>u</code> <code>v</code> for an modified <code>model</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.scale_image" href="#VLBISkyModels.scale_image"><code>VLBISkyModels.scale_image</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scale_image(model::AbstractModifier, x, y)</code></pre><p>Returns a number of how to to scale the image intensity at <code>x</code> <code>y</code> for an modified <code>model</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.transform_uv" href="#VLBISkyModels.transform_uv"><code>VLBISkyModels.transform_uv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_uv(model::AbstractModifier, u, u)</code></pre><p>Returns a transformed <code>u</code> and <code>v</code> according to the <code>model</code> modifier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.transform_image" href="#VLBISkyModels.transform_image"><code>VLBISkyModels.transform_image</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_image(model::AbstractModifier, x, y)</code></pre><p>Returns a transformed <code>x</code> and <code>y</code> according to the <code>model</code> modifier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/modifiers.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VLBISkyModels.ThreadedModel" href="#VLBISkyModels.ThreadedModel"><code>VLBISkyModels.ThreadedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ThreadedModel</code></pre><p>Experimental model wrapper than enables multi-threading when evaluating <code>intensitymap</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/VLBISkyModels.jl/blob/fc61c697fdfdb36b10121d662c962842cd698a47/src/models/threaded.jl#L3-L6">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/">« Model Interface</a><a class="docs-footer-nextpage" href="../examples/nonanalytic/">Modeling with non-analytic Fourier transforms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 23 July 2023 23:10">Sunday 23 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
